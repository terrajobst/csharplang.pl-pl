---
ms.openlocfilehash: ff31585520c9090ad92893a930327112743c8e77
ms.sourcegitcommit: 892af9016b3317a8fae12d195014dc38ba51cf16
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/01/2019
ms.locfileid: "71704003"
---
# <a name="basic-concepts"></a><span data-ttu-id="4e268-101">Podstawowe pojęcia</span><span class="sxs-lookup"><span data-stu-id="4e268-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="4e268-102">Uruchamianie aplikacji</span><span class="sxs-lookup"><span data-stu-id="4e268-102">Application Startup</span></span>

<span data-ttu-id="4e268-103">Zestaw, który ma ***punkt wejścia*** , nosi nazwę ***aplikacji***.</span><span class="sxs-lookup"><span data-stu-id="4e268-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="4e268-104">Po uruchomieniu aplikacji zostanie utworzona nowa ***domena aplikacji*** .</span><span class="sxs-lookup"><span data-stu-id="4e268-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="4e268-105">Kilka różnych wystąpień aplikacji może istnieć na tym samym komputerze w tym samym czasie, a każda z nich ma własną domenę aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="4e268-106">Domena aplikacji umożliwia izolację aplikacji, działając jako kontener dla stanu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="4e268-107">Domena aplikacji pełni rolę kontenera i granicy dla typów zdefiniowanych w aplikacji i używanych przez niego bibliotek klas.</span><span class="sxs-lookup"><span data-stu-id="4e268-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="4e268-108">Typy ładowane do jednej domeny aplikacji różnią się od tego samego typu, który został załadowany do innej domeny aplikacji, a wystąpienia obiektów nie są bezpośrednio udostępniane między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="4e268-109">Na przykład Każda domena aplikacji ma własną kopię zmiennych statycznych dla tych typów, a Konstruktor statyczny dla typu jest uruchamiany maksymalnie raz dla każdej domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="4e268-110">Implementacje mogą być bezpłatne, aby zapewnić zasady i mechanizmy specyficzne dla implementacji dotyczące tworzenia i niszczenia domen aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="4e268-111">***Uruchamianie aplikacji*** występuje, gdy środowisko wykonawcze wywołuje wydaną metodę, która jest określana jako punkt wejścia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="4e268-112">Ta metoda punktu wejścia ma zawsze nazwę `Main`i może mieć jeden z następujących sygnatur:</span><span class="sxs-lookup"><span data-stu-id="4e268-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="4e268-113">Jak pokazano, punkt wejścia może opcjonalnie zwrócić wartość `int`.</span><span class="sxs-lookup"><span data-stu-id="4e268-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="4e268-114">Ta wartość zwracana jest używana podczas kończenia aplikacji ([zakończenie aplikacji](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="4e268-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="4e268-115">Punkt wejścia może opcjonalnie mieć jeden parametr formalny.</span><span class="sxs-lookup"><span data-stu-id="4e268-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="4e268-116">Parametr może mieć dowolną nazwę, ale typem parametru musi być `string[]`.</span><span class="sxs-lookup"><span data-stu-id="4e268-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="4e268-117">Jeśli parametr formalny jest obecny, środowisko wykonawcze tworzy i przekazuje argument `string[]` zawierający argumenty wiersza polecenia, które zostały określone podczas uruchamiania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="4e268-118">Argument `string[]` nigdy nie ma wartości null, ale może mieć długość zero, jeśli nie określono żadnych argumentów wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="4e268-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="4e268-119">Ponieważ C# obsługuje Przeciążenie metod, Klasa lub struktura może zawierać wiele definicji niektórych metod, pod warunkiem, że każda z nich ma inną sygnaturę.</span><span class="sxs-lookup"><span data-stu-id="4e268-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="4e268-120">Jednak w ramach jednego programu żadna Klasa lub struktura nie może zawierać więcej niż jednej metody o nazwie `Main` której definicja kwalifikuje się do użycia jako punkt wejścia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="4e268-121">Inne przeciążone wersje `Main` są dozwolone, jednak pod warunkiem, że mają więcej niż jeden parametr, lub tylko ich parametr jest inny niż typ `string[]`.</span><span class="sxs-lookup"><span data-stu-id="4e268-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="4e268-122">Aplikacja może składać się z wielu klas lub struktur.</span><span class="sxs-lookup"><span data-stu-id="4e268-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="4e268-123">Istnieje możliwość, że więcej niż jedna z tych klas lub struktur będzie zawierać metodę o nazwie `Main` której definicja kwalifikuje się do użycia jako punkt wejścia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="4e268-124">W takich przypadkach mechanizm zewnętrzny (na przykład opcja kompilatora wiersza polecenia) musi zostać użyty do wybrania jednej z tych `Main` metod jako punktu wejścia.</span><span class="sxs-lookup"><span data-stu-id="4e268-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="4e268-125">W C#programie każda metoda musi być zdefiniowana jako element członkowski klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="4e268-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="4e268-126">Zwykle zadeklarowana dostępność ([zadeklarowana dostępność](basic-concepts.md#declared-accessibility)) metody jest określana przez Modyfikatory dostępu ([Modyfikatory dostępu](classes.md#access-modifiers)) określone w swojej deklaracji, a podobnie zadeklarowana dostępność typu jest określana przez Modyfikatory dostępu określone w jego deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="4e268-127">Aby można było wywołać daną metodę danego typu, zarówno typ, jak i element członkowski muszą być dostępne.</span><span class="sxs-lookup"><span data-stu-id="4e268-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="4e268-128">Jednak punkt wejścia aplikacji jest szczególnym przypadkiem.</span><span class="sxs-lookup"><span data-stu-id="4e268-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="4e268-129">W szczególności środowisko wykonawcze może uzyskać dostęp do punktu wejścia aplikacji niezależnie od jego zadeklarowanej dostępności i bez względu na zadeklarowaną dostępność jego deklaracji typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="4e268-130">Metoda punktu wejścia aplikacji nie może znajdować się w deklaracji klasy ogólnej.</span><span class="sxs-lookup"><span data-stu-id="4e268-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="4e268-131">We wszystkich innych aspektach metody punktu wejścia zachowują się jak te, które nie są punktami wejścia.</span><span class="sxs-lookup"><span data-stu-id="4e268-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="4e268-132">Zakończenie aplikacji</span><span class="sxs-lookup"><span data-stu-id="4e268-132">Application termination</span></span>

<span data-ttu-id="4e268-133">***Zakończenie aplikacji*** zwraca kontrolę do środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="4e268-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="4e268-134">Jeśli zwracany typ metody ***punktu wejścia*** aplikacji jest `int`, zwracana wartość służy jako ***kod stanu zakończenia***aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="4e268-135">Celem tego kodu jest umożliwienie komunikacji sukcesu lub niepowodzenia środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="4e268-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="4e268-136">Jeśli zwracanym typem metody punktu wejścia jest `void`, osiągnięcie prawego nawiasu klamrowego (`}`), który kończy tę metodę, lub wykonywanie instrukcji `return`, która nie ma wyrażenia, powoduje kod stanu zakończenia `0`.</span><span class="sxs-lookup"><span data-stu-id="4e268-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="4e268-137">Przed zakończeniem działania aplikacji są wywoływane destruktory dla wszystkich obiektów, które nie zostały jeszcze pobrane jako elementy bezużyteczne, chyba że takie oczyszczanie zostało pominięte (przez wywołanie metody biblioteki `GC.SuppressFinalize`, na przykład).</span><span class="sxs-lookup"><span data-stu-id="4e268-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="4e268-138">Deklaracje</span><span class="sxs-lookup"><span data-stu-id="4e268-138">Declarations</span></span>

<span data-ttu-id="4e268-139">Deklaracje w C# programie definiują elementy składowe programu.</span><span class="sxs-lookup"><span data-stu-id="4e268-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="4e268-140">C#programy są zorganizowane przy użyciu przestrzeni nazw ([przestrzenie nazw](namespaces.md)), które mogą zawierać deklaracje typów i zagnieżdżone deklaracje przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="4e268-141">Deklaracje typów ([deklaracje typów](namespaces.md#type-declarations)) służą do definiowania klas ([klas](classes.md)), struktur ([struktur](structs.md)), interfejsów ([interfejsów](interfaces.md)), wyliczeniowych ([wyliczeniowych](enums.md)) i delegatów ([delegatów](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="4e268-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="4e268-142">Rodzaje elementów członkowskich dozwolone w deklaracji typu zależą od formy deklaracji typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="4e268-143">Na przykład deklaracji klasy mogą zawierać deklaracje dla stałych ([stałych](classes.md#constants)), pól ([pól](classes.md#fields)), metod ([metod](classes.md#methods)), właściwości ([Właściwości](classes.md#properties)), zdarzeń ([zdarzeń](classes.md#events)), indeksatorów ([indeksatorów](classes.md#indexers)), operatorów ([operatorów](classes.md#operators)), konstruktorów wystąpień ([konstruktorów wystąpień](classes.md#instance-constructors)), konstruktorów statycznych ([konstruktorów statycznych](classes.md#static-constructors)), destruktorów ([destruktorów](classes.md#destructors)) i typów zagnieżdżonych ([typy zagnieżdżone](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="4e268-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="4e268-144">Deklaracja definiuje nazwę w ***obszarze deklaracji*** , do którego należy deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="4e268-145">Z wyjątkiem przeciążonych elementów członkowskich ([sygnatur i Przeciążenie](basic-concepts.md#signatures-and-overloading)), jest to błąd czasu kompilacji, który ma dwie lub więcej deklaracji, które wprowadzają elementy członkowskie o tej samej nazwie w obszarze deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="4e268-146">Nie jest możliwe, aby miejsce deklaracji zawierało różne rodzaje składowych o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="4e268-147">Na przykład obszar deklaracji nigdy nie może zawierać pola i metody o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="4e268-148">Istnieje kilka różnych typów obszarów deklaracji, zgodnie z opisem w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="4e268-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="4e268-149">W ramach wszystkich plików źródłowych programu *namespace_member_declaration*s bez otaczających *namespace_declaration* są członkami pojedynczej, połączonej przestrzeni deklaracji nazywanej ***przestrzenią globalną deklaracji***.</span><span class="sxs-lookup"><span data-stu-id="4e268-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="4e268-150">W ramach wszystkich plików źródłowych programu *namespace_member_declaration*s w *namespace_declaration*s, które mają taką samą w pełni kwalifikowaną nazwę przestrzeni nazw, są członkami pojedynczej złożonej deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="4e268-151">Każda klasa, struktura lub Deklaracja interfejsu tworzy nową przestrzeń deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="4e268-152">Nazwy są wprowadzane do tego obszaru deklaracji za poorednictwem *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s lub *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4e268-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="4e268-153">Z wyjątkiem deklaracji konstruktora wystąpień przeciążonych i deklaracji konstruktora statycznego Klasa lub struktura nie może zawierać deklaracji składowej o takiej samej nazwie jak Klasa lub struktura.</span><span class="sxs-lookup"><span data-stu-id="4e268-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="4e268-154">Klasa, struktura lub interfejs umożliwia deklarację przeciążonych metod i indeksatorów.</span><span class="sxs-lookup"><span data-stu-id="4e268-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="4e268-155">Ponadto Klasa lub struktura zezwala na deklarację konstruktorów przeciążonych wystąpień i operatorów.</span><span class="sxs-lookup"><span data-stu-id="4e268-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="4e268-156">Na przykład Klasa, struktura lub interfejs może zawierać wiele deklaracji metody o tej samej nazwie, pod warunkiem, że te deklaracje metod różnią się w sygnaturze ([sygnatur i Przeciążenie](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="4e268-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="4e268-157">Należy zauważyć, że klasy bazowe nie przyczyniają się do przestrzeni deklaracji klasy, a interfejsy podstawowe nie przyczyniają się do obszaru deklaracji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="4e268-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="4e268-158">W ten sposób Klasa pochodna lub interfejs może zadeklarować element członkowski o takiej samej nazwie jak Dziedziczony element członkowski.</span><span class="sxs-lookup"><span data-stu-id="4e268-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="4e268-159">Członek ten jest wymieniony do ***ukrycia*** dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="4e268-160">Każda deklaracja delegata tworzy nową przestrzeń deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="4e268-161">Nazwy są wprowadzane do tego obszaru deklaracji za poorednictwem parametrów formalnych (*fixed_parameter*s i *parameter_array*s) i *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4e268-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="4e268-162">Każda deklaracja wyliczenia tworzy nową przestrzeń deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="4e268-163">Nazwy są wprowadzane do tego obszaru deklaracji za poorednictwem *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="4e268-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="4e268-164">Każda deklaracja metody, deklaracja indeksatora, deklaracja operatora, deklaracja konstruktora wystąpień i funkcja anonimowa tworzą nowe miejsce deklaracji zwane ***przestrzenią lokalnej deklaracji zmiennej***.</span><span class="sxs-lookup"><span data-stu-id="4e268-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="4e268-165">Nazwy są wprowadzane do tego obszaru deklaracji za poorednictwem parametrów formalnych (*fixed_parameter*s i *parameter_array*s) i *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="4e268-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="4e268-166">Treść składowej funkcji lub funkcji anonimowej, jeśli istnieje, jest uznawana za zagnieżdżoną w obrębie przestrzeni deklaracji zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="4e268-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="4e268-167">Jest to błąd dla przestrzeni lokalnej deklaracji zmiennej i zagnieżdżona przestrzeń deklaracji zmiennej lokalnej, która zawiera elementy o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="4e268-168">W tym celu w ramach zagnieżdżonej deklaracji nie można zadeklarować zmiennej lokalnej ani stałej o takiej samej nazwie jak zmienna lokalna lub stała w otaczającym obszarze deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="4e268-169">Możliwe jest, aby dwie spacje deklaracji zawierały elementy o tej samej nazwie, o ile nie zawiera ona żadnej z nich.</span><span class="sxs-lookup"><span data-stu-id="4e268-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="4e268-170">Każdy *blok* lub *switch_block* , jak również instrukcja *for*, *foreach* i *using* , tworzy przestrzeń lokalnej deklaracji zmiennej dla zmiennych lokalnych i stałych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="4e268-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="4e268-171">Nazwy są wprowadzane do tego obszaru deklaracji za poorednictwem *local_variable_declaration*s i *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="4e268-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="4e268-172">Należy zauważyć, że Bloki występujące jako lub w treści elementu członkowskiego funkcji lub funkcji anonimowej są zagnieżdżone w obszarze deklaracji zmiennej lokalnej zadeklarowanej przez te funkcje dla ich parametrów.</span><span class="sxs-lookup"><span data-stu-id="4e268-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="4e268-173">W rezultacie jest to błąd, na przykład, Metoda ze zmienną lokalną i parametr o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="4e268-174">Każdy *blok* lub *switch_block* tworzy oddzielne miejsce deklaracji dla etykiet.</span><span class="sxs-lookup"><span data-stu-id="4e268-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="4e268-175">Nazwy są wprowadzane do tego obszaru deklaracji za pomocą *labeled_statement*s, a nazwy są przywoływane przez *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="4e268-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="4e268-176">***Miejsce deklaracji etykiety*** bloku zawiera wszystkie zagnieżdżone bloki.</span><span class="sxs-lookup"><span data-stu-id="4e268-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="4e268-177">W tym celu w bloku zagnieżdżonym nie można zadeklarować etykiety o takiej samej nazwie jak etykieta w otaczającym bloku.</span><span class="sxs-lookup"><span data-stu-id="4e268-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="4e268-178">Kolejność tekstu, w której zadeklarowane są nazwy, zazwyczaj nie ma znaczenia.</span><span class="sxs-lookup"><span data-stu-id="4e268-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="4e268-179">W szczególności kolejność tekstu nie jest istotna dla deklaracji i użycia przestrzeni nazw, stałych, metod, właściwości, zdarzeń, indeksatorów, konstruktorów wystąpień, destruktorów, konstruktorów statycznych i typów.</span><span class="sxs-lookup"><span data-stu-id="4e268-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="4e268-180">Kolejność deklaracji jest istotna w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e268-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="4e268-181">Kolejność deklaracji dla deklaracji pola i deklaracji zmiennych lokalnych określa kolejność, w jakiej są wykonywane ich inicjatory (jeśli istnieją).</span><span class="sxs-lookup"><span data-stu-id="4e268-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="4e268-182">Zmienne lokalne muszą być zdefiniowane przed użyciem ([zakresy](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="4e268-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="4e268-183">Kolejność deklaracji deklaracji elementu członkowskiego wyliczenia ([składowe wyliczenia](enums.md#enum-members)) jest istotna, gdy wartości *constant_expression* są pomijane.</span><span class="sxs-lookup"><span data-stu-id="4e268-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="4e268-184">Obszar deklaracji przestrzeni nazw to "otwarta zakończona", a dwie deklaracje przestrzeni nazw o tej samej w pełni kwalifikowanej nazwie współtworzą ten sam obszar deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="4e268-185">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4e268-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="4e268-186">Powyższe dwie deklaracje przestrzeni nazw składają się na ten sam obszar deklaracji, w tym przypadku deklarując dwie klasy z w pełni kwalifikowanymi nazwami `Megacorp.Data.Customer` i `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="4e268-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="4e268-187">Ponieważ dwie deklaracje przyczyniają się do tego samego obszaru deklaracji, powodowały to błąd czasu kompilacji, jeśli każda z nich zawiera deklarację klasy o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="4e268-188">Jak określono powyżej, obszar deklaracji bloku zawiera wszystkie zagnieżdżone bloki.</span><span class="sxs-lookup"><span data-stu-id="4e268-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="4e268-189">W związku z tym w poniższym przykładzie metody `F` i `G` powodują błąd czasu kompilacji, ponieważ nazwa `i` jest zadeklarowana w bloku zewnętrznym i nie może być ponownie zadeklarowana w bloku wewnętrznym.</span><span class="sxs-lookup"><span data-stu-id="4e268-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="4e268-190">Jednakże metody `H` i `I` są prawidłowe, ponieważ dwa `i`są zadeklarowane w oddzielnych blokach niezagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="4e268-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="4e268-191">Members</span><span class="sxs-lookup"><span data-stu-id="4e268-191">Members</span></span>

<span data-ttu-id="4e268-192">Przestrzenie nazw i typy mają ***składowe***.</span><span class="sxs-lookup"><span data-stu-id="4e268-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="4e268-193">Elementy członkowskie jednostki są ogólnie dostępne przy użyciu kwalifikowanej nazwy, która rozpoczyna się od odwołania do jednostki, po której następuje token "`.`", po którym następuje nazwa elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="4e268-194">Elementy członkowskie typu są zadeklarowane w deklaracji typu lub ***dziedziczone*** z klasy bazowej typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="4e268-195">Gdy typ dziedziczy z klasy bazowej, wszystkie elementy członkowskie klasy podstawowej, z wyjątkiem konstruktorów wystąpień, destruktorów i konstruktorów statycznych, stają się elementami członkowskimi typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="4e268-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="4e268-196">Zadeklarowana dostępność składowej klasy bazowej nie kontroluje, czy element członkowski jest dziedziczony — dziedziczenie rozciąga się do dowolnego elementu członkowskiego, który nie jest konstruktorem wystąpienia, konstruktorem statycznym ani destruktorem.</span><span class="sxs-lookup"><span data-stu-id="4e268-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="4e268-197">Jednak Dziedziczony element członkowski może nie być dostępny w typie pochodnym, z powodu jego zadeklarowanej dostępności ([zadeklarowanej dostępności](basic-concepts.md#declared-accessibility)) lub jest ukryty przez deklarację w samym typie ([ukrywając poprzez dziedziczenie](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="4e268-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="4e268-198">Elementy członkowskie przestrzeni nazw</span><span class="sxs-lookup"><span data-stu-id="4e268-198">Namespace members</span></span>

<span data-ttu-id="4e268-199">Przestrzenie nazw i typy, które nie mają otaczającej przestrzeni nazw, są elementami członkowskimi ***globalnej przestrzeni nazw***.</span><span class="sxs-lookup"><span data-stu-id="4e268-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="4e268-200">Odnosi się to bezpośrednio do nazw zadeklarowanych w globalnej przestrzeni deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="4e268-201">Przestrzenie nazw i typy zadeklarowane w przestrzeni nazw są elementami członkowskimi tej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="4e268-202">Odnosi się to bezpośrednio do nazw zadeklarowanych w obszarze deklaracji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="4e268-203">Przestrzenie nazw nie mają ograniczeń dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="4e268-204">Nie można zadeklarować prywatnych, chronionych lub wewnętrznych przestrzeni nazw, a nazwy przestrzeni nazw są zawsze publicznie dostępne.</span><span class="sxs-lookup"><span data-stu-id="4e268-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="4e268-205">Elementy członkowskie struktury</span><span class="sxs-lookup"><span data-stu-id="4e268-205">Struct members</span></span>

<span data-ttu-id="4e268-206">Elementy członkowskie struktury to elementy członkowskie zadeklarowane w strukturze i składowe dziedziczone z bezpośredniej klasy podstawowej struktury `System.ValueType` i pośredniej klasy bazowej `object`.</span><span class="sxs-lookup"><span data-stu-id="4e268-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="4e268-207">Elementy członkowskie typu prostego odpowiadają bezpośrednio elementom członkowskim typu struct, które są aliase według typu prostego:</span><span class="sxs-lookup"><span data-stu-id="4e268-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="4e268-208">Członkowie `sbyte` są członkami struktury `System.SByte`.</span><span class="sxs-lookup"><span data-stu-id="4e268-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="4e268-209">Członkowie `byte` są członkami struktury `System.Byte`.</span><span class="sxs-lookup"><span data-stu-id="4e268-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="4e268-210">Członkowie `short` są członkami struktury `System.Int16`.</span><span class="sxs-lookup"><span data-stu-id="4e268-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="4e268-211">Członkowie `ushort` są członkami struktury `System.UInt16`.</span><span class="sxs-lookup"><span data-stu-id="4e268-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="4e268-212">Członkowie `int` są członkami struktury `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="4e268-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="4e268-213">Członkowie `uint` są członkami struktury `System.UInt32`.</span><span class="sxs-lookup"><span data-stu-id="4e268-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="4e268-214">Członkowie `long` są członkami struktury `System.Int64`.</span><span class="sxs-lookup"><span data-stu-id="4e268-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="4e268-215">Członkowie `ulong` są członkami struktury `System.UInt64`.</span><span class="sxs-lookup"><span data-stu-id="4e268-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="4e268-216">Członkowie `char` są członkami struktury `System.Char`.</span><span class="sxs-lookup"><span data-stu-id="4e268-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="4e268-217">Członkowie `float` są członkami struktury `System.Single`.</span><span class="sxs-lookup"><span data-stu-id="4e268-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="4e268-218">Członkowie `double` są członkami struktury `System.Double`.</span><span class="sxs-lookup"><span data-stu-id="4e268-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="4e268-219">Członkowie `decimal` są członkami struktury `System.Decimal`.</span><span class="sxs-lookup"><span data-stu-id="4e268-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="4e268-220">Członkowie `bool` są członkami struktury `System.Boolean`.</span><span class="sxs-lookup"><span data-stu-id="4e268-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="4e268-221">Elementy członkowskie wyliczenia</span><span class="sxs-lookup"><span data-stu-id="4e268-221">Enumeration members</span></span>

<span data-ttu-id="4e268-222">Elementy członkowskie wyliczenia to stałe zadeklarowane w wyliczeniu i składowe dziedziczone z bezpośredniej klasy podstawowej wyliczenia `System.Enum` i pośrednich klas bazowych `System.ValueType` i `object`.</span><span class="sxs-lookup"><span data-stu-id="4e268-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="4e268-223">Elementy członkowskie klasy</span><span class="sxs-lookup"><span data-stu-id="4e268-223">Class members</span></span>

<span data-ttu-id="4e268-224">Elementy członkowskie klasy są składowymi zadeklarowanymi w klasie i składowymi dziedziczonymi z klasy podstawowej (z wyjątkiem klasy `object`, która nie ma klasy bazowej).</span><span class="sxs-lookup"><span data-stu-id="4e268-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="4e268-225">Elementy członkowskie dziedziczone z klasy bazowej obejmują stałe, pola, metody, właściwości, zdarzenia, indeksatory, operatory i typy klasy bazowej, ale nie konstruktorów wystąpień, destruktorów i konstruktorów statycznych klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4e268-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="4e268-226">Składowe klasy bazowej są dziedziczone bez względu na ich dostępność.</span><span class="sxs-lookup"><span data-stu-id="4e268-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="4e268-227">Deklaracja klasy może zawierać deklaracje stałych, pól, metod, właściwości, zdarzeń, indeksatorów, operatorów, konstruktorów wystąpień, destruktorów, konstruktorów statycznych i typów.</span><span class="sxs-lookup"><span data-stu-id="4e268-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="4e268-228">Elementy członkowskie `object` i `string` odpowiadają bezpośrednio członkom typów klas, których aliasy:</span><span class="sxs-lookup"><span data-stu-id="4e268-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="4e268-229">Członkowie `object` są członkami klasy `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="4e268-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="4e268-230">Członkowie `string` są członkami klasy `System.String`.</span><span class="sxs-lookup"><span data-stu-id="4e268-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="4e268-231">Elementy członkowskie interfejsu</span><span class="sxs-lookup"><span data-stu-id="4e268-231">Interface members</span></span>

<span data-ttu-id="4e268-232">Elementy członkowskie interfejsu są elementami zadeklarowanymi w interfejsie i we wszystkich interfejsach podstawowych interfejsu.</span><span class="sxs-lookup"><span data-stu-id="4e268-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="4e268-233">Elementy członkowskie w klasie `object` nie są, ściśle mówiące, członkami dowolnego interfejsu ([elementy członkowskie interfejsu](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="4e268-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="4e268-234">Jednakże elementy członkowskie klasy `object` są dostępne za pośrednictwem wyszukiwania elementów członkowskich w dowolnym typie interfejsu ([wyszukiwanie elementu członkowskiego](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="4e268-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="4e268-235">Elementy członkowskie tablicy</span><span class="sxs-lookup"><span data-stu-id="4e268-235">Array members</span></span>

<span data-ttu-id="4e268-236">Elementy członkowskie tablicy są elementami dziedziczonymi z klasy `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="4e268-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="4e268-237">Deleguj członków</span><span class="sxs-lookup"><span data-stu-id="4e268-237">Delegate members</span></span>

<span data-ttu-id="4e268-238">Elementy członkowskie delegata są elementami dziedziczonymi z klasy `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="4e268-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="4e268-239">Dostęp do elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="4e268-239">Member access</span></span>

<span data-ttu-id="4e268-240">Deklaracje elementów członkowskich umożliwiają kontrolę dostępu do elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="4e268-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="4e268-241">Dostępność elementu członkowskiego jest określana przez zadeklarowane dostępność ([zadeklarowane dostępność](basic-concepts.md#declared-accessibility)) elementu członkowskiego połączonego z ułatwieniami dostępu do typu, jeśli istnieje.</span><span class="sxs-lookup"><span data-stu-id="4e268-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="4e268-242">Gdy dostęp do określonego elementu członkowskiego jest dozwolony, członek jest uznawany za ***dostępny***.</span><span class="sxs-lookup"><span data-stu-id="4e268-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="4e268-243">Z drugiej strony, gdy dostęp do określonego elementu członkowskiego jest niedozwolony, członek jest uznawany za ***niedostępny***.</span><span class="sxs-lookup"><span data-stu-id="4e268-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="4e268-244">Dostęp do elementu członkowskiego jest dozwolony, gdy lokalizacja tekstowa, w której odbywa się dostęp, jest uwzględniona w domenie dostępności ([domeny ułatwień](basic-concepts.md#accessibility-domains)dostępu) elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="4e268-245">Zadeklarowane ułatwienia dostępu</span><span class="sxs-lookup"><span data-stu-id="4e268-245">Declared accessibility</span></span>

<span data-ttu-id="4e268-246">***Zadeklarowana dostępność*** elementu członkowskiego może być jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="4e268-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="4e268-247">Public, który jest wybierany przez dołączenie modyfikatora `public` w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="4e268-248">Intuicyjne znaczenie `public` ma wartość "dostęp nieograniczony".</span><span class="sxs-lookup"><span data-stu-id="4e268-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="4e268-249">Chroniony, który jest wybierany przez dołączenie modyfikatora `protected` w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="4e268-250">Intuicyjne znaczenie `protected` jest "dostęp ograniczony do klasy zawierającej lub typów pochodzących od klasy zawierającej".</span><span class="sxs-lookup"><span data-stu-id="4e268-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="4e268-251">Wewnętrzna, która jest wybierana przez dołączenie modyfikatora `internal` w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="4e268-252">Intuicyjne znaczenie `internal` jest "dostęp ograniczony do tego programu".</span><span class="sxs-lookup"><span data-stu-id="4e268-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="4e268-253">Chroniona wewnętrznie (czyli chroniona lub wewnętrzna), która jest wybierana przez uwzględnienie zarówno `protected`, jak i modyfikatora `internal` w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="4e268-254">Intuicyjne znaczenie `protected internal` jest "dostęp ograniczony do tego programu lub typów pochodzących od klasy zawierającej".</span><span class="sxs-lookup"><span data-stu-id="4e268-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="4e268-255">Prywatny, który jest wybierany przez dołączenie modyfikatora `private` w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="4e268-256">Intuicyjne znaczenie `private` jest "dostęp ograniczony do typu zawierającego".</span><span class="sxs-lookup"><span data-stu-id="4e268-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="4e268-257">W zależności od kontekstu, w którym jest realizowana Deklaracja elementu członkowskiego, dozwolone są tylko niektóre typy zadeklarowanych ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="4e268-258">Ponadto, gdy Deklaracja elementu członkowskiego nie zawiera żadnych modyfikatorów dostępu, kontekst, w którym odbywa się deklaracja, określa domyślny dostępną dostępność.</span><span class="sxs-lookup"><span data-stu-id="4e268-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="4e268-259">Przestrzenie nazw niejawnie mają `public` zadeklarowane ułatwienia dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4e268-260">W deklaracjach przestrzeni nazw nie są dozwolone Modyfikatory dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="4e268-261">Typy zadeklarowane w jednostkach kompilacji lub przestrzeniach nazw mogą mieć `public` lub `internal` zadeklarowane ułatwienia dostępu i domyślne do `internal` zadeklarowanej dostępności.</span><span class="sxs-lookup"><span data-stu-id="4e268-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="4e268-262">Elementy członkowskie klasy mogą mieć dowolne pięć rodzajów zadeklarowanych ułatwień dostępu i wartości domyślnych, aby `private` zadeklarowane ułatwienia dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="4e268-263">(Należy zauważyć, że typ zadeklarowany jako element członkowski klasy może mieć którykolwiek z pięciu rodzajów zadeklarowanej dostępności, podczas gdy typ zadeklarowany jako składowa przestrzeni nazw może mieć tylko `public` lub `internal` zadeklarowane ułatwienia dostępu).</span><span class="sxs-lookup"><span data-stu-id="4e268-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="4e268-264">Elementy członkowskie struktury mogą mieć `public`, `internal`lub `private` zadeklarowane ułatwienia dostępu i domyślne do `private` zadeklarowanej dostępności, ponieważ struktury są niejawnie zapieczętowane.</span><span class="sxs-lookup"><span data-stu-id="4e268-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="4e268-265">Elementy członkowskie struktury wprowadzone w strukturze (która nie jest dziedziczona przez tę strukturę) nie mogą mieć `protected` ani `protected internal` zadeklarowanej dostępności.</span><span class="sxs-lookup"><span data-stu-id="4e268-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="4e268-266">(Należy zauważyć, że typ zadeklarowany jako element członkowski struktury może mieć `public`, `internal`lub `private` zadeklarowanej dostępności, podczas gdy typ zadeklarowany jako składowa przestrzeni nazw może mieć tylko `public` lub `internal` zadeklarowane ułatwienia dostępu.)</span><span class="sxs-lookup"><span data-stu-id="4e268-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="4e268-267">Elementy członkowskie interfejsu niejawnie mają `public` zadeklarowane ułatwienia dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4e268-268">W deklaracjach składowych interfejsu nie można używać modyfikatorów dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="4e268-269">Elementy członkowskie wyliczenia niejawnie mają `public` zadeklarowane ułatwienia dostępu.</span><span class="sxs-lookup"><span data-stu-id="4e268-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="4e268-270">Modyfikatory dostępu są niedozwolone w deklaracjach składowych wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="4e268-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="4e268-271">Domeny ułatwień dostępu</span><span class="sxs-lookup"><span data-stu-id="4e268-271">Accessibility domains</span></span>

<span data-ttu-id="4e268-272">***Domena dostępności*** elementu członkowskiego składa się z sekcji (ewentualnie rozłączonych) tekstu programu, w którym dozwolony jest dostęp do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="4e268-273">Aby można było zdefiniować domenę dostępności elementu członkowskiego, członek jest nazywany ***najwyższego poziomu*** , jeśli nie jest zadeklarowany w obrębie typu, a element członkowski jest określany jako ***zagnieżdżony*** , jeśli jest zadeklarowany w innym typie.</span><span class="sxs-lookup"><span data-stu-id="4e268-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="4e268-274">Ponadto ***tekst programu*** w programie jest zdefiniowany jako cały tekst programu zawarty we wszystkich plikach źródłowych programu, a tekst programu typu jest zdefiniowany jako cały tekst programu zawarty w *type_declaration*s tego typu (w tym, ewentualnie, typy, które są zagnieżdżone w typie).</span><span class="sxs-lookup"><span data-stu-id="4e268-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="4e268-275">Domena dostępności wstępnie zdefiniowanego typu (na przykład `object`, `int`lub `double`) jest nieograniczona.</span><span class="sxs-lookup"><span data-stu-id="4e268-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="4e268-276">Domena dostępności niepowiązanego typu najwyższego poziomu `T` ([powiązane i niepowiązane typy](types.md#bound-and-unbound-types)) zadeklarowane w programie `P` definiuje się w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e268-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="4e268-277">Jeśli deklarowana dostępność `T` jest `public`, domena dostępności `T` jest tekstem programu `P` i dowolnym programem, który odwołuje się do `P`.</span><span class="sxs-lookup"><span data-stu-id="4e268-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="4e268-278">Jeśli deklarowana dostępność `T` jest `internal`, domena dostępności `T` jest tekstem programu `P`.</span><span class="sxs-lookup"><span data-stu-id="4e268-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="4e268-279">Z tych definicji wynika, że domena dostępności niepowiązanego typu najwyższego poziomu jest zawsze co najmniej programem tekstowym programu, w którym ten typ jest zadeklarowany.</span><span class="sxs-lookup"><span data-stu-id="4e268-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="4e268-280">Domena dostępności dla konstruowanego typu `T<A1, ..., An>` jest częścią wspólną domeny dostępności niepowiązanego typu ogólnego `T` i domen dostępności argumentów typu `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="4e268-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="4e268-281">Domena dostępności zagnieżdżonego elementu członkowskiego `M` zadeklarowana w typie `T` w ramach programu `P` jest zdefiniowana w następujący sposób (zwracając uwagę, że `M` może być typem):</span><span class="sxs-lookup"><span data-stu-id="4e268-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="4e268-282">Jeśli deklarowana dostępność `M` jest `public`, domena dostępności `M` jest domeną dostępności `T`.</span><span class="sxs-lookup"><span data-stu-id="4e268-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="4e268-283">Jeśli deklarowana dostępność `M` jest `protected internal`, niech `D` być złożeniem tekstu programu `P` i tekstu programu dowolnego typu pochodzącego od `T`, który jest zadeklarowany poza `P`.</span><span class="sxs-lookup"><span data-stu-id="4e268-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="4e268-284">Domena dostępności `M` jest częścią wspólną domeny dostępności `T` z `D`.</span><span class="sxs-lookup"><span data-stu-id="4e268-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="4e268-285">Jeśli deklarowana dostępność `M` jest `protected`, niech `D` być złożeniem tekstu programu `T` i tekstu programu dowolnego typu pochodzącego od `T`.</span><span class="sxs-lookup"><span data-stu-id="4e268-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="4e268-286">Domena dostępności `M` jest częścią wspólną domeny dostępności `T` z `D`.</span><span class="sxs-lookup"><span data-stu-id="4e268-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="4e268-287">Jeśli deklarowana dostępność `M` jest `internal`, domena dostępności `M` jest częścią wspólną domeny dostępności `T` z tekstem programu `P`.</span><span class="sxs-lookup"><span data-stu-id="4e268-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="4e268-288">Jeśli deklarowana dostępność `M` jest `private`, domena dostępności `M` jest tekstem programu `T`.</span><span class="sxs-lookup"><span data-stu-id="4e268-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="4e268-289">Z tych definicji następuje, że domena dostępności zagnieżdżonego elementu członkowskiego jest zawsze co najmniej tekstem programu typu, w którym jest zadeklarowany element członkowski.</span><span class="sxs-lookup"><span data-stu-id="4e268-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="4e268-290">Ponadto, gdy domena dostępności elementu członkowskiego nigdy nie jest większa niż domena dostępności typu, w którym jest zadeklarowany element członkowski.</span><span class="sxs-lookup"><span data-stu-id="4e268-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="4e268-291">W intuicyjnych terminach podczas uzyskiwania dostępu do typu lub elementu członkowskiego `M` są oceniane następujące kroki, aby upewnić się, że dostęp jest dozwolony:</span><span class="sxs-lookup"><span data-stu-id="4e268-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="4e268-292">Po pierwsze, jeśli `M` jest zadeklarowany w obrębie typu (w przeciwieństwie do jednostki kompilacji lub przestrzeni nazw), wystąpi błąd w czasie kompilacji, jeśli ten typ nie jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="4e268-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="4e268-293">Następnie Jeśli `M` jest `public`, dostęp jest dozwolony.</span><span class="sxs-lookup"><span data-stu-id="4e268-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="4e268-294">W przeciwnym razie, jeśli `M` jest `protected internal`, dostęp jest dozwolony, jeśli występuje w ramach programu, w którym `M` jest zadeklarowana, lub jeśli występuje w klasie pochodzącej od klasy, w której `M` jest zadeklarowana, i odbywa się za pośrednictwem typu klasy pochodnej ([chroniony dostęp dla członków wystąpienia](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="4e268-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="4e268-295">W przeciwnym razie, jeśli `M` jest `protected`, dostęp jest dozwolony, jeśli występuje w klasie, w której `M` jest zadeklarowana, lub jeśli występuje w klasie pochodzącej od klasy, w której `M` jest zadeklarowana, i odbywa się za pośrednictwem typu klasy pochodnej ([chroniony dostęp dla członków wystąpienia](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="4e268-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="4e268-296">W przeciwnym razie, jeśli `M` jest `internal`, dostęp jest dozwolony, jeśli występuje w ramach programu, w którym `M` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="4e268-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="4e268-297">W przeciwnym razie, jeśli `M` jest `private`, dostęp jest dozwolony, jeśli występuje w ramach typu, w którym `M` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="4e268-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="4e268-298">W przeciwnym razie typ lub element członkowski jest niedostępny i wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="4e268-299">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="4e268-300">klasy i składowe mają następujące domeny ułatwień dostępu:</span><span class="sxs-lookup"><span data-stu-id="4e268-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="4e268-301">Domena dostępności `A` i `A.X` jest nieograniczona.</span><span class="sxs-lookup"><span data-stu-id="4e268-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="4e268-302">Domena dostępności `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`i `B.C.Y` to tekst programu zawierającego program zawierający.</span><span class="sxs-lookup"><span data-stu-id="4e268-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="4e268-303">Domena dostępności `A.Z` jest tekstem programu `A`.</span><span class="sxs-lookup"><span data-stu-id="4e268-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="4e268-304">Domena dostępności `B.Z` i `B.D` to tekst programu `B`, w tym tekst programu `B.C` i `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4e268-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="4e268-305">Domena dostępności `B.C.Z` jest tekstem programu `B.C`.</span><span class="sxs-lookup"><span data-stu-id="4e268-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="4e268-306">Domena dostępności `B.D.X` i `B.D.Y` to tekst programu `B`, w tym tekst programu `B.C` i `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4e268-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="4e268-307">Domena dostępności `B.D.Z` jest tekstem programu `B.D`.</span><span class="sxs-lookup"><span data-stu-id="4e268-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="4e268-308">Jak pokazano na przykładzie, domena dostępności elementu członkowskiego nigdy nie jest większa niż typ zawierającego.</span><span class="sxs-lookup"><span data-stu-id="4e268-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="4e268-309">Na przykład mimo że wszyscy członkowie `X` mają publicznie zadeklarowane ułatwienia dostępu, a wszystkie `A.X` mają domeny dostępności, które są ograniczone przez typ zawierający.</span><span class="sxs-lookup"><span data-stu-id="4e268-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="4e268-310">Zgodnie z opisem w części [Członkowie](basic-concepts.md#members), wszyscy członkowie klasy podstawowej, z wyjątkiem konstruktorów wystąpień, destruktory i konstruktory statyczne są dziedziczone przez typy pochodne.</span><span class="sxs-lookup"><span data-stu-id="4e268-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="4e268-311">Obejmuje to nawet prywatne elementy członkowskie klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4e268-311">This includes even private members of a base class.</span></span> <span data-ttu-id="4e268-312">Jednak domena dostępności prywatnego elementu członkowskiego zawiera tylko tekst programu typu, w którym jest zadeklarowany element członkowski.</span><span class="sxs-lookup"><span data-stu-id="4e268-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="4e268-313">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="4e268-314">Klasa `B` dziedziczy prywatny element członkowski `x` z klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="4e268-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="4e268-315">Ponieważ element członkowski jest prywatny, jest dostępny tylko w *class_body* `A`.</span><span class="sxs-lookup"><span data-stu-id="4e268-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="4e268-316">W ten sposób dostęp do `b.x` powiedzie się w metodzie `A.F`, ale w metodzie `B.F` nie powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="4e268-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="4e268-317">Chroniony dostęp dla członków wystąpienia</span><span class="sxs-lookup"><span data-stu-id="4e268-317">Protected access for instance members</span></span>

<span data-ttu-id="4e268-318">Gdy jest uzyskiwany dostęp do elementu członkowskiego wystąpienia `protected` poza tekstem programu klasy, w którym jest zadeklarowany, a gdy członek wystąpienia `protected internal` jest dostępny poza tekstem programu w programie, w którym jest zadeklarowany, dostęp musi odbywać się w deklaracji klasy, która pochodzi od klasy, w której jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="4e268-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="4e268-319">Ponadto dostęp musi odbywać się za pośrednictwem wystąpienia tego typu klasy pochodnej lub klasy z tego typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="4e268-320">To ograniczenie uniemożliwia jednej klasie pochodnej dostęp do chronionych elementów członkowskich innych klas pochodnych, nawet gdy elementy członkowskie są dziedziczone z tej samej klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="4e268-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="4e268-321">Niech `B` być klasą bazową, która deklaruje element członkowski chronionego wystąpienia `M`i niech `D` być klasą pochodzącą z `B`.</span><span class="sxs-lookup"><span data-stu-id="4e268-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="4e268-322">W *class_body* `D`dostęp do `M` może mieć jedną z następujących form:</span><span class="sxs-lookup"><span data-stu-id="4e268-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="4e268-323">Niekwalifikowana *TYPE_NAME* lub *primary_expression* formularza `M`.</span><span class="sxs-lookup"><span data-stu-id="4e268-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="4e268-324">*Primary_expression* formularza `E.M`, pod warunkiem, że typ `E` jest `T` lub Klasa pochodna z `T`, gdzie `T` jest typem klasy `D`lub typ klasy zbudowany z `D`</span><span class="sxs-lookup"><span data-stu-id="4e268-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="4e268-325">*Primary_expression* `base.M`formularza.</span><span class="sxs-lookup"><span data-stu-id="4e268-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="4e268-326">Oprócz tych formularzy dostępu Klasa pochodna może uzyskać dostęp do konstruktora chronionych wystąpień klasy bazowej w *constructor_initializer* ([inicjatory konstruktora](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="4e268-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="4e268-327">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="4e268-328">w `A`można uzyskać dostęp do `x` przez wystąpienia obu `A` i `B`, ponieważ w obu przypadkach dostęp odbywa się za pośrednictwem wystąpienia `A` lub klasy pochodnej z `A`.</span><span class="sxs-lookup"><span data-stu-id="4e268-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="4e268-329">Jednak w `B`nie jest możliwe uzyskanie dostępu do `x` za pośrednictwem wystąpienia `A`, ponieważ `A` nie pochodzi od `B`.</span><span class="sxs-lookup"><span data-stu-id="4e268-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="4e268-330">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="4e268-331">trzy przypisania do `x` są dozwolone, ponieważ są one wykonywane za pośrednictwem wystąpień typów klas zbudowanych z typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="4e268-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="4e268-332">Ograniczenia dotyczące ułatwień dostępu</span><span class="sxs-lookup"><span data-stu-id="4e268-332">Accessibility constraints</span></span>

<span data-ttu-id="4e268-333">Kilka konstrukcji w C# języku wymaga, aby typ był ***co najmniej*** taki sam jak element członkowski lub inny typ.</span><span class="sxs-lookup"><span data-stu-id="4e268-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="4e268-334">Typ `T` jest uznawany za co najmniej jako element członkowski lub typ `M`, jeśli domena dostępności `T` jest nadzbiorem domeny dostępności `M`.</span><span class="sxs-lookup"><span data-stu-id="4e268-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="4e268-335">Innymi słowy, `T` jest co najmniej tak samo, jak `M`, jeśli `T` jest dostępny we wszystkich kontekstach, w których `M` jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="4e268-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="4e268-336">Istnieją następujące ograniczenia dotyczące ułatwień dostępu:</span><span class="sxs-lookup"><span data-stu-id="4e268-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="4e268-337">Bezpośrednia klasa bazowa typu klasy musi być co najmniej równa dostępności jako samego typu klasy.</span><span class="sxs-lookup"><span data-stu-id="4e268-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="4e268-338">Jawne interfejsy podstawowe typu interfejsu muszą być co najmniej takie same jak typ interfejsu.</span><span class="sxs-lookup"><span data-stu-id="4e268-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="4e268-339">Typ zwracany i typy parametrów typu delegata muszą być co najmniej tak samo jak typ delegata.</span><span class="sxs-lookup"><span data-stu-id="4e268-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="4e268-340">Typ stałej musi być co najmniej tak samo jak jako stała.</span><span class="sxs-lookup"><span data-stu-id="4e268-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="4e268-341">Typ pola musi być co najmniej tak samo jak w przypadku samego pola.</span><span class="sxs-lookup"><span data-stu-id="4e268-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="4e268-342">Typ zwracany i typy parametrów metody muszą być co najmniej tak samo samo jak metoda.</span><span class="sxs-lookup"><span data-stu-id="4e268-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="4e268-343">Typ właściwości musi być co najmniej taki sam jak wartość właściwości.</span><span class="sxs-lookup"><span data-stu-id="4e268-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="4e268-344">Typ zdarzenia musi być co najmniej tak samo jak w przypadku samego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="4e268-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="4e268-345">Typ i typy parametrów indeksatora muszą być co najmniej tak samo dostępne jak indeksator.</span><span class="sxs-lookup"><span data-stu-id="4e268-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="4e268-346">Typ zwracany i typy parametrów operatora muszą być co najmniej takie same jak dla samego operatora.</span><span class="sxs-lookup"><span data-stu-id="4e268-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="4e268-347">Typy parametrów konstruktora wystąpienia muszą być co najmniej tak samo samo jak Konstruktor wystąpień.</span><span class="sxs-lookup"><span data-stu-id="4e268-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="4e268-348">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="4e268-349">Klasa `B` powoduje błąd czasu kompilacji, ponieważ `A` nie jest co najmniej równa dostępności jako `B`.</span><span class="sxs-lookup"><span data-stu-id="4e268-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="4e268-350">Podobnie, w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="4e268-351">Metoda `H` w `B` powoduje błąd czasu kompilacji, ponieważ typ zwracany `A` nie jest co najmniej taki sam jak metoda.</span><span class="sxs-lookup"><span data-stu-id="4e268-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="4e268-352">Sygnatury i Przeciążenie</span><span class="sxs-lookup"><span data-stu-id="4e268-352">Signatures and overloading</span></span>

<span data-ttu-id="4e268-353">Metody, konstruktory wystąpień, indeksatory i operatory są scharakteryzowane przez ich ***sygnatury***:</span><span class="sxs-lookup"><span data-stu-id="4e268-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="4e268-354">Podpis metody składa się z nazwy metody, liczby parametrów typu i typu i rodzaju (wartości, odwołania lub danych wyjściowych) każdego z parametrów formalnych, które są uwzględniane w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="4e268-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4e268-355">W tym celu wszelkie parametry typu metody, która występuje w typie parametru formalnego, nie są identyfikowane przez jego nazwę, ale według pozycji porządkowej na liście argumentów typu metody.</span><span class="sxs-lookup"><span data-stu-id="4e268-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="4e268-356">Sygnatura metody w szczególności nie obejmuje typu zwracanego, modyfikatora `params`, który może być określony dla najwyższego parametru lub opcjonalnych ograniczeń parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="4e268-357">Sygnatura konstruktora wystąpienia składa się z typu i rodzaju (wartości, odwołania lub danych wyjściowych) każdego z jego parametrów formalnych, w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="4e268-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4e268-358">Podpis konstruktora wystąpienia w szczególności nie zawiera modyfikatora `params`, który może być określony dla każdego parametru z prawej strony.</span><span class="sxs-lookup"><span data-stu-id="4e268-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="4e268-359">Podpis indeksatora składa się z typu każdego z parametrów formalnych, który jest traktowany w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="4e268-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4e268-360">Podpis indeksatora w szczególności nie zawiera typu elementu ani nie zawiera modyfikatora `params`, który może być określony dla tego parametru.</span><span class="sxs-lookup"><span data-stu-id="4e268-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="4e268-361">Podpis operatora składa się z nazwy operatora i typu każdego z jego parametrów formalnych, w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="4e268-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="4e268-362">Podpis operatora jawnie nie zawiera typu wyniku.</span><span class="sxs-lookup"><span data-stu-id="4e268-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="4e268-363">Sygnatury są mechanizmem włączania do ***przeciążenia*** elementów członkowskich w klasach, strukturach i interfejsach:</span><span class="sxs-lookup"><span data-stu-id="4e268-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="4e268-364">Przeciążanie metod pozwala klasy, struktury lub interfejsu zadeklarować wiele metod o tej samej nazwie, pod warunkiem, że ich sygnatury są unikatowe w ramach tej klasy, struktury lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="4e268-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="4e268-365">Przeciążanie konstruktorów wystąpień pozwala klasie lub strukturze zadeklarować wiele konstruktorów wystąpień, pod warunkiem, że ich sygnatury są unikatowe w obrębie tej klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="4e268-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="4e268-366">Przeciążanie indeksatorów umożliwia klasy, struktury lub interfejsu zadeklarować wiele indeksatorów, pod warunkiem, że ich sygnatury są unikatowe w ramach tej klasy, struktury lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="4e268-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="4e268-367">Przeciążanie operatorów pozwala klasie lub strukturze zadeklarować wiele operatorów o tej samej nazwie, pod warunkiem, że ich sygnatury są unikatowe w tej klasie lub strukturze.</span><span class="sxs-lookup"><span data-stu-id="4e268-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="4e268-368">Mimo że Modyfikatory parametrów `out` i `ref` są uważane za część podpisu, składowe zadeklarowane w pojedynczym typie nie mogą różnić się w podpisie wyłącznie przez `ref` i `out`.</span><span class="sxs-lookup"><span data-stu-id="4e268-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="4e268-369">Błąd czasu kompilacji występuje, jeśli dwa składowe są zadeklarowane w tym samym typie z podpisami, które byłyby takie same, jeśli wszystkie parametry w obu metodach z modyfikatorami `out` zostały zmienione na `ref` modyfikatory.</span><span class="sxs-lookup"><span data-stu-id="4e268-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="4e268-370">Do innych celów dopasowywania podpisów (np. ukrycia lub przesłaniania) `ref` i `out` są uważane za część podpisu i nie pasują do siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="4e268-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="4e268-371">(To ograniczenie umożliwia łatwe tłumaczenie C# programów na Common Language Infrastructure (CLI), które nie udostępniają sposobu definiowania metod, które różnią się wyłącznie w `ref` i `out`.)</span><span class="sxs-lookup"><span data-stu-id="4e268-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="4e268-372">Na potrzeby podpisów typy `object` i `dynamic` są uważane za takie same.</span><span class="sxs-lookup"><span data-stu-id="4e268-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="4e268-373">Elementy członkowskie zadeklarowane w pojedynczym typie mogą nie różnić się w podpisie wyłącznie przez `object` i `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="4e268-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="4e268-374">Poniższy przykład pokazuje zestaw przeciążonych deklaracji metod wraz z ich podpisami.</span><span class="sxs-lookup"><span data-stu-id="4e268-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="4e268-375">Należy zauważyć, że wszystkie `ref` i `out` Modyfikatory parametrów ([Parametry metody](classes.md#method-parameters)) są częścią sygnatury.</span><span class="sxs-lookup"><span data-stu-id="4e268-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="4e268-376">W ten sposób `F(int)` i `F(ref int)` są unikatowymi sygnaturami.</span><span class="sxs-lookup"><span data-stu-id="4e268-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="4e268-377">Nie można jednak zadeklarować `F(ref int)` i `F(out int)` w tym samym interfejsie, ponieważ ich podpisy różnią się wyłącznie `ref` i `out`.</span><span class="sxs-lookup"><span data-stu-id="4e268-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="4e268-378">Należy również zauważyć, że typ zwracany i modyfikator `params` nie są częścią podpisu, więc nie jest możliwe przeciążanie wyłącznie na podstawie typu zwracanego lub przy włączaniu lub wykluczeniu modyfikatora `params`.</span><span class="sxs-lookup"><span data-stu-id="4e268-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="4e268-379">W związku z tym deklaracje metod `F(int)` i `F(params string[])` zidentyfikowane powyżej powodują błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="4e268-380">Zakresy</span><span class="sxs-lookup"><span data-stu-id="4e268-380">Scopes</span></span>

<span data-ttu-id="4e268-381">***Zakres*** nazwy jest regionem tekstu programu, w którym można odwołać się do jednostki zadeklarowanej przez nazwę bez kwalifikacji nazwy.</span><span class="sxs-lookup"><span data-stu-id="4e268-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="4e268-382">Zakresy mogą być ***zagnieżdżane***, a zakres wewnętrzny może redeklarować znaczenie nazwy z zewnętrznego zakresu (nie jest to jednak konieczne usunięcie ograniczenia wynikającego z [deklaracji](basic-concepts.md#declarations) , które w bloku zagnieżdżonym nie można zadeklarować zmiennej lokalnej o takiej samej nazwie jak zmienna lokalna w otaczającym bloku).</span><span class="sxs-lookup"><span data-stu-id="4e268-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="4e268-383">Nazwa z zewnętrznego zakresu jest następnie określana jako ***Ukryta*** w regionie tekstu programu objętego zakresem wewnętrznym, a dostęp do nazwy zewnętrznej jest możliwy tylko przez zakwalifikowanie nazwy.</span><span class="sxs-lookup"><span data-stu-id="4e268-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="4e268-384">Zakres elementu członkowskiego przestrzeni nazw zadeklarowany przez *namespace_member_declaration* ([elementy członkowskie obszaru nazw](namespaces.md#namespace-members)) bez otaczającego *namespace_declaration* jest całym tekstem programu.</span><span class="sxs-lookup"><span data-stu-id="4e268-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="4e268-385">Zakres elementu członkowskiego przestrzeni nazw zadeklarowany przez *namespace_member_declaration* w *namespace_declaration* , którego w pełni kwalifikowana nazwa jest `N` jest *namespace_body* każdego *namespace_declaration* , którego w pełni kwalifikowana nazwa jest `N` lub rozpoczyna się od `N`, po którym następuje kropka.</span><span class="sxs-lookup"><span data-stu-id="4e268-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="4e268-386">Zakres nazwy zdefiniowany przez *extern_alias_directive* rozciąga się na *using_directive*s, *global_attributes* i *namespace_member_declaration*s jego bezpośrednio zawierający jednostkę kompilacji lub treść przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="4e268-387">*Extern_alias_directive* nie współtworzy żadnych nowych członków do bazowego obszaru deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="4e268-388">Inaczej mówiąc, *extern_alias_directive* nie jest przechodnia, ale ma wpływ tylko na jednostkę kompilacji lub treść przestrzeni nazw, w której występuje.</span><span class="sxs-lookup"><span data-stu-id="4e268-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="4e268-389">Zakres nazwy zdefiniowany lub zaimportowany przez *using_directive* ([dyrektywy using](namespaces.md#using-directives)) rozciąga się na *namespace_member_declaration*s *compilation_unit* lub *namespace_body* , w których występuje *using_directive* .</span><span class="sxs-lookup"><span data-stu-id="4e268-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="4e268-390">*Using_directive* może wprowadzać zero lub większą liczbę nazw, typów lub elementów członkowskich, które są dostępne w ramach określonego *compilation_unit* lub *namespace_body*, ale nie współtworzy żadnych nowych członków do źródłowej przestrzeni deklaracji.</span><span class="sxs-lookup"><span data-stu-id="4e268-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="4e268-391">Innymi słowy *using_directive* nie jest przechodnia, ale ma wpływ tylko na *compilation_unit* lub *namespace_body* , w których występuje.</span><span class="sxs-lookup"><span data-stu-id="4e268-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="4e268-392">Zakres parametru typu zadeklarowanego przez *type_parameter_list* na *class_declaration* ([deklaracji klas](classes.md#class-declarations)) to *class_base*, *type_parameter_constraints_clause*s i *class_body* tego *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="4e268-393">Zakres parametru typu zadeklarowany przez *type_parameter_list* na *struct_declaration* ([deklaracje struktury](structs.md#struct-declarations)) to *struct_interfaces*, *type_parameter_constraints_clause*s i *struct_body* tego *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="4e268-394">Zakres parametru typu zadeklarowanego przez *type_parameter_list* na *interface_declaration* ([deklaracji interfejsu](interfaces.md#interface-declarations)) to *interface_base*, *type_parameter_constraints_clause*s i *interface_body* tego *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="4e268-395">Zakres parametru typu zadeklarowany przez *type_parameter_list* na *delegate_declaration* ([deklaracje delegatów](delegates.md#delegate-declarations)) to *return_type*, *formal_parameter_list*i *type_parameter_constraints_clause*s tego *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="4e268-396">Zakres składowej zadeklarowanej przez *class_member_declaration* ([Treść klasy](classes.md#class-body)) to *class_body* , w której występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="4e268-397">Ponadto zakres elementu członkowskiego klasy rozciąga się na *class_body* tych klas pochodnych, które znajdują się w domenie dostępności ([domeny ułatwień dostępu](basic-concepts.md#accessibility-domains)) elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="4e268-398">Zakres elementu członkowskiego zadeklarowany przez *struct_member_declaration* ([elementy członkowskie struktury](structs.md#struct-members)) to *struct_body* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4e268-399">Zakres elementu członkowskiego zadeklarowany przez *enum_member_declaration* ([elementy członkowskie wyliczenia](enums.md#enum-members)) to *enum_body* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4e268-400">Zakres parametru zadeklarowany w *method_declaration* ([metody](classes.md#methods)) to *method_body* tego *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="4e268-401">Zakres parametru zadeklarowany w *indexer_declaration* ([indeksatory](classes.md#indexers)) to *accessor_declarations* tego *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="4e268-402">Zakres parametru zadeklarowany w *operator_declaration* ([Operatory](classes.md#operators)) jest *blokiem* tego *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="4e268-403">Zakres parametru zadeklarowany w *constructor_declaration* ([konstruktory wystąpień](classes.md#instance-constructors)) to *constructor_initializer* i *blok* tego *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="4e268-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="4e268-404">Zakres parametru zadeklarowany w *lambda_expression* ([wyrażenia funkcji anonimowej](expressions.md#anonymous-function-expressions)) to *anonymous_function_body* *lambda_expression*</span><span class="sxs-lookup"><span data-stu-id="4e268-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="4e268-405">Zakres parametru zadeklarowany w *anonymous_method_expression* ([wyrażenia funkcji anonimowej](expressions.md#anonymous-function-expressions)) jest *blokiem* tego *anonymous_method_expression*.</span><span class="sxs-lookup"><span data-stu-id="4e268-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="4e268-406">Zakres etykiety zadeklarowanej w *labeled_statement* ([instrukcje z etykietą](statements.md#labeled-statements)) to *blok* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="4e268-407">Zakres zmiennej lokalnej zadeklarowanej w *local_variable_declaration* ([lokalna deklaracja zmiennej](statements.md#local-variable-declarations)) to blok, w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="4e268-408">Zakres zmiennej lokalnej zadeklarowanej w *switch_block* instrukcji `switch` ([instrukcja switch](statements.md#the-switch-statement)) to *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="4e268-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="4e268-409">Zakres zmiennej lokalnej zadeklarowanej w *for_initializer* instrukcji `for` ([instrukcja for](statements.md#the-for-statement)) to *for_initializer*, *for_condition*, *for_iterator*i zawartej *instrukcji* instrukcji `for`.</span><span class="sxs-lookup"><span data-stu-id="4e268-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="4e268-410">Zakres stałej lokalnej zadeklarowanej w *local_constant_declaration* ([lokalna deklaracja stała](statements.md#local-constant-declarations)) to blok, w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="4e268-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="4e268-411">Jest to błąd czasu kompilacji, który odwołuje się do lokalnej stałej w pozycji tekstowej, która poprzedza jej *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="4e268-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="4e268-412">Zakres zmiennej zadeklarowanej jako część *foreach_statement*, *using_statement*, *lock_statement* lub *query_expression* jest określany przez rozszerzenie danej konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="4e268-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="4e268-413">W zakresie przestrzeni nazw, klasy, struktury lub składowej wyliczenia można odwołać się do elementu członkowskiego w pozycji tekstowej, która poprzedza deklarację elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="4e268-414">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4e268-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="4e268-415">W tym miejscu jest ważne, aby `F` odwoływać się do `i` przed zadeklarowaniem.</span><span class="sxs-lookup"><span data-stu-id="4e268-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="4e268-416">W zakresie zmiennej lokalnej jest to błąd czasu kompilacji, który odwołuje się do zmiennej lokalnej w pozycji tekstowej, która poprzedza *local_variable_declarator* zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="4e268-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="4e268-417">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4e268-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="4e268-418">W powyższej metodzie `F` pierwsze przypisanie do `i` szczególne nie odwołuje się do pola zadeklarowanego w zewnętrznym zakresie.</span><span class="sxs-lookup"><span data-stu-id="4e268-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="4e268-419">Nie odnosi się do zmiennej lokalnej i powoduje błąd czasu kompilacji, ponieważ jest ona poprzedzona znakiem deklaracji zmiennej.</span><span class="sxs-lookup"><span data-stu-id="4e268-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="4e268-420">W metodzie `G` użycie `j` w inicjatorze dla deklaracji `j` jest prawidłowe, ponieważ użycie nie poprzedza *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="4e268-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="4e268-421">W metodzie `H` kolejne *local_variable_declarator* prawidłowo odwołują się do zmiennej lokalnej zadeklarowanej we wcześniejszym *local_variable_declarator* w ramach tego samego *local_variable_declarationu*.</span><span class="sxs-lookup"><span data-stu-id="4e268-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="4e268-422">Reguły określania zakresu dla zmiennych lokalnych są zaprojektowane w celu zagwarantowania, że znaczenie nazwy używanej w kontekście wyrażenia jest zawsze takie samo w bloku.</span><span class="sxs-lookup"><span data-stu-id="4e268-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="4e268-423">Jeśli zakres zmiennej lokalnej miał zostać rozbudowany tylko od jej deklaracji do końca bloku, wówczas w powyższym przykładzie pierwsze przypisanie zostanie przypisane do zmiennej wystąpienia, a drugie przypisanie zostanie przypisane do zmiennej lokalnej, co może prowadzić do Błędy czasu kompilacji, jeśli instrukcje bloku były później zmieniane.</span><span class="sxs-lookup"><span data-stu-id="4e268-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="4e268-424">Znaczenie nazwy w bloku może się różnić w zależności od kontekstu, w którym jest używana nazwa.</span><span class="sxs-lookup"><span data-stu-id="4e268-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="4e268-425">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="4e268-426">Nazwa `A` jest używana w kontekście wyrażenia do odwoływania się do zmiennej lokalnej `A` i w kontekście typu, aby odwołać się do klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="4e268-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="4e268-427">Ukrywanie nazwy</span><span class="sxs-lookup"><span data-stu-id="4e268-427">Name hiding</span></span>

<span data-ttu-id="4e268-428">Zakres jednostki zwykle obejmuje więcej tekstu programu niż miejsce zadeklarowane w jednostce.</span><span class="sxs-lookup"><span data-stu-id="4e268-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="4e268-429">W szczególności zakres jednostki może zawierać deklaracje wprowadzające nowe obszary deklaracji zawierające jednostki o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="4e268-430">Takie deklaracje powodują, że oryginalna jednostka zostanie ***Ukryta***.</span><span class="sxs-lookup"><span data-stu-id="4e268-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="4e268-431">Z drugiej strony jednostka jest ***widoczna*** , gdy nie jest ukryta.</span><span class="sxs-lookup"><span data-stu-id="4e268-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="4e268-432">Ukrywanie nazw występuje, gdy zakresy nakładają się na zagnieżdżenie i gdy zakresy nakładają się na dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="4e268-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="4e268-433">Właściwości dwóch typów ukrywania są opisane w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="4e268-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="4e268-434">Ukrywanie przez zagnieżdżanie</span><span class="sxs-lookup"><span data-stu-id="4e268-434">Hiding through nesting</span></span>

<span data-ttu-id="4e268-435">Nazwa ukrywająca przy użyciu zagnieżdżenia może wystąpić w wyniku zagnieżdżania przestrzeni nazw lub typów w przestrzeni nazw, w wyniku zagnieżdżania typów w obrębie klas lub struktur, a także jako wynik deklaracji parametrów i zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="4e268-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="4e268-436">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="4e268-437">w metodzie `F` zmienna wystąpienia `i` jest ukryta przez zmienną lokalną `i`, ale w ramach metody `G`, `i` nadal odwołuje się do zmiennej wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4e268-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="4e268-438">Gdy nazwa w zakresie wewnętrznym ukrywa nazwę w zewnętrznym zakresie, ukrywa wszystkie załadowane wystąpienia tej nazwy.</span><span class="sxs-lookup"><span data-stu-id="4e268-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="4e268-439">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="4e268-440">Wywołanie `F(1)` wywołuje `F` zadeklarowane w `Inner`, ponieważ wszystkie zewnętrzne wystąpienia `F` są ukryte przez wewnętrzną deklarację.</span><span class="sxs-lookup"><span data-stu-id="4e268-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="4e268-441">Z tego samego powodu wywołanie `F("Hello")` powoduje błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="4e268-442">Ukrywanie poprzez dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="4e268-442">Hiding through inheritance</span></span>

<span data-ttu-id="4e268-443">Nazwa ukrywając przy użyciu dziedziczenia występuje, gdy klasy lub struktury ponownie deklarują nazwy dziedziczone z klas bazowych.</span><span class="sxs-lookup"><span data-stu-id="4e268-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="4e268-444">Ten typ ukrywania nazwy ma jedną z następujących form:</span><span class="sxs-lookup"><span data-stu-id="4e268-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="4e268-445">Stałe, pole, właściwość, zdarzenie lub typ wprowadzone w klasie lub strukturze ukrywa wszystkie składowe klasy bazowej o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="4e268-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="4e268-446">Metoda wprowadzona w klasie lub strukturze ukrywa wszystkie składowe klas podstawowych niebędących metodami o tej samej nazwie i wszystkie metody klasy bazowej o tej samej sygnaturze (nazwa metody i liczba parametrów, modyfikatory i typy).</span><span class="sxs-lookup"><span data-stu-id="4e268-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="4e268-447">Indeksator wprowadzony w klasie lub strukturze ukrywa wszystkie indeksatory klasy bazowej o tej samej sygnaturze (liczba parametrów i typy).</span><span class="sxs-lookup"><span data-stu-id="4e268-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="4e268-448">Reguły dotyczące deklaracji operatora ([Operatory](classes.md#operators)) sprawiają, że Klasa pochodna nie może deklarować operatora z tym samym podpisem jako operatora w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="4e268-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="4e268-449">W tym celu operatory nigdy nie są ukrywane.</span><span class="sxs-lookup"><span data-stu-id="4e268-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="4e268-450">W przeciwieństwie do ukrywania nazwy z zewnętrznego zakresu ukrycie dostępnej nazwy z dziedziczonego zakresu powoduje ostrzeżenie o zgłoszeniu.</span><span class="sxs-lookup"><span data-stu-id="4e268-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="4e268-451">w przykładzie</span><span class="sxs-lookup"><span data-stu-id="4e268-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="4e268-452">Deklaracja `F` w `Derived` powoduje zgłoszenie ostrzeżenia.</span><span class="sxs-lookup"><span data-stu-id="4e268-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="4e268-453">Ukrycie dziedziczonej nazwy nie jest jawnie błędem, ponieważ spowodowałoby to wykluczenie oddzielnego ewolucji klas bazowych.</span><span class="sxs-lookup"><span data-stu-id="4e268-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="4e268-454">Na przykład Powyższa sytuacja może być spowodowana tym, że w nowszej wersji `Base` wprowadzono metodę `F`, która nie jest obecna we wcześniejszej wersji klasy.</span><span class="sxs-lookup"><span data-stu-id="4e268-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="4e268-455">W przypadku powyższej sytuacji Wystąpił błąd, a następnie wszelkie zmiany wprowadzone do klasy podstawowej w bibliotece klas z odrębną wersją mogą potencjalnie spowodować, że klasy pochodne staną się nieprawidłowe.</span><span class="sxs-lookup"><span data-stu-id="4e268-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="4e268-456">Ostrzeżenie spowodowane ukrywaniem dziedziczonej nazwy można wyeliminować za pomocą modyfikatora `new`:</span><span class="sxs-lookup"><span data-stu-id="4e268-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="4e268-457">Modyfikator `new` wskazuje, że `F` w `Derived` jest "New" i że rzeczywiście jest przeznaczony do ukrycia dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="4e268-458">Deklaracja nowego elementu członkowskiego powoduje ukrycie dziedziczonego elementu członkowskiego tylko w zakresie nowego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="4e268-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="4e268-459">W powyższym przykładzie deklaracja `F` w `Derived` powoduje ukrycie `F`, która była dziedziczona z `Base`, ale ponieważ nowy `F` w `Derived` ma dostęp prywatny, jego zakres nie obejmuje `MoreDerived`.</span><span class="sxs-lookup"><span data-stu-id="4e268-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="4e268-460">W tym celu `F()` wywołań w `MoreDerived.G` jest prawidłowy i wywoła `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="4e268-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="4e268-461">Nazwa przestrzeni nazw i typów</span><span class="sxs-lookup"><span data-stu-id="4e268-461">Namespace and type names</span></span>

<span data-ttu-id="4e268-462">Kilka kontekstów w C# programie wymaga określenia *namespace_name* lub *TYPE_NAME* .</span><span class="sxs-lookup"><span data-stu-id="4e268-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="4e268-463">*Namespace_name* jest *namespace_or_type_name* , który odwołuje się do przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="4e268-464">Poniższe rozwiązanie, jak opisano poniżej, *namespace_or_type_name* *namespace_name* musi odwoływać się do przestrzeni nazw lub w przeciwnym razie wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="4e268-465">Brak argumentów typu ([argumenty typu](types.md#type-arguments)) w *namespace_name* (tylko typy mogą mieć argumenty typu).</span><span class="sxs-lookup"><span data-stu-id="4e268-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="4e268-466">*TYPE_NAME* jest *namespace_or_type_name* , który odwołuje się do typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="4e268-467">Poniższe rozwiązanie, jak opisano poniżej, *namespace_or_type_name* *TYPE_NAME* musi odwoływać się do typu lub w przeciwnym razie wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="4e268-468">Jeśli *namespace_or_type_name* jest aliasem kwalifikowanym, jego znaczenie jest zgodnie z opisem w [kwalifikatorach aliasów przestrzeni nazw](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="4e268-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="4e268-469">W przeciwnym razie *namespace_or_type_name* ma jedną z czterech postaci:</span><span class="sxs-lookup"><span data-stu-id="4e268-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="4e268-470">gdzie `I` jest pojedynczym identyfikatorem, `N` jest *namespace_or_type_name* , a `<A1, ..., Ak>` jest opcjonalną *type_argument_list*.</span><span class="sxs-lookup"><span data-stu-id="4e268-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="4e268-471">Gdy nie określono *type_argument_list* , należy wziąć pod uwagę `k` wartość zero.</span><span class="sxs-lookup"><span data-stu-id="4e268-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="4e268-472">Znaczenie *namespace_or_type_name* jest określane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e268-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="4e268-473">Jeśli *namespace_or_type_name* ma postać `I` lub formularza `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="4e268-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="4e268-474">Jeśli `K` ma wartość zero, a *namespace_or_type_name* pojawia się w deklaracji metody ogólnej ([metody](classes.md#methods)), a jeśli ta deklaracja zawiera parametr typu ([parametry typu](classes.md#type-parameters)) o nazwie `I`, *namespace_or_type_name* odwołuje się do tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="4e268-475">W przeciwnym razie, jeśli *namespace_or_type_name* pojawia się w deklaracji typu, wówczas dla każdego typu wystąpienia `T` ([Typ wystąpienia](classes.md#the-instance-type)), rozpoczynając od typu wystąpienia tego typu deklaracji i kontynuując typ wystąpienia każdej klasy lub deklaracji struktury (jeśli istnieje):</span><span class="sxs-lookup"><span data-stu-id="4e268-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="4e268-476">Jeśli `K` ma wartość zero, a deklaracja `T` zawiera parametr typu o nazwie `I`, wówczas *namespace_or_type_name* odwołuje się do tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="4e268-477">W przeciwnym razie, jeśli *namespace_or_type_name* pojawia się w treści deklaracji typu, a `T` lub dowolny z jej typów podstawowych zawiera zagnieżdżony dostępny typ o nazwie `I` i `K` parametry typu, wówczas *namespace_or_type_name* odwołuje się do tego typu skonstruowanego za pomocą podanych argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="4e268-478">Jeśli jest więcej niż jeden taki typ, zostanie wybrany typ zadeklarowany w ramach bardziej pochodnego typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="4e268-479">Należy zauważyć, że elementy członkowskie inne niż typy (stałe, pola, metody, właściwości, indeksatory, operatory, konstruktory wystąpień, destruktory i konstruktory statyczne) i elementy członkowskie typu z inną liczbą parametrów typu są ignorowane podczas określania znaczenia *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="4e268-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="4e268-480">Jeśli poprzednie kroki nie powiodły się, dla każdej przestrzeni nazw `N`, rozpoczynając od przestrzeni nazw, w której występuje *namespace_or_type_name* , kontynuując z każdą otaczającą przestrzeń nazw (jeśli istnieje) i kończąc z globalną przestrzenią nazw, następujące kroki są oceniane do momentu zlokalizowania jednostki:</span><span class="sxs-lookup"><span data-stu-id="4e268-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="4e268-481">Jeśli `K` ma wartość zero, a `I` to nazwa przestrzeni nazw w `N`, wówczas:</span><span class="sxs-lookup"><span data-stu-id="4e268-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="4e268-482">Jeśli lokalizacja, w której występuje *namespace_or_type_name* , jest ujęta w deklarację przestrzeni nazw dla `N`, a Deklaracja przestrzeni nazw zawiera *extern_alias_directive* lub *using_alias_directive* , która kojarzy nazwę `I` z przestrzenią nazw lub typem, wówczas *namespace_or_type_name* jest niejednoznaczna i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="4e268-483">W przeciwnym razie *namespace_or_type_name* odwołuje się do przestrzeni nazw o nazwie `I` w `N`.</span><span class="sxs-lookup"><span data-stu-id="4e268-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="4e268-484">W przeciwnym razie, jeśli `N` zawiera dostępny typ o nazwie `I` i `K`parametrów typu  , wówczas:</span><span class="sxs-lookup"><span data-stu-id="4e268-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="4e268-485">Jeśli `K` ma wartość zero, a lokalizacja, w której występuje *namespace_or_type_name* , jest ujęta w deklarację przestrzeni nazw dla `N` a Deklaracja przestrzeni nazw zawiera *extern_alias_directive* lub *using_alias_directive* , który kojarzy nazwę `I` z przestrzenią nazw lub typem, wówczas *namespace_or_type_name* jest niejednoznaczna i wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="4e268-486">W przeciwnym razie *namespace_or_type_name* odwołuje się do typu złożonego za pomocą podanych argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="4e268-487">W przeciwnym razie, jeśli lokalizacja, w której występuje *namespace_or_type_name* , jest ujęta w deklarację przestrzeni nazw dla `N`:</span><span class="sxs-lookup"><span data-stu-id="4e268-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="4e268-488">Jeśli `K` ma wartość zero, a Deklaracja przestrzeni nazw zawiera *extern_alias_directive* lub *using_alias_directive* , które kojarzą nazwę `I` z zaimportowaną przestrzenią nazw lub typem, wówczas *namespace_or_type_name* odwołuje się do tej przestrzeni nazw lub typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="4e268-489">W przeciwnym razie, jeśli przestrzenie nazw i deklaracje typów zaimportowane przez *using_namespace_directive*s i *using_alias_directive*s deklaracji przestrzeni nazw zawierają dokładnie jeden dostępny typ o nazwie `I` i `K` parametry typu, a następnie *namespace_or_type_name* odwołuje się do tego typu skonstruowanego za pomocą podanych argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="4e268-490">W przeciwnym razie, jeśli przestrzenie nazw i deklaracje typów zaimportowane przez *using_namespace_directive*s i *using_alias_directive*s deklaracji przestrzeni nazw zawierają więcej niż jeden dostępny typ o nazwie `I` i `K` parametry typu, wówczas *namespace_or_type_name* jest niejednoznaczny i wystąpi błąd.</span><span class="sxs-lookup"><span data-stu-id="4e268-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="4e268-491">W przeciwnym razie *namespace_or_type_name* jest niezdefiniowana i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="4e268-492">W przeciwnym razie *namespace_or_type_name* ma postać `N.I` lub `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="4e268-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="4e268-493">`N` został najpierw rozpoznany jako *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="4e268-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="4e268-494">Jeśli rozwiązanie `N` nie powiedzie się, wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="4e268-495">W przeciwnym razie `N.I` lub `N.I<A1, ..., Ak>` są rozwiązywane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e268-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="4e268-496">Jeśli `K` ma wartość zero i `N` odwołuje się do przestrzeni nazw, a `N` zawiera zagnieżdżoną przestrzeń nazw o nazwie `I`, wówczas *namespace_or_type_name* odwołuje się do tej zagnieżdżonej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="4e268-497">W przeciwnym razie, jeśli `N` odwołuje się do przestrzeni nazw, a `N` zawiera dostępny typ o nazwie `I` i `K` parametry typu, wówczas *namespace_or_type_name* odwołuje się do tego typu skonstruowanego za pomocą podanych argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="4e268-498">W przeciwnym razie, jeśli `N` odwołuje się do klasy lub typu struktury, a `N` lub dowolna z jej klas podstawowych zawiera zagnieżdżony dostępny typ o nazwie `I` i `K` parametry typu, a następnie *namespace_or_type_name* odwołuje się do tego typu skonstruowanego za pomocą podanych argumentów typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="4e268-499">Jeśli jest więcej niż jeden taki typ, zostanie wybrany typ zadeklarowany w ramach bardziej pochodnego typu.</span><span class="sxs-lookup"><span data-stu-id="4e268-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="4e268-500">Należy pamiętać, że jeśli znaczenie `N.I` jest określane jako część rozpoznawania specyfikacji klasy bazowej `N`, bezpośrednia klasa bazowa `N` jest uznawana za obiekt ([klasy bazowe](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="4e268-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="4e268-501">W przeciwnym razie `N.I` jest nieprawidłowym *namespace_or_type_name*i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4e268-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="4e268-502">*Namespace_or_type_name* może odwoływać się do klasy statycznej ([klasy statyczne](classes.md#static-classes)) tylko wtedy, gdy</span><span class="sxs-lookup"><span data-stu-id="4e268-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="4e268-503">*Namespace_or_type_name* jest `T` w *namespace_or_type_name* `T.I`formularz, lub</span><span class="sxs-lookup"><span data-stu-id="4e268-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="4e268-504">*Namespace_or_type_name* jest `T` w *typeof_expression* ([Argument Lists](expressions.md#argument-lists)1) `typeof(T)`formularza.</span><span class="sxs-lookup"><span data-stu-id="4e268-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="4e268-505">W pełni kwalifikowane nazwy</span><span class="sxs-lookup"><span data-stu-id="4e268-505">Fully qualified names</span></span>

<span data-ttu-id="4e268-506">Każda przestrzeń nazw i typ mają w ***pełni kwalifikowaną nazwę***, która jednoznacznie identyfikuje przestrzeń nazw lub typ między wszystkimi innymi.</span><span class="sxs-lookup"><span data-stu-id="4e268-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="4e268-507">W pełni kwalifikowana nazwa przestrzeni nazw lub typu `N` jest określana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4e268-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="4e268-508">Jeśli `N` jest członkiem globalnej przestrzeni nazw, jego w pełni kwalifikowana nazwa jest `N`.</span><span class="sxs-lookup"><span data-stu-id="4e268-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="4e268-509">W przeciwnym razie jego w pełni kwalifikowana nazwa jest `S.N`, gdzie `S` to w pełni kwalifikowana nazwa przestrzeni nazw lub typu, w którym `N` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="4e268-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="4e268-510">Innymi słowy, w pełni kwalifikowana nazwa `N` jest pełną ścieżką hierarchiczną identyfikatorów, które prowadzą do `N`, rozpoczynając od globalnej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="4e268-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="4e268-511">Ponieważ każdy element członkowski przestrzeni nazw lub typu musi mieć unikatową nazwę, następuje, że w pełni kwalifikowana nazwa przestrzeni nazw lub typu jest zawsze unikatowa.</span><span class="sxs-lookup"><span data-stu-id="4e268-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="4e268-512">W poniższym przykładzie przedstawiono kilka nazw i deklaracji typów wraz z ich skojarzonymi w pełni kwalifikowanymi nazwami.</span><span class="sxs-lookup"><span data-stu-id="4e268-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="4e268-513">Automatyczne zarządzanie pamięcią</span><span class="sxs-lookup"><span data-stu-id="4e268-513">Automatic memory management</span></span>

<span data-ttu-id="4e268-514">C#Program wykorzystuje automatyczne zarządzanie pamięcią, dzięki czemu deweloperzy mogą bezpłatnie przydzielać i zwalniać pamięć zajmowaną przez obiekty.</span><span class="sxs-lookup"><span data-stu-id="4e268-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="4e268-515">Automatyczne zasady zarządzania pamięcią są implementowane przez ***Moduł wyrzucania elementów bezużytecznych***.</span><span class="sxs-lookup"><span data-stu-id="4e268-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="4e268-516">Cykl życia zarządzania pamięcią obiektu jest następujący:</span><span class="sxs-lookup"><span data-stu-id="4e268-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="4e268-517">Po utworzeniu obiektu zostanie do niego przydzielono pamięć, Konstruktor zostanie uruchomiony, a obiekt jest uznawany za aktywny.</span><span class="sxs-lookup"><span data-stu-id="4e268-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="4e268-518">Jeśli obiektu lub dowolnej jego części nie można uzyskać dostępu do żadnego możliwej kontynuacji wykonywania, z wyjątkiem uruchamiania destruktorów, obiekt jest uważany za nieużywany i będzie uprawniony do zniszczenia.</span><span class="sxs-lookup"><span data-stu-id="4e268-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="4e268-519">C# Kompilator i moduł wyrzucania elementów bezużytecznych mogą analizować kod, aby określić, które odwołania do obiektu mogą być używane w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="4e268-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="4e268-520">Na przykład jeśli zmienna lokalna, która znajduje się w zakresie, jest jedynym istniejącym odwołaniem do obiektu, ale ta zmienna lokalna nigdy nie jest określana w żadnej możliwej kontynuacji wykonywania z bieżącego punktu wykonywania w procedurze, Moduł wyrzucania elementów bezużytecznych może (ale nie) wymagane do) traktuje obiekt jako nieużywany.</span><span class="sxs-lookup"><span data-stu-id="4e268-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="4e268-521">Gdy obiekt kwalifikuje się do zniszczenia, w przypadku, gdy nie zostanie określony później destruktor ([destruktory](classes.md#destructors)) (jeśli istnieje) dla obiektu jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="4e268-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="4e268-522">W normalnych warunkach destruktor dla obiektu jest uruchamiany tylko raz, ale interfejsy API specyficzne dla implementacji mogą zezwalać na przesłanianie tego zachowania.</span><span class="sxs-lookup"><span data-stu-id="4e268-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="4e268-523">Po uruchomieniu destruktora obiektu, jeśli ten obiekt lub jakakolwiek jego część nie są dostępne w żadnej możliwej kontynuacji wykonywania, w tym uruchamiania destruktorów, obiekt jest uznawany za niedostępny i obiekt kwalifikuje się do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="4e268-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="4e268-524">Na koniec po pewnym czasie po przypisaniu obiektu do kolekcji moduł wyrzucania elementów bezużytecznych zwolni pamięć skojarzoną z tym obiektem.</span><span class="sxs-lookup"><span data-stu-id="4e268-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="4e268-525">Moduł wyrzucania elementów bezużytecznych przechowuje informacje o użyciu obiektów i używa tych informacji do podejmowania decyzji dotyczących zarządzania pamięcią, takich jak miejsce w pamięci do lokalizowania nowo utworzonego obiektu, kiedy przemieszczenie obiektu, gdy obiekt nie jest już używany lub niedostępny.</span><span class="sxs-lookup"><span data-stu-id="4e268-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="4e268-526">Podobnie jak w przypadku innych języków, które zakładają istnienie C# wyrzucania elementów bezużytecznych, zaprojektowano tak, aby moduł zbierający elementy bezużyteczne mógł zaimplementować szeroką gamę zasad zarządzania pamięcią</span><span class="sxs-lookup"><span data-stu-id="4e268-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="4e268-527">Na przykład program C# nie wymaga uruchomienia destruktorów lub obiektów, które są zbierane zaraz po ich zakwalifikowaniu lub że destruktory są uruchamiane w określonej kolejności lub w dowolnym wątku.</span><span class="sxs-lookup"><span data-stu-id="4e268-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="4e268-528">Zachowanie modułu wyrzucania elementów bezużytecznych może być kontrolowane w pewnym stopniu za pomocą metod statycznych w klasie `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="4e268-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="4e268-529">Ta klasa może służyć do żądania kolekcji, destruktorów, które mają być uruchamiane (lub nie są uruchamiane) i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="4e268-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="4e268-530">Ponieważ moduł wyrzucania elementów bezużytecznych jest dozwolony szerokiej szerokości geograficznej podczas wybierania obiektów i destruktorów, implementacja zgodna może generować dane wyjściowe, które różnią się od pokazanego w poniższym kodzie.</span><span class="sxs-lookup"><span data-stu-id="4e268-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="4e268-531">Program</span><span class="sxs-lookup"><span data-stu-id="4e268-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="4e268-532">tworzy wystąpienie klasy `A` i wystąpienie klasy `B`.</span><span class="sxs-lookup"><span data-stu-id="4e268-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="4e268-533">Te obiekty stają się kwalifikować do wyrzucania elementów bezużytecznych, gdy zmienna `b` ma przypisaną wartość `null`, ponieważ po tym czasie nie jest możliwe uzyskanie dostępu do nich przez każdy kod pisany przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="4e268-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="4e268-534">Dane wyjściowe mogą być albo</span><span class="sxs-lookup"><span data-stu-id="4e268-534">The output could be either</span></span>

```console
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="4e268-535">lub</span><span class="sxs-lookup"><span data-stu-id="4e268-535">or</span></span>
```console
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="4e268-536">Ponieważ język nie nakłada żadnych ograniczeń w kolejności, w której obiekty są odbierane jako elementy bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="4e268-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="4e268-537">W delikatnych przypadkach rozróżnienie między elementami "kwalifikujące się do zniszczenia" i "kwalifikujące się do kolekcji" może być ważne.</span><span class="sxs-lookup"><span data-stu-id="4e268-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="4e268-538">Na przykład</span><span class="sxs-lookup"><span data-stu-id="4e268-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="4e268-539">Jeśli moduł wyrzucania elementów bezużytecznych wybierze uruchomienie destruktora `A` przed destruktorem `B`, dane wyjściowe tego programu mogą być następujące:</span><span class="sxs-lookup"><span data-stu-id="4e268-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```console
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="4e268-540">Należy zauważyć, że chociaż wystąpienie `A` było nieużywane i nie uruchomiono destruktora `A`, nadal jest możliwe Metoda `A` (w tym przypadku `F`) do wywołania z innego destruktora.</span><span class="sxs-lookup"><span data-stu-id="4e268-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="4e268-541">Należy również pamiętać, że uruchomienie destruktora może spowodować, że obiekt będzie można użyć ponownie z programu linii głównej.</span><span class="sxs-lookup"><span data-stu-id="4e268-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="4e268-542">W takim przypadku uruchomienie destruktora `B`spowodowało wystąpienie `A`, które wcześniej nie było używane do uzyskania dostępu z `Test.RefA`na żywo odwołania.</span><span class="sxs-lookup"><span data-stu-id="4e268-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="4e268-543">Po wywołaniu `WaitForPendingFinalizers`wystąpienie `B` jest uprawnione do kolekcji, ale wystąpienie `A` nie jest, ze względu na `Test.RefA`odwołania.</span><span class="sxs-lookup"><span data-stu-id="4e268-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="4e268-544">Aby uniknąć nieporozumień i nieoczekiwanego zachowania, zwykle dobrym pomysłem jest, aby destruktory wykonywały tylko oczyszczanie danych przechowywanych w własnych polach obiektu, a nie do wykonywania żadnych akcji na obiektach, do których istnieją odwołania lub pola statyczne.</span><span class="sxs-lookup"><span data-stu-id="4e268-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="4e268-545">Alternatywą dla korzystania z destruktorów jest umożliwienie klasy implementującej interfejs `System.IDisposable`.</span><span class="sxs-lookup"><span data-stu-id="4e268-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="4e268-546">Umożliwia to klientowi obiektu określenie czasu zwolnienia zasobów obiektu, zazwyczaj przez uzyskanie dostępu do obiektu jako zasobu w instrukcji `using` ([instrukcja using](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="4e268-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="4e268-547">Kolejność wykonywania</span><span class="sxs-lookup"><span data-stu-id="4e268-547">Execution order</span></span>

<span data-ttu-id="4e268-548">Wykonanie C# programu jest wykonywane w taki sposób, że efekty uboczne każdego wątku wykonywanego są zachowywane w kluczowych punktach wykonania.</span><span class="sxs-lookup"><span data-stu-id="4e268-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="4e268-549">***Efekt uboczny*** jest definiowany jako Odczyt lub zapis pola nietrwałego, zapis do zmiennej nietrwałej, zapis do zasobu zewnętrznego i wyrzucanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="4e268-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="4e268-550">Krytyczne punkty wykonywania, w których kolejność tych efektów ubocznych muszą być zachowywane, są odwołaniami do pól nietrwałych ([pól nietrwałych](classes.md#volatile-fields)), instrukcji `lock` ([instrukcja Lock](statements.md#the-lock-statement)) oraz tworzenia i kończenia wątku.</span><span class="sxs-lookup"><span data-stu-id="4e268-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="4e268-551">Środowisko wykonawcze jest bezpłatne, aby zmienić kolejność wykonywania C# programu, zgodnie z następującymi ograniczeniami:</span><span class="sxs-lookup"><span data-stu-id="4e268-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="4e268-552">Zależność danych jest zachowywana w wątku wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4e268-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="4e268-553">Oznacza to, że wartość każdej zmiennej jest obliczana tak, jakby wszystkie instrukcje w wątku były wykonywane w oryginalnej kolejności programu.</span><span class="sxs-lookup"><span data-stu-id="4e268-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="4e268-554">Reguły porządkowania inicjalizacji są zachowywane ([Inicjalizacja pola](classes.md#field-initialization) i [inicjatory zmiennych](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="4e268-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="4e268-555">Porządkowanie efektów ubocznych jest zachowywane w odniesieniu do nietrwałych odczytów i zapisów ([pola nietrwałe](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="4e268-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="4e268-556">Ponadto środowisko wykonawcze nie musi obliczać części wyrażenia, jeśli może wywnioskować, że wartość tego wyrażenia nie jest używana i że nie są generowane żadne niepotrzebne efekty uboczne (w tym wszelkie powodowane przez wywołanie metody lub uzyskanie dostępu do pola nietrwałego).</span><span class="sxs-lookup"><span data-stu-id="4e268-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="4e268-557">Po przerwaniu wykonywania programu przez zdarzenie asynchroniczne (takie jak wyjątek zgłoszony przez inny wątek) nie jest gwarantowane, że zauważalne efekty uboczne są widoczne w oryginalnym porządku programu.</span><span class="sxs-lookup"><span data-stu-id="4e268-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
