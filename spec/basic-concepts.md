# <a name="basic-concepts"></a><span data-ttu-id="cbd27-101">Podstawowe pojęcia</span><span class="sxs-lookup"><span data-stu-id="cbd27-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="cbd27-102">Uruchamianie aplikacji</span><span class="sxs-lookup"><span data-stu-id="cbd27-102">Application Startup</span></span>

<span data-ttu-id="cbd27-103">Zestaw, który ma ***punktu wejścia*** nosi nazwę ***aplikacji***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="cbd27-104">Gdy aplikacja jest uruchomić nową ***domeny aplikacji*** zostanie utworzony.</span><span class="sxs-lookup"><span data-stu-id="cbd27-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="cbd27-105">Kilka różne wystąpienia aplikacji mogą istnieć na tym samym komputerze, w tym samym czasie, a każde z nich ma swoje własne domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="cbd27-106">Domeny aplikacji umożliwia izolacji aplikacji według działających jako kontener dla stanu aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="cbd27-107">Domeny aplikacji działa jako kontener i granic dla typów zdefiniowanych w aplikacji i bibliotek klas, które są używane.</span><span class="sxs-lookup"><span data-stu-id="cbd27-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="cbd27-108">Typy załadowane do jednej domeny aplikacji różnią się od tego samego typu, które są ładowane do innej domeny aplikacji, a wystąpienia obiektów, nie są bezpośrednio współużytkowane między domenami aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="cbd27-109">Na przykład każda domena aplikacji ma własną kopię statyczne zmienne dla tych typów, a Konstruktor statyczny dla typu jest uruchamiany co najwyżej raz na domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="cbd27-110">Implementacje są bezpłatne zapewnienie specyficzne dla implementacji zasad i mechanizmów tworzenia i niszczenia domen aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="cbd27-111">***Uruchamianie aplikacji*** występuje, gdy środowisko wykonawcze wywołuje wyznaczonym metody, która jest określany jako punkt wejścia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="cbd27-112">Zawsze nosi nazwę tej metody punktu wejścia `Main`i może mieć jednej z następujących:</span><span class="sxs-lookup"><span data-stu-id="cbd27-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="cbd27-113">Jak widać, punkt wejścia opcjonalnie może zwrócić `int` wartość.</span><span class="sxs-lookup"><span data-stu-id="cbd27-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="cbd27-114">To zwraca wartość jest używana do zakończenia aplikacji ([zakończenia aplikacji](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="cbd27-115">Punkt wejścia opcjonalnie może mieć jeden formalny parametr.</span><span class="sxs-lookup"><span data-stu-id="cbd27-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="cbd27-116">Parametr może mieć dowolną nazwę, ale typ parametru musi być `string[]`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="cbd27-117">Jeśli parametr formalny jest obecny, środowisko wykonawcze tworzy i przekazuje `string[]` argument zawierająca argumenty wiersza polecenia, które zostały określone podczas uruchomienia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="cbd27-118">`string[]` Argument nigdy nie ma wartość null, ale może mieć długości zerowej, jeśli nie określono żadnych argumentów wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="cbd27-119">Od C# obsługuje metody przeciążenie, klasy lub struktury może zawierać wiele definicji niektóre metody, pod warunkiem każdy ma inny podpis.</span><span class="sxs-lookup"><span data-stu-id="cbd27-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="cbd27-120">Jednak w ramach jednego programu, nie klasy lub struktury może zawierać więcej niż jedną metodę o nazwie `Main` kwalifikuje się której definicja może być ona używana jako punkt wejścia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="cbd27-121">Inne przeciążone wersje `Main` są dozwolone, pod warunkiem mają więcej niż jeden parametr lub ich jedynym parametrem jest inny niż typ `string[]`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="cbd27-122">Aplikacja może składać się z wielu klas lub struktur.</span><span class="sxs-lookup"><span data-stu-id="cbd27-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="cbd27-123">Możliwe jest więcej niż jeden z tych klas lub struktur zawiera metodę o nazwie `Main` kwalifikuje się której definicja może być ona używana jako punkt wejścia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="cbd27-124">W takich przypadkach mechanizm zewnętrznych (takich jak opcja kompilatora wiersza polecenia) może służyć do wybierz jedną z następujących `Main` metod jako punkt wejścia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="cbd27-125">W języku C# każdej metody musi być zdefiniowany jako członek klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="cbd27-126">Zazwyczaj deklarowana dostępność metody ([zadeklarowana dostępność](basic-concepts.md#declared-accessibility)) metody jest określana przez modyfikatory dostępu ([modyfikatorach dostępu](classes.md#access-modifiers)) określona w jego deklaracji i podobnie deklarowana dostępność typu jest określany przez modyfikatory dostępu w jego deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="cbd27-127">Aby danej metody danego typu jako możliwy do wywołania muszą być dostępne zarówno typ, jak i element członkowski.</span><span class="sxs-lookup"><span data-stu-id="cbd27-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="cbd27-128">Jednak punkt wejścia aplikacji jest przypadkiem szczególnym.</span><span class="sxs-lookup"><span data-stu-id="cbd27-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="cbd27-129">Ściślej mówiąc środowisko wykonawcze mają dostęp do punktu wejścia aplikacji, niezależnie od jego deklarowana dostępność metody i niezależnie od tego, deklarowana dostępność metody jego otaczającego deklaracje typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="cbd27-130">Metody punktu wejścia aplikacji może nie być w deklaracji klasy ogólnej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="cbd27-131">Pod innymi względami metodach punktu wejścia zachowują się jak te, które nie są punkty wejścia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="cbd27-132">Kończenie działania aplikacji</span><span class="sxs-lookup"><span data-stu-id="cbd27-132">Application termination</span></span>

<span data-ttu-id="cbd27-133">***Kończenie działania aplikacji*** przekazuje sterowanie do środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="cbd27-134">Jeśli zwracany typ metody aplikacji ***punktu wejścia*** metodą jest `int`, wartość zwracana służy jako aplikacji ***kod stanu zakończenia***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="cbd27-135">Celem tego kodu jest do zezwalania na komunikację powodzenia lub niepowodzenia do środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="cbd27-136">Jeśli zwracany typ metody punktu wejścia jest `void`, osiągając prawy nawias klamrowy (`}`), który kończy metody lub wykonywania `return` instrukcję, która ma nie wyrażenie powoduje zakończenie kod stanu `0`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="cbd27-137">Przed zakończeniem aplikacji, wszystkie jego obiekty, które nie zostały jeszcze bezużyteczne destruktory są wywoływane, chyba że oczyszczania takie zostały pominięte (przez wywołanie metody biblioteki `GC.SuppressFinalize`, na przykład).</span><span class="sxs-lookup"><span data-stu-id="cbd27-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="cbd27-138">Deklaracje</span><span class="sxs-lookup"><span data-stu-id="cbd27-138">Declarations</span></span>

<span data-ttu-id="cbd27-139">Deklaracje w języku C# służącego Definiowanie elementów programu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="cbd27-140">C# programy są zorganizowane przy użyciu przestrzeni nazw ([przestrzenie nazw](namespaces.md)), który może zawierać typ deklaracje i deklaracji zagnieżdżonej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="cbd27-141">Wpisz deklaracje ([wpisz deklaracje](namespaces.md#type-declarations)) są używane do definiowania klas ([klasy](classes.md)), struktur ([struktury](structs.md)), interfejsy ([interfejsów](interfaces.md) ), Typy wyliczeniowe ([wyliczenia](enums.md)) i delegatów ([delegatów](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="cbd27-142">Rodzaje elementy członkowskie dozwolone w deklaracji typu są zależne od postaci deklaracji typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="cbd27-143">Na przykład deklaracje klas mogą zawierać deklaracje dla stałych ([stałe](classes.md#constants)), pola ([pola](classes.md#fields)), metody ([metody](classes.md#methods)), właściwości ([ Właściwości](classes.md#properties)), zdarzenia ([zdarzenia](classes.md#events)), indeksatorów ([indeksatory](classes.md#indexers)), operatory ([operatory](classes.md#operators)), wystąpienie konstruktory ([ Konstruktory wystąpień](classes.md#instance-constructors)), konstruktory statyczne ([konstruktorów statycznych](classes.md#static-constructors)), destruktory ([destruktory](classes.md#destructors)) i zagnieżdżone typy ([zagnieżdżone typy](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="cbd27-144">Deklaracja Określa nazwę w ***deklaracji przestrzeni*** do której należy deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="cbd27-145">Z wyjątkiem przeciążone elementy członkowskie ([podpisów i przeciążenie](basic-concepts.md#signatures-and-overloading)), jest to błąd czasu kompilacji, mieć co najmniej dwóch deklaracje, które wprowadzają składowych o tej samej nazwie w miejscu do deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="cbd27-146">Nigdy nie jest możliwe dla miejsca deklaracji w celu uwzględnienia różnych rodzajów elementów członkowskich o takiej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="cbd27-147">Na przykład miejsca deklaracja może nigdy nie zawierać pola i metody o tej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="cbd27-148">Istnieje kilka różnych typów miejsc do magazynowania deklaracji, zgodnie z opisem w następujących.</span><span class="sxs-lookup"><span data-stu-id="cbd27-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="cbd27-149">W ramach wszystkich plików źródłowych programu *namespace_member_declaration*s nie otaczający *namespace_declaration* są elementami członkowskimi miejsca jednej Scalonej deklaracji, nazywanego ***globalne deklaracja przestrzeni***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="cbd27-150">W ramach wszystkich plików źródłowych programu *namespace_member_declaration*s w ramach *namespace_declaration*s, który ma taką samą nazwę w pełni kwalifikowanych przestrzeni nazw są członkami jednej deklaracji połączone miejsca.</span><span class="sxs-lookup"><span data-stu-id="cbd27-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="cbd27-151">Każdej klasy, struktury lub interfejsu deklaracja tworzy nowe miejsce do deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="cbd27-152">Nazwy są wprowadzane do tego obszaru deklaracji za pośrednictwem *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, lub *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="cbd27-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="cbd27-153">Z wyjątkiem konstruktora wystąpienia przeciążona deklaracje i Konstruktor statyczny deklaracji klasy lub struktury nie mogą zawierać deklaracji elementu członkowskiego z taką samą nazwę jak klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="cbd27-154">Klasy, struktury lub interfejsu zezwala na deklarację przeciążonych metod i indeksatorów.</span><span class="sxs-lookup"><span data-stu-id="cbd27-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="cbd27-155">Ponadto klasy lub struktury pozwala na deklarację operatory i konstruktory wystąpień przeciążona.</span><span class="sxs-lookup"><span data-stu-id="cbd27-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="cbd27-156">Na przykład klasy, struktury lub interfejsu może zawierać wiele deklaracje metody o tej samej nazwie, pod warunkiem te deklaracje metody różnią się w ich podpisu ([podpisów i przeciążenie](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="cbd27-157">Należy pamiętać, że klasy bazowe nie przyczyniają się do obszaru deklaracji klasy i interfejsy podstawowe nie przyczyniają się do obszaru deklaracji interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="cbd27-158">W efekcie pochodne klasy lub interfejsu może zadeklarować członka o takiej samej nazwie jak dziedziczonego członka.</span><span class="sxs-lookup"><span data-stu-id="cbd27-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="cbd27-159">Członek taki jest nazywany ***Ukryj*** dziedziczonego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="cbd27-160">Każdy deklaracja delegata tworzy nowe miejsce do deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="cbd27-161">Nazwy są wprowadzane do tego obszaru deklaracji parametrów formalnych (*fixed_parameter*s i *parameter_array*s) i *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="cbd27-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="cbd27-162">Każda deklaracja wyliczenia tworzy nowe miejsce do deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="cbd27-163">Nazwy są wprowadzane do tego obszaru deklaracji za pośrednictwem *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="cbd27-164">Każdy deklaracji metody, deklaracja indeksatora, Deklaracja operatora, deklaracja konstruktora wystąpienia i funkcja anonimowa tworzy nowe miejsce deklaracji o nazwie ***deklaracji zmiennej lokalnej przestrzeni***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="cbd27-165">Nazwy są wprowadzane do tego obszaru deklaracji parametrów formalnych (*fixed_parameter*s i *parameter_array*s) i *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="cbd27-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="cbd27-166">Treści funkcji składowej lub funkcja anonimowa, jeśli istnieje, jest uważany za można zagnieździć w obrębie przestrzeni deklaracji zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="cbd27-167">Jest to błąd dla deklaracji zmiennej lokalnej i miejsca zagnieżdżonych deklaracji zmiennej lokalnej, aby zawierać elementy o takiej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="cbd27-168">W związku z tym w obrębie deklaracji zagnieżdżonej przestrzeni nie jest możliwe zadeklarować zmienną lub stałą o takiej samej nazwie jako zmiennej lokalnej lub stałą lokalną w otaczającej przestrzeni deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="cbd27-169">Istnieje możliwość dla dwóch spacji deklaracji ma zawierać elementy o takiej samej nazwie, tak długo, jak ani miejsca deklaracja zawiera drugi.</span><span class="sxs-lookup"><span data-stu-id="cbd27-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="cbd27-170">Każdego *bloku* lub *switch_block* , a także *dla*, *foreach* i *przy użyciu* instrukcja, tworzy deklaracji zmiennej lokalnej miejsca dla lokalnych stałe i zmienne lokalne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="cbd27-171">Nazwy są wprowadzane do tego obszaru deklaracji za pośrednictwem *local_variable_declaration*s i *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="cbd27-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="cbd27-172">Należy pamiętać, że bloki, które występują jako lub w treści funkcji składowej lub funkcja anonimowa są zagnieżdżone w obrębie przestrzeni deklaracji zmiennej lokalnej zgłoszonych przez te funkcje do swoich parametrów.</span><span class="sxs-lookup"><span data-stu-id="cbd27-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="cbd27-173">Ten sposób jest błędem np. metody przy użyciu zmiennej lokalnej i parametru o takiej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="cbd27-174">Każdy *bloku* lub *switch_block* tworzy miejsce na oddzielnych deklaracji etykiety.</span><span class="sxs-lookup"><span data-stu-id="cbd27-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="cbd27-175">Nazwy są wprowadzane do tego obszaru deklaracji za pośrednictwem *labeled_statement*s i nazw, które są wywoływane za pośrednictwem *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="cbd27-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="cbd27-176">***Etykiety deklaracji przestrzeni*** bloku zawiera wszelkich bloków zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="cbd27-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="cbd27-177">W związku z tym w ramach zagnieżdżony blok nie jest możliwe do deklarowania etykietę o takiej samej nazwie jako etykieta w otaczającym bloku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="cbd27-178">Ogólnie tekstową kolejność, w których nazwy są deklarowane jest bez znaczenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="cbd27-179">W szczególności tekstową kolejność nie jest istotne dla deklaracji i korzystania z przestrzeni nazw, stałe, metody, właściwości, zdarzenia, indeksatory, operatory, konstruktory wystąpień, destruktory, konstruktory statyczne i typów.</span><span class="sxs-lookup"><span data-stu-id="cbd27-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="cbd27-180">Deklaracja kolejność jest ważna w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="cbd27-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="cbd27-181">Kolejność deklaracji dla deklaracji pól i deklaracje zmiennych lokalnych określa kolejność wykonywania ich inicjatory (jeśli istnieje).</span><span class="sxs-lookup"><span data-stu-id="cbd27-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="cbd27-182">Muszą być zdefiniowane zmienne lokalne, zanim zostaną użyte ([zakresy](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="cbd27-183">Kolejności deklaracji dla deklaracji elementu członkowskiego wyliczenia ([typu wyliczeniowego](enums.md#enum-members)) ma znaczenie, gdy *constant_expression* wartości są pomijane.</span><span class="sxs-lookup"><span data-stu-id="cbd27-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="cbd27-184">Miejsce na deklarację przestrzeni nazw jest "Otwórz Zakończono", a dwie przestrzeni nazw deklaracje o takiej samej nazwie FQDN przyczyniają się do tej samej deklaracji przestrzeni.</span><span class="sxs-lookup"><span data-stu-id="cbd27-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="cbd27-185">Na przykład</span><span class="sxs-lookup"><span data-stu-id="cbd27-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="cbd27-186">dwie deklaracje przestrzeni nazw powyżej przyczyniają się do tej samej przestrzeni deklaracji, w tym przypadku deklarowania dwóch klas z w pełni kwalifikowane nazwy `Megacorp.Data.Customer` i `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="cbd27-187">Ponieważ dwie deklaracje przyczynić się do tej samej przestrzeni deklaracji, jego spowodowałaby błąd kompilacji w przypadku każdego zawartych w deklaracji klasy o takiej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="cbd27-188">Jak określono powyżej w deklaracji przestrzeni blok zawiera wszelkich bloków zagnieżdżonych.</span><span class="sxs-lookup"><span data-stu-id="cbd27-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="cbd27-189">W związku z tym, w poniższym przykładzie `F` i `G` metody powoduje błąd w czasie kompilacji, ponieważ nazwa `i` jest zadeklarowany w zewnętrznym bloku i nie można ponownie zadeklarować w bloku wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="cbd27-190">Jednak `H` i `I` metody są prawidłowe, ponieważ dwa `i`firmy są deklarowane w osobnych blokach-nested.</span><span class="sxs-lookup"><span data-stu-id="cbd27-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="cbd27-191">Elementy członkowskie</span><span class="sxs-lookup"><span data-stu-id="cbd27-191">Members</span></span>

<span data-ttu-id="cbd27-192">Obszary nazw i typy mają ***członków***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="cbd27-193">Elementy członkowskie jednostki są ogólnie dostępne w ramach kwalifikowana nazwa, która rozpoczyna się od odwołanie do jednostki, a następnie "`.`" token, a następnie według nazwy elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="cbd27-194">Elementy członkowskie typu albo są deklarowane w deklaracji typu lub ***dziedziczone*** z klasy bazowej tego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="cbd27-195">Jeśli typ dziedziczy z klasy bazowej, wszystkich elementów członkowskich klasy podstawowej, z wyjątkiem wystąpienia konstruktory, destruktory i konstruktorów statycznych stają się elementy członkowskie typu pochodnego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="cbd27-196">Deklarowaną dostępność składowej klasy bazowej nie kontroluje, czy element członkowski jest dziedziczony — dziedziczenie rozszerza się do wszystkich elementów członkowskich, którego nie ma konstruktora wystąpienia, statyczny Konstruktor lub destruktor.</span><span class="sxs-lookup"><span data-stu-id="cbd27-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="cbd27-197">Jednak dziedziczonego członka nie mogą być dostępne w typie pochodnym, albo z powodu jego deklarowana dostępność metody ([zadeklarowana dostępność](basic-concepts.md#declared-accessibility)) lub ponieważ jest on ukryty przez deklarację w typie ([ukrywanie przez dziedziczenie](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="cbd27-198">Elementy członkowskie Namespace</span><span class="sxs-lookup"><span data-stu-id="cbd27-198">Namespace members</span></span>

<span data-ttu-id="cbd27-199">Obszary nazw i typy, które mają bez otaczającej przestrzeni nazw są elementami członkowskimi ***globalnej przestrzeni nazw***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="cbd27-200">Odpowiada to bezpośrednio nazwy zadeklarowane w deklaracji globalnej przestrzeni.</span><span class="sxs-lookup"><span data-stu-id="cbd27-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="cbd27-201">Obszary nazw i typy zadeklarowane w przestrzeni nazw są elementami członkowskimi tej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="cbd27-202">Odpowiada to bezpośrednio nazwy zadeklarowane w obszarze deklaracji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="cbd27-203">Przestrzenie nazw nie ma ograniczeń dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="cbd27-204">Nie jest możliwe zadeklarować prywatny, chroniony lub wewnętrzny przestrzenie nazw i nazwy przestrzeni nazw są zawsze dostępne publicznie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="cbd27-205">Składowe struktury</span><span class="sxs-lookup"><span data-stu-id="cbd27-205">Struct members</span></span>

<span data-ttu-id="cbd27-206">Elementy członkowskie struktury są elementów członkowskich zadeklarowanych w strukturze i elementy członkowskie dziedziczone po bezpośredniej klasie bazowej struktury `System.ValueType` i pośredniej klasy bazowej `object`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="cbd27-207">Elementy członkowskie typu prostego odpowiadają bezpośrednio do elementów członkowskich struktury typ aliasowany przez typ prosty:</span><span class="sxs-lookup"><span data-stu-id="cbd27-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="cbd27-208">Elementy członkowskie `sbyte` należą do `System.SByte` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="cbd27-209">Elementy członkowskie `byte` należą do `System.Byte` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="cbd27-210">Elementy członkowskie `short` należą do `System.Int16` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="cbd27-211">Elementy członkowskie `ushort` należą do `System.UInt16` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="cbd27-212">Elementy członkowskie `int` należą do `System.Int32` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="cbd27-213">Elementy członkowskie `uint` należą do `System.UInt32` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="cbd27-214">Elementy członkowskie `long` należą do `System.Int64` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="cbd27-215">Elementy członkowskie `ulong` należą do `System.UInt64` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="cbd27-216">Elementy członkowskie `char` należą do `System.Char` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="cbd27-217">Elementy członkowskie `float` należą do `System.Single` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="cbd27-218">Elementy członkowskie `double` należą do `System.Double` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="cbd27-219">Elementy członkowskie `decimal` należą do `System.Decimal` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="cbd27-220">Elementy członkowskie `bool` należą do `System.Boolean` struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="cbd27-221">Elementy członkowskie wyliczenia</span><span class="sxs-lookup"><span data-stu-id="cbd27-221">Enumeration members</span></span>

<span data-ttu-id="cbd27-222">Elementy członkowskie wyliczenia są stałe zadeklarowane w wyliczeniu i elementy członkowskie dziedziczone po bezpośredniej klasie bazowej wyliczenia `System.Enum` i pośrednie klas bazowych `System.ValueType` i `object`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="cbd27-223">Elementy członkowskie klasy</span><span class="sxs-lookup"><span data-stu-id="cbd27-223">Class members</span></span>

<span data-ttu-id="cbd27-224">Elementy członkowskie klasy są elementów członkowskich zadeklarowanych w klasie i elementy członkowskie dziedziczone z klasy podstawowej (z wyjątkiem klasy `object` którego nie ma klasy bazowej).</span><span class="sxs-lookup"><span data-stu-id="cbd27-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="cbd27-225">Elementy członkowskie, dziedziczone z klasy bazowej zawierają, stałe, pola, metody, właściwości, zdarzenia, indeksatory, operatorów i typów klasy bazowej, ale nie konstruktory wystąpień, destruktory i konstruktory statyczne klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="cbd27-226">Klasa bazowa członkowie są dziedziczeni bez względu na ich dostępność.</span><span class="sxs-lookup"><span data-stu-id="cbd27-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="cbd27-227">Deklaracja klasy może zawierać deklaracje stałe, pola, metody, właściwości, zdarzenia, indeksatory, operatorów, konstruktory wystąpień, destruktory, konstruktory statyczne i typów.</span><span class="sxs-lookup"><span data-stu-id="cbd27-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="cbd27-228">Elementy członkowskie `object` i `string` odpowiadają bezpośrednio do elementów członkowskich typu klasy one aliasu:</span><span class="sxs-lookup"><span data-stu-id="cbd27-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="cbd27-229">Elementy członkowskie `object` należą do `System.Object` klasy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="cbd27-230">Elementy członkowskie `string` należą do `System.String` klasy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="cbd27-231">Elementy członkowskie interfejsu</span><span class="sxs-lookup"><span data-stu-id="cbd27-231">Interface members</span></span>

<span data-ttu-id="cbd27-232">Członkowie interfejsu są elementów członkowskich zadeklarowanych w interfejsie i wszystkie interfejsy podstawowe interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="cbd27-233">Elementy członkowskie w klasie `object` nie są ściśle rzecz biorąc, elementy członkowskie dowolnego interfejsu ([interfejsu członków](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="cbd27-234">Jednak elementy członkowskie w klasie `object` są dostępne za pośrednictwem wyszukać składowej w dowolny typ interfejsu ([wyszukanie członka](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="cbd27-235">Elementy członkowskie tablicy</span><span class="sxs-lookup"><span data-stu-id="cbd27-235">Array members</span></span>

<span data-ttu-id="cbd27-236">Elementy członkowskie tablicy są elementami członkowskimi, odziedziczoną z klasy `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="cbd27-237">Elementy członkowskie delegata</span><span class="sxs-lookup"><span data-stu-id="cbd27-237">Delegate members</span></span>

<span data-ttu-id="cbd27-238">Elementy członkowskie obiektu delegowanego są elementami członkowskimi, odziedziczoną z klasy `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="cbd27-239">Dostęp do elementu członkowskiego</span><span class="sxs-lookup"><span data-stu-id="cbd27-239">Member access</span></span>

<span data-ttu-id="cbd27-240">Deklaracje członków umożliwia kontrolę dostępu do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="cbd27-241">Ułatwienia dostępu elementu członkowskiego jest ustanawiane przez deklarowana dostępność metody ([zadeklarowana dostępność](basic-concepts.md#declared-accessibility)) elementu członkowskiego w połączeniu z ułatwieniami dostępu typu zawierającego ewentualne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="cbd27-242">Dostęp do określonego elementu członkowskiego jest dozwolony, element członkowski jest określane jako ***dostępny***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="cbd27-243">Z drugiej strony, dostęp do określonego elementu członkowskiego jest niedozwolona, element członkowski jest określane jako ***niedostępny***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="cbd27-244">Dostęp do elementu członkowskiego jest dozwolone, gdy tekstową lokalizacji, w którym odbywa się dostępu znajduje się w domenie ułatwień dostępu ([domeny dostępności](basic-concepts.md#accessibility-domains)) elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="cbd27-245">Deklarowana dostępność metody</span><span class="sxs-lookup"><span data-stu-id="cbd27-245">Declared accessibility</span></span>

<span data-ttu-id="cbd27-246">***Zadeklarowana dostępność*** członka może być jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="cbd27-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="cbd27-247">Publiczny, który jest wybierany przez dołączenie `public` modyfikatora w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="cbd27-248">Intuicyjne znaczenie `public` jest "nie jest ograniczony dostęp".</span><span class="sxs-lookup"><span data-stu-id="cbd27-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="cbd27-249">Chroniony, który jest zaznaczony, w tym `protected` modyfikatora w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="cbd27-250">Intuicyjne znaczenie `protected` "dostęp ograniczony do zawierający klasy lub typów pochodzi od klasy zawierającej".</span><span class="sxs-lookup"><span data-stu-id="cbd27-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="cbd27-251">Wewnętrzny, który jest wybierany przez dołączenie `internal` modyfikatora w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="cbd27-252">Intuicyjne znaczenie `internal` jest "dostęp ograniczony do tego programu".</span><span class="sxs-lookup"><span data-stu-id="cbd27-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="cbd27-253">Chronionych wewnętrznych (to znaczy chronionych i wewnętrznych), który jest zaznaczony, tym `protected` i `internal` modyfikatora w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="cbd27-254">Intuicyjne znaczenie `protected internal` jest "dostęp ograniczony do tego programu lub typy pochodzące z klasy zawierającej".</span><span class="sxs-lookup"><span data-stu-id="cbd27-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="cbd27-255">Prywatne, który jest wybierany przez dołączenie `private` modyfikatora w deklaracji elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="cbd27-256">Intuicyjne znaczenie `private` jest "dostęp ograniczony do typu zawierającego".</span><span class="sxs-lookup"><span data-stu-id="cbd27-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="cbd27-257">W zależności od kontekstu, w którym odbywa się deklaracji składowej umieścić, dozwolone są tylko niektóre typy deklarowana dostępność metody.</span><span class="sxs-lookup"><span data-stu-id="cbd27-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="cbd27-258">Ponadto po deklaracji elementu członkowskiego nie zawiera żadnych modyfikatory dostępu, kontekst, w którym odbywa się deklaracja określa domyślne zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="cbd27-259">Przestrzenie nazw niejawnie mają `public` zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="cbd27-260">Brak modyfikatorów dostępu są dozwolone w deklaracji przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="cbd27-261">Typy zadeklarowane w jednostkach kompilacji lub przestrzeni nazw mogą mieć `public` lub `internal` zadeklarowana dostępność i domyślnie `internal` zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="cbd27-262">Elementy członkowskie klasy można istnieje pięć rodzajów deklarowana dostępność metody i domyślnie `private` zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="cbd27-263">(Należy pamiętać, że typem zadeklarowane jako składowej klasy może być spowodowany pięć rodzajów deklarowana dostępność metody, natomiast typ zadeklarowane jako składowa klasy przestrzeni nazw może mieć tylko `public` lub `internal` zadeklarowana ułatwień dostępu.)</span><span class="sxs-lookup"><span data-stu-id="cbd27-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="cbd27-264">Składowe struktury mogą mieć `public`, `internal`, lub `private` zadeklarowana dostępność i domyślnie `private` zadeklarowany ułatwień dostępu, ponieważ struktury niejawnie są zamknięte.</span><span class="sxs-lookup"><span data-stu-id="cbd27-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="cbd27-265">Składowe struktury wprowadzone w strukturze (który nie jest dziedziczone przez tej struktury) nie może mieć `protected` lub `protected internal` zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="cbd27-266">(Należy pamiętać, że typem zadeklarowane jako składowa struktury mogą mieć `public`, `internal`, lub `private` zadeklarowana dostępność, natomiast typ zadeklarowane jako składowa klasy przestrzeni nazw może mieć tylko `public` lub `internal` zadeklarowana ułatwień dostępu.)</span><span class="sxs-lookup"><span data-stu-id="cbd27-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="cbd27-267">Elementy członkowskie interfejsu niejawnie ma `public` zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="cbd27-268">Brak modyfikatorów dostępu są dozwolone w deklaracji elementu członkowskiego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="cbd27-269">Elementy członkowskie wyliczenia niejawnie ma `public` zadeklarowana ułatwień dostępu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="cbd27-270">Brak modyfikatorów dostępu są dozwolone w deklaracji elementu członkowskiego wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="cbd27-271">Domen ułatwień dostępu</span><span class="sxs-lookup"><span data-stu-id="cbd27-271">Accessibility domains</span></span>

<span data-ttu-id="cbd27-272">***Domena dostępności*** elementu członkowskiego składa się z części (prawdopodobnie rozłączne) tekst programu, w którym jest dozwolony dostęp do elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="cbd27-273">W celu definiowania domena dostępności członka, członek jest nazywany ***najwyższego poziomu*** Jeśli nie jest zadeklarowany w ramach danego typu, a członek jest nazywany ***zagnieżdżonych*** Jeśli zostanie ona zadeklarowana w ramach innego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="cbd27-274">Ponadto ***program tekstu*** programu w języku jest zdefiniowana jako wszystkich programów tekst zawarty we wszystkich plikach źródłowych programu i tekstu programu o typie jest zdefiniowany jako wszystkich programów tekst zawarty w *type_declaration*s tego typu (oraz, ewentualnie typy, które są zagnieżdżone w obrębie typu).</span><span class="sxs-lookup"><span data-stu-id="cbd27-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="cbd27-275">Domena dostępności wstępnie zdefiniowany typ (takie jak `object`, `int`, lub `double`) jest nieograniczona.</span><span class="sxs-lookup"><span data-stu-id="cbd27-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="cbd27-276">Domena dostępności najwyższego poziomu niepowiązany typ `T` ([powiązane i wskazanych typów](types.md#bound-and-unbound-types)) zadeklarowanego w programie `P` jest zdefiniowana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="cbd27-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="cbd27-277">Jeśli deklarowana dostępność metody `T` jest `public`, domena dostępności `T` znajduje się tekst program `P` i dowolnego programu, który odwołuje się do `P`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="cbd27-278">Jeśli deklarowana dostępność metody `T` jest `internal`, domena dostępności `T` znajduje się tekst program `P`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="cbd27-279">Z tymi definicjami wynika, że domena dostępności typu niepowiązanego najwyższego poziomu jest zawsze co najmniej programu, który typ tekstu jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="cbd27-280">Domena dostępności do skonstruowanego typu `T<A1, ..., An>` jest część wspólną domeny dostępności niepowiązanych typu ogólnego `T` i domeny dostępności argumentów typu `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="cbd27-281">Domena dostępności członka zagnieżdżonego `M` zadeklarowane w typie `T` w programie `P` jest zdefiniowany następująco (biorąc pod uwagę, że `M` sam prawdopodobnie może być typem):</span><span class="sxs-lookup"><span data-stu-id="cbd27-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="cbd27-282">Jeśli deklarowana dostępność metody `M` jest `public`, domena dostępności `M` jest domena dostępności `T`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="cbd27-283">Jeśli deklarowana dostępność metody `M` jest `protected internal`systemowi `D` stanowią połączenie i tekstu programu `P` i tekstu programu o dowolnym typie pochodnych `T`, która jest zadeklarowana poza `P`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="cbd27-284">Domena dostępności `M` jest część wspólną domeny dostępności `T` z `D`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="cbd27-285">Jeśli deklarowana dostępność metody `M` jest `protected`systemowi `D` stanowią połączenie i tekstu programu `T` i tekstu programu o dowolnym typie pochodnych `T`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="cbd27-286">Domena dostępności `M` jest część wspólną domeny dostępności `T` z `D`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="cbd27-287">Jeśli deklarowana dostępność metody `M` jest `internal`, domena dostępności `M` jest część wspólną domeny dostępności `T` tekstu programu `P`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="cbd27-288">Jeśli deklarowana dostępność metody `M` jest `private`, domena dostępności `M` znajduje się tekst program `T`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="cbd27-289">Z tymi definicjami wynika, że domena dostępności członka zagnieżdżonego jest zawsze co najmniej tekstu programu o typie, w którym zadeklarowany jest element członkowski.</span><span class="sxs-lookup"><span data-stu-id="cbd27-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="cbd27-290">Ponadto wynika, że domena dostępności członka się nigdy nie więcej niż domena dostępności typu, w którym zadeklarowany jest element członkowski.</span><span class="sxs-lookup"><span data-stu-id="cbd27-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="cbd27-291">W sposób intuicyjny gdy typ lub element członkowski `M` jest dostępne, aby upewnić się, że taki dostęp jest dozwolony są oceniane następujące kroki:</span><span class="sxs-lookup"><span data-stu-id="cbd27-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="cbd27-292">Po pierwsze, jeśli `M` jest zadeklarowany w typie (w przeciwieństwie do jednostki kompilacji lub przestrzeni nazw), występuje błąd kompilacji, jeśli ten typ nie jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="cbd27-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="cbd27-293">Następnie, jeśli `M` jest `public`, dostęp jest dozwolony.</span><span class="sxs-lookup"><span data-stu-id="cbd27-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="cbd27-294">W przeciwnym razie, jeśli `M` jest `protected internal`, dostęp jest dozwolony, jeśli ma miejsce w programie, w którym `M` zadeklarowano, lub jeśli nastąpi to w ramach klasy pochodnej klasy, w którym `M` jest zadeklarowana i odbywa się za pośrednictwem pochodnej Typ klasy ([chronionego dostępu dla wystąpienia elementów członkowskich](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="cbd27-295">W przeciwnym razie, jeśli `M` jest `protected`, dostęp jest dozwolony, jeżeli wystąpi w ramach klasy, w której `M` zadeklarowano, lub jeśli nastąpi to w ramach klasy pochodnej klasy, w którym `M` jest zadeklarowana i odbywa się za pośrednictwem pochodnej Typ klasy ([chronionego dostępu dla wystąpienia elementów członkowskich](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="cbd27-296">W przeciwnym razie, jeśli `M` jest `internal`, dostęp jest dozwolony, jeśli ma miejsce w programie, w którym `M` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="cbd27-297">W przeciwnym razie, jeśli `M` jest `private`, dostęp jest dozwolony, jeżeli wystąpi w ramach typu, w którym `M` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="cbd27-298">W przeciwnym razie typu lub elementu członkowskiego jest niedostępny i występuje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="cbd27-299">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="cbd27-300">klasy i członkowie mają następujące domeny dostępności:</span><span class="sxs-lookup"><span data-stu-id="cbd27-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="cbd27-301">Domena dostępności `A` i `A.X` jest nieograniczona.</span><span class="sxs-lookup"><span data-stu-id="cbd27-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="cbd27-302">Domena dostępności `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, i `B.C.Y` to tekst programu, zawierającego programu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="cbd27-303">Domena dostępności `A.Z` znajduje się tekst program `A`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="cbd27-304">Domena dostępności `B.Z` i `B.D` znajduje się tekst program `B`, w tym i tekstu programu `B.C` i `B.D`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="cbd27-305">Domena dostępności `B.C.Z` znajduje się tekst program `B.C`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="cbd27-306">Domena dostępności `B.D.X` i `B.D.Y` znajduje się tekst program `B`, w tym i tekstu programu `B.C` i `B.D`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="cbd27-307">Domena dostępności `B.D.Z` znajduje się tekst program `B.D`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="cbd27-308">Tak jak pokazano w przykładzie, domena dostępności członka nigdy nie jest większa niż w przypadku typu zawierającego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="cbd27-309">Na przykład nawet jeśli wszystkie `X` członkowie mają publiczne deklarowana dostępność metody wszystkie elementy oprócz `A.X` domen ułatwień dostępu, które są ograniczone przez typ zawierający.</span><span class="sxs-lookup"><span data-stu-id="cbd27-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="cbd27-310">Zgodnie z opisem w [członków](basic-concepts.md#members), wszystkie elementy członkowskie klasy bazowej, chyba że dla wystąpienia konstruktorów, destruktorów i konstruktorów statycznych są dziedziczone przez typy pochodne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="cbd27-311">Dotyczy to nawet prywatnych składowych klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-311">This includes even private members of a base class.</span></span> <span data-ttu-id="cbd27-312">Jednakże domena dostępności członka prywatnych umożliwia stosowanie tylko tekstu programu, typu, w którym zadeklarowany jest element członkowski.</span><span class="sxs-lookup"><span data-stu-id="cbd27-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="cbd27-313">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="cbd27-314">`B` klasa dziedziczy prywatnego elementu członkowskiego `x` z `A` klasy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="cbd27-315">Ponieważ element członkowski jest prywatny, jest ona dostępna tylko w ramach *class_body* z `A`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="cbd27-316">W związku z tym, dostęp do `b.x` zakończy się pomyślnie w `A.F` metody, ale kończy się niepowodzeniem w `B.F` metody.</span><span class="sxs-lookup"><span data-stu-id="cbd27-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="cbd27-317">Chronionego dostępu do składowych wystąpienia</span><span class="sxs-lookup"><span data-stu-id="cbd27-317">Protected access for instance members</span></span>

<span data-ttu-id="cbd27-318">Gdy `protected` elementu członkowskiego wystąpienia odbywa się poza tekst programu, klasy, w której jest zadeklarowana, i kiedy `protected internal` elementu członkowskiego wystąpienia odbywa się poza i tekstu programu, w której jest zadeklarowana, dostępu musi odbywać się w ciągu deklaracji klasy, który pochodzi od klasy, w którym jest zdeklarowana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="cbd27-319">Ponadto dostęp jest wymagany do odbywać się za pośrednictwem wystąpienia tego typu klasy pochodnej lub typu klasy skonstruowany z niego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="cbd27-320">To ograniczenie zapobiega uzyskiwania dostępu do chronionych członków innych klas pochodnych, nawet wtedy, gdy elementy członkowskie są dziedziczone z klasy bazowej tego samego jednej klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="cbd27-321">Pozwól `B` jako klasa bazowa, która deklaruje element członkowski chronionego wystąpienia `M`i pozwól `D` być klasą pochodzącą z `B`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="cbd27-322">W ramach *class_body* z `D`, dostęp do `M` może mieć jedną z następujących form:</span><span class="sxs-lookup"><span data-stu-id="cbd27-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="cbd27-323">Niekwalifikowane *type_name* lub *primary_expression* formularza `M`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="cbd27-324">A *primary_expression* formularza `E.M`, podany typ `E` jest `T` lub klasą pochodną `T`, gdzie `T` jest typem klasy `D`, ani typem klasy zbudowany z `D`</span><span class="sxs-lookup"><span data-stu-id="cbd27-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="cbd27-325">A *primary_expression* formularza `base.M`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="cbd27-326">Oprócz poniższych metod dostępu do klasy pochodnej mogą uzyskiwać dostęp do konstruktora chronionego wystąpienia w klasie bazowej *constructor_initializer* ([inicjatory konstruktora](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="cbd27-327">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="cbd27-328">w ramach `A`, istnieje możliwość, aby uzyskać dostęp do `x` za pośrednictwem obu wystąpień `A` i `B`, ponieważ w obu przypadkach dostępu odbywa się za pośrednictwem wystąpienia `A` lub klasą pochodną `A`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="cbd27-329">Jednak w ramach `B`, nie jest możliwe, aby uzyskać dostęp do `x` za pośrednictwem wystąpienia `A`, ponieważ `A` nie pochodzi od `B`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="cbd27-330">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="cbd27-331">trzy przypisania do `x` są dozwolone, ponieważ wszystkie wykonane za pomocą wystąpienia typów klas skonstruowany z typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="cbd27-332">Ograniczenia ułatwień dostępu</span><span class="sxs-lookup"><span data-stu-id="cbd27-332">Accessibility constraints</span></span>

<span data-ttu-id="cbd27-333">Kilka konstrukcji w języku C# wymaga użycia typu jako ***co najmniej tak samo dostępna jak*** członka lub innego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="cbd27-334">Typ `T` jest określany jako co najmniej tak samo dostępna jak elementu członkowskiego lub typu `M` Jeśli domena dostępności `T` jest podzbiorem domena dostępności `M`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="cbd27-335">Innymi słowy `T` jest co najmniej tak samo dostępna jak `M` Jeśli `T` jest dostępny we wszystkich kontekstach, w którym `M` jest dostępny.</span><span class="sxs-lookup"><span data-stu-id="cbd27-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="cbd27-336">Istnieją następujące ograniczenia ułatwień dostępu:</span><span class="sxs-lookup"><span data-stu-id="cbd27-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="cbd27-337">Bezpośrednie klasy bazowej typu klasy musi być co najmniej tak samo dostępna jak samego typu klasy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="cbd27-338">Jawne interfejsy podstawowe typu interfejsu, musi być co najmniej tak samo dostępna jak samego typu interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="cbd27-339">Typ zwracany i typy parametrów typu delegowanego musi być co najmniej tak samo dostępna jak samego typu delegata.</span><span class="sxs-lookup"><span data-stu-id="cbd27-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="cbd27-340">Typ stałej musi być co najmniej tak samo dostępna jak stała się.</span><span class="sxs-lookup"><span data-stu-id="cbd27-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="cbd27-341">Typ pola musi być co najmniej tak samo dostępna jak samo pole.</span><span class="sxs-lookup"><span data-stu-id="cbd27-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="cbd27-342">Typ zwracany i typy parametrów metody muszą być co najmniej tak samo dostępna jak sama metoda.</span><span class="sxs-lookup"><span data-stu-id="cbd27-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="cbd27-343">Typ właściwości musi być co najmniej tak samo dostępna jak samej właściwości.</span><span class="sxs-lookup"><span data-stu-id="cbd27-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="cbd27-344">Typ zdarzenia musi być co najmniej tak samo dostępna jak samego zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="cbd27-345">Typ i parametrów typów indeksatora musi być co najmniej tak samo dostępna jak indeksatora, sam.</span><span class="sxs-lookup"><span data-stu-id="cbd27-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="cbd27-346">Typ zwracany i typy parametrów operatora musi być co najmniej tak samo dostępna jak operator sam.</span><span class="sxs-lookup"><span data-stu-id="cbd27-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="cbd27-347">Typy parametru konstruktora wystąpień musi być co najmniej tak samo dostępna jak sam Konstruktor wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="cbd27-348">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="cbd27-349">`B` klasy powoduje błąd kompilacji ponieważ `A` nie jest co najmniej tak samo dostępna jak `B`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="cbd27-350">Podobnie w przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="cbd27-351">`H` method in Class metoda `B` powoduje błąd w czasie kompilacji, ponieważ zwracany typ `A` nie jest co najmniej tak samo dostępna jak metoda.</span><span class="sxs-lookup"><span data-stu-id="cbd27-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="cbd27-352">Podpisy i przeciążenie</span><span class="sxs-lookup"><span data-stu-id="cbd27-352">Signatures and overloading</span></span>

<span data-ttu-id="cbd27-353">Metody, konstruktory wystąpień, indeksatorów i operatory charakteryzują się ich ***podpisy***:</span><span class="sxs-lookup"><span data-stu-id="cbd27-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="cbd27-354">Podpis metody zawiera nazwę metody, liczbę parametrów typu i typu i rodzaj (wartość, odwołanie lub danych wyjściowych) każdego z jego parametrów formalnych w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="cbd27-355">Do tych celów wszelkie parametr typu metody, która występuje w typie formalny parametr jest identyfikowany nie według jego nazwy, ale za pomocą jego numer porządkowy pozycji na liście argumentów typu metody.</span><span class="sxs-lookup"><span data-stu-id="cbd27-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="cbd27-356">Podpis metody specjalnie nie zawiera typ zwracany `params` modyfikator, który może być określona dla parametru najdalej z prawej strony ani ograniczenia parametru typu opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="cbd27-357">Podpis konstruktora wystąpień składa się z typu i rodzaj (wartość, odwołanie lub danych wyjściowych) każdego z jego parametrów formalnych w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="cbd27-358">Podpis konstruktora wystąpień specjalnie nie obejmuje `params` modyfikator, który może być określona dla parametru najdalej z prawej strony.</span><span class="sxs-lookup"><span data-stu-id="cbd27-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="cbd27-359">Podpis indeksatora składa się z typu każdego z jego parametrów formalnych w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="cbd27-360">Podpis indeksatora specjalnie nie zawiera typu elementu, ani obejmuje `params` modyfikator, który może być określona dla parametru najdalej z prawej strony.</span><span class="sxs-lookup"><span data-stu-id="cbd27-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="cbd27-361">Podpis operator składa się z nazwy operatora i typu każdego z jego parametrów formalnych w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="cbd27-362">Podpis operator specjalnie nie ma typ wyniku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="cbd27-363">Podpisy są włączenie mechanizmu ***przeciążenie*** elementów członkowskich klas, struktur i interfejsów:</span><span class="sxs-lookup"><span data-stu-id="cbd27-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="cbd27-364">Pozwala na przeciążenie metody, klasy, struktury lub interfejsu, aby zadeklarować, że wiele metod o tej samej nazwie, pod warunkiem ich podpisy są unikatowe w obrębie tej klasy, struktury lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="cbd27-365">Przeciążenia konstruktorów wystąpienia pozwala na klasie lub strukturze, aby zadeklarować wiele konstruktorów wystąpienia, pod warunkiem ich podpisy są unikatowe w obrębie tej klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="cbd27-366">Przeciążenia indeksatorów pozwala klasy, struktury lub interfejsu, aby zadeklarować wiele indeksatorów, pod warunkiem ich podpisy są unikatowe w obrębie tej klasy, struktury lub interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="cbd27-367">Przeciążanie operatorów pozwala klasie lub strukturze, aby zadeklarować, że wiele operatorów o takiej samej nazwie, pod warunkiem ich podpisy są unikatowe w obrębie tej klasy lub struktury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="cbd27-368">Mimo że `out` i `ref` Modyfikatory parametrów są uważane za część podpisu, elementów członkowskich zadeklarowanych w jednym typie nie mogą się różnić w podpisie wyłącznie przez `ref` i `out`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="cbd27-369">Występuje błąd kompilacji, jeśli dwa elementy członkowskie są zadeklarowane w ten sam typ z podpisami, które mogą być identyczny, jeśli wszystkie parametry w obu metod za pomocą `out` Modyfikatory zostały zmienione na `ref` modyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="cbd27-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="cbd27-370">Do innych celów zgodnych podpisu (np. ukrycie lub zastępowanie) `ref` i `out` są uważane za część podpisu i nie pasują do siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="cbd27-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="cbd27-371">(To ograniczenie jest umożliwienie C# programy, które ma zostać poddany translacji łatwe do uruchamiania na Common Language Infrastructure (CLI), która nie zapewnia sposób definiowania metod, które różnią się jedynie w `ref` i `out`.)</span><span class="sxs-lookup"><span data-stu-id="cbd27-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="cbd27-372">Na potrzeby podpisów, typy `object` i `dynamic` są traktowane jako takie same.</span><span class="sxs-lookup"><span data-stu-id="cbd27-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="cbd27-373">Elementów członkowskich zadeklarowanych w jednym typie może w związku z tym nie różnią się w podpisie wyłącznie przez `object` i `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="cbd27-374">Poniższy przykład przedstawia zestaw deklaracje metody przeciążonej, wraz z ich podpisy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="cbd27-375">Należy pamiętać, że wszelkie `ref` i `out` Modyfikatory parametrów ([parametry metody](classes.md#method-parameters)) są dostępne w ramach sygnatury.</span><span class="sxs-lookup"><span data-stu-id="cbd27-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="cbd27-376">W efekcie `F(int)` i `F(ref int)` unikatowy podpisów.</span><span class="sxs-lookup"><span data-stu-id="cbd27-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="cbd27-377">Jednak `F(ref int)` i `F(out int)` nie można zadeklarować w obrębie tego samego interfejsu, ponieważ ich podpisy różnią się jedynie przez `ref` i `out`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="cbd27-378">Warto również zauważyć, że zwracany typ i `params` modyfikator nie są częścią podpis, więc nie jest możliwe przeciążenia wyłącznie na podstawie na zwracany typ lub włączenia lub wyłączenia `params` modyfikator.</span><span class="sxs-lookup"><span data-stu-id="cbd27-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="cbd27-379">Działa w taki sposób, deklaracje metody `F(int)` i `F(params string[])` określonych powyżej wynik na liście błędów kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="cbd27-380">Zakresy</span><span class="sxs-lookup"><span data-stu-id="cbd27-380">Scopes</span></span>

<span data-ttu-id="cbd27-381">***Zakres*** nazwy jest region tekst programu, w którym jest możliwe do odwoływania się do jednostki zadeklarowanej przez nazwę bez kwalifikowania nazwy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="cbd27-382">Zakresy mogą być ***zagnieżdżonych***, i w zakresie wewnętrznym może ponownie zadeklarować znaczenie nazwę z zakresu zewnętrznego (nie powoduje jednak usunięcia ograniczeń nałożonych przez [deklaracje](basic-concepts.md#declarations) , w ramach zagnieżdżony blok nie jest możliwe do deklarowania zmiennej lokalnej o tej samej nazwie jako zmiennej lokalnej w otaczającym bloku).</span><span class="sxs-lookup"><span data-stu-id="cbd27-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="cbd27-383">Nazwie w zewnętrznym zakresie są określane jako ***ukryte*** w regionie program tekstu objętych w zakresie wewnętrznym, a dostęp do zewnętrznej nazwy jest możliwe tylko kwalifikując nazwę.</span><span class="sxs-lookup"><span data-stu-id="cbd27-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="cbd27-384">Zakres elementu członkowskiego przestrzeni nazw zadeklarowana przez *namespace_member_declaration* ([członków Namespace](namespaces.md#namespace-members)) z nie otaczającej *namespace_declaration* jest całego programu tekst.</span><span class="sxs-lookup"><span data-stu-id="cbd27-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="cbd27-385">Zakres elementu członkowskiego przestrzeni nazw zadeklarowana przez *namespace_member_declaration* w ramach *namespace_declaration* którego w pełni kwalifikowana nazwa to `N` jest *namespace_body*  z każdego *namespace_declaration* którego w pełni kwalifikowana nazwa to `N` lub zaczynające się od `N`, a następnie kropkę.</span><span class="sxs-lookup"><span data-stu-id="cbd27-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="cbd27-386">Zakres nazwa zdefiniowana przez *extern_alias_directive* rozciąga *using_directive*s, *global_attributes* i *namespace_member_ Deklaracja*s jego kompilacji natychmiast zawierający treść jednostki lub przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="cbd27-387">*Extern_alias_directive* nie wpływa na żadnych nowych elementów członkowskich do obszaru bazowego deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="cbd27-388">Innymi słowy *extern_alias_directive* nie jest przechodnia, ale raczej dotyczy tylko kompilacji zespołu lub przestrzeni nazw treści w której występuje.</span><span class="sxs-lookup"><span data-stu-id="cbd27-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="cbd27-389">Zakres nazwę zdefiniowany lub importowane przez *using_directive* ([dyrektywy Using](namespaces.md#using-directives)) rozciąga *namespace_member_declaration*s  *compilation_unit* lub *namespace_body* w którym *using_directive* występuje.</span><span class="sxs-lookup"><span data-stu-id="cbd27-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="cbd27-390">A *using_directive* może udostępnić zero lub więcej nazw przestrzeni nazw, typu lub elementu członkowskiego w ramach określonego *compilation_unit* lub *namespace_body*, ale nie Współtworzenie żadnych nowych elementów członkowskich do obszaru bazowego deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="cbd27-391">Innymi słowy *using_directive* nie jest przechodnia, ale raczej ma wpływ tylko na *compilation_unit* lub *namespace_body* , w której występuje.</span><span class="sxs-lookup"><span data-stu-id="cbd27-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="cbd27-392">Zakres parametr typu zadeklarowana przez *type_parameter_list* na *class_declaration* ([klasy deklaracje](classes.md#class-declarations)) jest *class_base*, *type_parameter_constraints_clause*s, i *class_body* tego *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="cbd27-393">Zakres parametr typu zadeklarowana przez *type_parameter_list* na *struct_declaration* ([deklaracji struktury](structs.md#struct-declarations)) jest *struct_interfaces* , *type_parameter_constraints_clause*s, i *struct_body* tego *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="cbd27-394">Zakres parametr typu zadeklarowana przez *type_parameter_list* na *interface_declaration* ([interfejsu deklaracje](interfaces.md#interface-declarations)) jest *interface_base* , *type_parameter_constraints_clause*s, i *interface_body* tego *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="cbd27-395">Zakres parametr typu zadeklarowana przez *type_parameter_list* na *delegate_declaration* ([delegować deklaracje](delegates.md#delegate-declarations)) jest *Typ_wyniku*, *formal_parameter_list*, i *type_parameter_constraints_clause*s, który *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="cbd27-396">Zakres elementu członkowskiego zadeklarowana przez *class_member_declaration* ([klasy treści](classes.md#class-body)) jest *class_body* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="cbd27-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="cbd27-397">Ponadto rozszerza zakres składowej klasy *class_body* tych pochodne klasy, które znajdują się w domenie ułatwień dostępu ([domeny dostępności](basic-concepts.md#accessibility-domains)) elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="cbd27-398">Zakres elementu członkowskiego zadeklarowana przez *struct_member_declaration* ([składowe struktury](structs.md#struct-members)) jest *struct_body* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="cbd27-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="cbd27-399">Zakres elementu członkowskiego zadeklarowana przez *enum_member_declaration* ([typu wyliczeniowego](enums.md#enum-members)) jest *enum_body* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="cbd27-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="cbd27-400">Zakres parametr zadeklarowanych w *method_declaration* ([metody](classes.md#methods)) jest *method_body* tego *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="cbd27-401">Zakres parametr zadeklarowanych w *indexer_declaration* ([indeksatory](classes.md#indexers)) jest *accessor_declarations* tego *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="cbd27-402">Zakres parametr zadeklarowanych w *operator_declaration* ([operatory](classes.md#operators)) jest *bloku* tego *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="cbd27-403">Zakres parametr zadeklarowanych w *constructor_declaration* ([wystąpienia konstruktory](classes.md#instance-constructors)) jest *constructor_initializer* i *bloku* tego *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="cbd27-404">Zakres parametr zadeklarowanych w *lambda_expression* ([wyrażenia funkcji anonimowych](expressions.md#anonymous-function-expressions)) jest *anonymous_function_body* tego *lambda_ wyrażenie*</span><span class="sxs-lookup"><span data-stu-id="cbd27-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="cbd27-405">Zakres parametr zadeklarowanych w *anonymous_method_expression* ([wyrażenia funkcji anonimowych](expressions.md#anonymous-function-expressions)) jest *bloku* tego *anonymous_method _expression*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="cbd27-406">Zakres etykiety zadeklarowanych w *labeled_statement* ([etykietą instrukcji](statements.md#labeled-statements)) jest *bloku* , w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="cbd27-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="cbd27-407">Zakres zmiennej lokalnej zadeklarowanej w *local_variable_declaration* ([deklaracje zmiennych lokalnych](statements.md#local-variable-declarations)) bloku, w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="cbd27-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="cbd27-408">Zakres zmiennej lokalnej zadeklarowanej w *switch_block* z `switch` — instrukcja ([instrukcji switch](statements.md#the-switch-statement)) jest *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="cbd27-409">Zakres zmiennej lokalnej zadeklarowanej w *for_initializer* z `for` — instrukcja ([dla instrukcji](statements.md#the-for-statement)) jest *for_initializer*,  *for_condition*, *for_iterator*i ograniczonego *instrukcji* z `for` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="cbd27-410">Zakres stała lokalna zadeklarowana w *local_constant_declaration* ([deklaracji stałej lokalnej](statements.md#local-constant-declarations)) bloku, w którym występuje deklaracja.</span><span class="sxs-lookup"><span data-stu-id="cbd27-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="cbd27-411">Jest to błąd czasu kompilacji do odwoływania się do stała lokalna w stanie tekstową poprzedzającym jego *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="cbd27-412">Zakres zmiennej zadeklarowany jako część *foreach_statement*, *using_statement*, *lock_statement* lub *query_expression* jest określany przez rozszerzenie danego konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="cbd27-413">W zakresie przestrzeni nazw, klasy, struktury lub wyliczenia elementu członkowskiego jest możliwe do odwoływania się do elementu członkowskiego w stanie tekstową poprzedzająca deklaracja elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="cbd27-414">Na przykład</span><span class="sxs-lookup"><span data-stu-id="cbd27-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="cbd27-415">W tym miejscu jest on prawidłowy dla `F` do odwoływania się do `i` przed jej zadeklarowaniem.</span><span class="sxs-lookup"><span data-stu-id="cbd27-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="cbd27-416">W zakresie zmiennej lokalnej jest błąd w czasie kompilacji do odwoływania się do zmiennej lokalnej w stanie tekstową poprzedzającym *local_variable_declarator* zmiennej lokalnej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="cbd27-417">Na przykład</span><span class="sxs-lookup"><span data-stu-id="cbd27-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="cbd27-418">W `F` powyższej metody, pierwsze przypisanie do `i` specjalnie odwołuje się do pola, zadeklarowany w zewnętrznym zakresie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="cbd27-419">Przeciwnie odwołuje się do zmiennej lokalnej, i powoduje błąd kompilacji, ponieważ w formie tekstu wcześniejsza deklaracja zmiennej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="cbd27-420">W `G` metody, użycie `j` w inicjatorze dla deklaracji `j` jest prawidłowy, ponieważ użycie nie poprzedza *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="cbd27-421">W `H` metody, kolejne *local_variable_declarator* poprawnie odwołuje się do zmienna lokalna zadeklarowana we wcześniejszej *local_variable_declarator* w tej samej  *local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="cbd27-422">Wyznaczanie zakresu reguły dla zmiennych lokalnych są przeznaczone do zagwarantowania, że znaczenie nazwa używana w kontekście wyrażenia jest zawsze taki sam sposób, w bloku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="cbd27-423">Gdyby zakres zmiennej lokalnej, aby rozszerzyć tylko z jego deklarację na końcu bloku w powyższym przykładzie pierwsze przypisanie przypisywanej zmienną instance i przypisywanej drugie przypisanie do zmiennej lokalnej, prawdopodobnie prowadzących do błędy kompilacji, gdyby nowszej, aby zmieniać wprowadza instrukcje w bloku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="cbd27-424">Znaczenie nazwy w bloku mogą się różnić w zależności od kontekstu, w której nazwa jest używana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="cbd27-425">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="cbd27-426">Nazwa `A` jest używany w kontekście wyrażenia do odwoływania się do zmiennej lokalnej `A` w kontekście typu do odwoływania się do klasy `A`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="cbd27-427">Ukrywanie nazw</span><span class="sxs-lookup"><span data-stu-id="cbd27-427">Name hiding</span></span>

<span data-ttu-id="cbd27-428">Zakres jednostki zwykle obejmuje więcej tekstu programu niż miejsce deklaracji jednostki.</span><span class="sxs-lookup"><span data-stu-id="cbd27-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="cbd27-429">W szczególności zakres jednostki może zawierać deklaracje, które wprowadzają nowe spacje deklaracji zawierający jednostkę o takiej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="cbd27-430">Takie deklaracje spowodować, że oryginalna jednostka stać się ***ukryte***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="cbd27-431">Z drugiej strony, jednostki jest nazywany ***widoczne*** kiedy nie jest ukryty.</span><span class="sxs-lookup"><span data-stu-id="cbd27-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="cbd27-432">Ukrywanie nazw występuje, gdy zakresy nakładają się na siebie przez zagnieżdżanie i kiedy zakresy nakładają się poprzez dziedziczenie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="cbd27-433">Cech dwóch rodzajów ukrywanie są opisane w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="cbd27-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="cbd27-434">Ukrywanie poprzez zagnieżdżanie</span><span class="sxs-lookup"><span data-stu-id="cbd27-434">Hiding through nesting</span></span>

<span data-ttu-id="cbd27-435">Ukrywanie nazw poprzez zagnieżdżenia może wystąpić w wyniku zagnieżdżenia przestrzeni nazw lub typów w przestrzeni nazw, w wyniku zagnieżdżanie typów w obrębie klasy lub struktury, a parametr i deklaracje zmiennych lokalnych w wyniku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="cbd27-436">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="cbd27-437">w ramach `F` metody, zmienną instance `i` jest ukryta przez zmienną lokalną `i`, ale w ramach `G` metody `i` nadal odwołuje się do zmiennej wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="cbd27-438">Nazwa w zakresie wewnętrznym ukrywa nazwę w zakresie zewnętrznym, powoduje ukrycie wszystkich wystąpień przeciążona o takiej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="cbd27-439">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="cbd27-440">wywołanie `F(1)` wywołuje `F` zadeklarowanych w `Inner` ponieważ wszystkie wystąpienia zewnętrzne `F` są ukryte przez wewnętrzny deklaracji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="cbd27-441">Z tego samego powodu wywołanie `F("Hello")` powoduje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="cbd27-442">Ukrywanie poprzez dziedziczenie</span><span class="sxs-lookup"><span data-stu-id="cbd27-442">Hiding through inheritance</span></span>

<span data-ttu-id="cbd27-443">Ukrywanie nazw poprzez dziedziczenie występuje, gdy klasy lub struktury ponownie zadeklarować nazwy, które były dziedziczone z klasy bazowej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="cbd27-444">Tego rodzaju ukrywaniem nazwy ma jedną z następujących form:</span><span class="sxs-lookup"><span data-stu-id="cbd27-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="cbd27-445">Stała, pola, właściwości, zdarzenia lub typ wprowadzony w klasie lub strukturze ukrywa wszystkie składowych klasy bazowej o takiej samej nazwie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="cbd27-446">Metoda wprowadzona w klasie lub strukturze ukrywa wszystkich członków klasy podstawowej-metoda o takiej samej nazwie, a wszystkie metody klasy podstawowej, z tym samym podpisie (Nazwa metody i liczba parametrów, Modyfikatory i typy).</span><span class="sxs-lookup"><span data-stu-id="cbd27-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="cbd27-447">Indeksator wprowadzony w klasie lub strukturze ukrywa wszystkie indeksatory klas podstawowych, z tym samym podpisie (liczba parametrów i typy).</span><span class="sxs-lookup"><span data-stu-id="cbd27-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="cbd27-448">Zasady dotyczące deklaracje operatora ([operatory](classes.md#operators)) uniemożliwia dla klasy pochodnej do deklarowania operatora z tym samym podpisie jako operator w klasie bazowej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="cbd27-449">W związku z tym operatory nigdy nie ukrywaj siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="cbd27-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="cbd27-450">Sprzecznie ukrywanie nazw z zakresu zewnętrznego, ukrywanie dostępna nazwa z zakresu dziedziczone powoduje, że ostrzeżenie zgłoszenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="cbd27-451">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="cbd27-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="cbd27-452">Deklaracja `F` w `Derived` powoduje, że ostrzeżenie zgłoszenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="cbd27-453">Ukrywanie odziedziczonych nazwa specjalnie nie jest błąd, ponieważ, mogłoby spowodować nieprawidłowe ewolucji osobnych klas bazowych.</span><span class="sxs-lookup"><span data-stu-id="cbd27-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="cbd27-454">Na przykład powyżej sytuacji mogą pochodzić ponieważ późniejszą wersję `Base` wprowadzone `F` metodę, która nie był obecny we wcześniejszej wersji tej klasy.</span><span class="sxs-lookup"><span data-stu-id="cbd27-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="cbd27-455">Powyżej sytuacji był błąd, następnie wszelkie zmiany wprowadzone do klasy bazowej w bibliotece klas oddzielnie wersjonowanych mogą potencjalnie powodować klasy pochodne staną się nieprawidłowe.</span><span class="sxs-lookup"><span data-stu-id="cbd27-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="cbd27-456">Ostrzeżenie spowodowane poprzez ukrywanie odziedziczonych nazwy mogą zostać usunięte za pośrednictwem `new` modyfikator:</span><span class="sxs-lookup"><span data-stu-id="cbd27-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="cbd27-457">`new` Modyfikator wskazuje, że `F` w `Derived` "nowy" i że w rzeczywistości jest przeznaczony do ukrywania odziedziczonej składowej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="cbd27-458">Deklaracja nowej składowej ukrywa dziedziczonego członka tylko w zakresie nowego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="cbd27-459">W przykładzie powyżej deklaracji `F` w `Derived` ukrywa `F` , został odziedziczony z `Base`, ale od nowej `F` w `Derived` ma dostęp do prywatnych, jego zakres nie obejmuje `MoreDerived` .</span><span class="sxs-lookup"><span data-stu-id="cbd27-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="cbd27-460">W związku z tym, wywołanie `F()` w `MoreDerived.G` jest prawidłowa i wywoła `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="cbd27-461">Nazw Namespace i typ</span><span class="sxs-lookup"><span data-stu-id="cbd27-461">Namespace and type names</span></span>

<span data-ttu-id="cbd27-462">Wiele kontekstów w C# wymagają programu *namespace_name* lub *type_name* należy określić.</span><span class="sxs-lookup"><span data-stu-id="cbd27-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="cbd27-463">A *namespace_name* jest *namespace_or_type_name* odwołujący się do przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="cbd27-464">Następujące rozwiązania, jak opisano poniżej, *namespace_or_type_name* z *namespace_name* musi odwoływać się do przestrzeni nazw, lub w przeciwnym razie wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="cbd27-465">Bez argumentów typu ([argumentów typu](types.md#type-arguments)) mogą być obecne w *namespace_name* (tylko typy mogą mieć argumentów typu).</span><span class="sxs-lookup"><span data-stu-id="cbd27-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="cbd27-466">A *type_name* jest *namespace_or_type_name* odwołujący się do typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="cbd27-467">Następujące rozwiązania, jak opisano poniżej, *namespace_or_type_name* z *type_name* musi odwoływać się do typu, lub w przeciwnym razie wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="cbd27-468">Jeśli *namespace_or_type_name* jest kwalifikowana alias składowej jego znaczenie jest zgodnie z opisem w [kwalifikatory alias Namespace](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="cbd27-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="cbd27-469">W przeciwnym razie *namespace_or_type_name* ma jedną z czterech form:</span><span class="sxs-lookup"><span data-stu-id="cbd27-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="cbd27-470">gdzie `I` jest pojedynczy identyfikator `N` jest *namespace_or_type_name* i `<A1, ..., Ak>` to opcjonalna *type_argument_list*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="cbd27-471">Gdy nie *type_argument_list* jest określony, należy wziąć pod uwagę `k` zero.</span><span class="sxs-lookup"><span data-stu-id="cbd27-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="cbd27-472">Znaczenie *namespace_or_type_name* jest określany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="cbd27-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="cbd27-473">Jeśli *namespace_or_type_name* ma postać `I` lub w postaci `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="cbd27-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="cbd27-474">Jeśli `K` jest równa zero i *namespace_or_type_name* pojawia się w obrębie deklaracji metody ogólnej ([metody](classes.md#methods)) i jeśli deklaracja zawiera parametr typu ([typu Parametry](classes.md#type-parameters)) o nazwie `I`, a następnie *namespace_or_type_name* odwołuje się do tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="cbd27-475">W przeciwnym razie, jeśli *namespace_or_type_name* pojawia się w deklaracji typu, a następnie dla każdego typu wystąpienia `T` ([typu wystąpienia](classes.md#the-instance-type)), począwszy od typu wystąpienia tego typu Deklaracja i kontynuowanie przy użyciu typu wystąpienia każdej otaczającej deklaracji klasy lub struktury (jeśli istnieje):</span><span class="sxs-lookup"><span data-stu-id="cbd27-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="cbd27-476">Jeśli `K` to zero, a deklaracja `T` obejmuje parametru typu o nazwie `I`, a następnie *namespace_or_type_name* odwołuje się do tego parametru typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="cbd27-477">W przeciwnym razie, jeśli *namespace_or_type_name* pojawia się w treści deklaracji typu i `T` lub dowolny z jej typów podstawowych zawiera zagnieżdżony typ dostępny o nazwie `I` i `K`  parametry typu, a następnie *namespace_or_type_name* odwołuje się do tego typu skonstruowany przy użyciu argumentów danego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="cbd27-478">Jeśli istnieje więcej niż jeden taki typ, zostanie wybrany typem zadeklarowanym w ramach typu bardziej pochodnego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="cbd27-479">Należy pamiętać, że członkowie-type (stałe, pola, metody, właściwości, indeksatory, operatory, konstruktory wystąpień, destruktory i konstruktorów statycznych) i elementów członkowskich typu z różną liczbę parametrów typu są ignorowane podczas określania znaczenie *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="cbd27-480">Jeśli poprzednie kroki powiodły się następnie dla każdej przestrzeni nazw `N`, począwszy od przestrzeni nazw, w którym *namespace_or_type_name* problem wystąpi, kontynuując każdego otaczającej przestrzeni nazw (jeśli istnieje), a kończąc Globalna przestrzeń nazw, poniższe kroki są oceniane, dopóki nie znajduje się jednostka:</span><span class="sxs-lookup"><span data-stu-id="cbd27-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="cbd27-481">Jeśli `K` jest równa zero i `I` jest nazwą przestrzeni nazw w `N`, następnie:</span><span class="sxs-lookup"><span data-stu-id="cbd27-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="cbd27-482">Jeśli lokalizacja gdzie *namespace_or_type_name* występuje jest ujęta w deklarację przestrzeni nazw dla `N` i zawiera deklarację przestrzeni nazw *extern_alias_directive* lub *using_alias_directive* który kojarzy nazwę `I` z przestrzeni nazw lub typ, a następnie *namespace_or_type_name* jest niejednoznaczny i występuje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="cbd27-483">W przeciwnym razie *namespace_or_type_name* odwołuje się do przestrzeni nazw o nazwie `I` w `N`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="cbd27-484">W przeciwnym razie, jeśli `N` zawiera dostępny typ o nazwie `I` i `K`  parametry typu, następnie:</span><span class="sxs-lookup"><span data-stu-id="cbd27-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="cbd27-485">Jeśli `K` to zero i lokalizacja gdzie *namespace_or_type_name* występuje jest ujęta w deklarację przestrzeni nazw dla `N` i zawiera deklarację przestrzeni nazw *extern_alias_directive*  lub *using_alias_directive* który kojarzy nazwę `I` z przestrzeni nazw lub typ, a następnie *namespace_or_type_name* jest niejednoznaczne i w czasie kompilacji występuje błąd.</span><span class="sxs-lookup"><span data-stu-id="cbd27-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="cbd27-486">W przeciwnym razie *namespace_or_type_name* odwołuje się do typu skonstruowany przy użyciu argumentów danego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="cbd27-487">W przeciwnym razie, jeśli lokalizacja gdzie *namespace_or_type_name* występuje jest ujęta w deklarację przestrzeni nazw dla `N`:</span><span class="sxs-lookup"><span data-stu-id="cbd27-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="cbd27-488">Jeśli `K` jest równa zero i zawiera deklarację przestrzeni nazw *extern_alias_directive* lub *using_alias_directive* który kojarzy nazwę `I` z zaimportowaną przestrzenią nazw lub Typ, a następnie *namespace_or_type_name* odwołuje się do tej przestrzeni nazw lub typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="cbd27-489">W przeciwnym razie, jeśli deklaracji przestrzeni nazw i typ zaimportowany przez *using_namespace_directive*s i *using_alias_directive*s deklarację przestrzeni nazw zawierać dokładnie jeden typ dostępne o nazwie `I` i `K`  parametry typu, a następnie *namespace_or_type_name* odwołuje się do tego typu skonstruowany przy użyciu argumentów danego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="cbd27-490">W przeciwnym razie, jeśli deklaracji przestrzeni nazw i typ zaimportowany przez *using_namespace_directive*s i *using_alias_directive*s deklaracji przestrzeni nazw zawiera więcej niż jeden dostępny typ o nazwie `I` i `K`  parametry typu, a następnie *namespace_or_type_name* jest niejednoznaczny i występuje błąd.</span><span class="sxs-lookup"><span data-stu-id="cbd27-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="cbd27-491">W przeciwnym razie *namespace_or_type_name* jest niezdefiniowana, i występuje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="cbd27-492">W przeciwnym razie *namespace_or_type_name* ma postać `N.I` lub w postaci `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="cbd27-493">`N` najpierw zostanie rozwiązany jak *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="cbd27-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="cbd27-494">Jeśli rozdzielczość `N` zakończy się niepowodzeniem, wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="cbd27-495">W przeciwnym razie `N.I` lub `N.I<A1, ..., Ak>` zostanie rozwiązany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="cbd27-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="cbd27-496">Jeśli `K` jest równa zero i `N` odwołuje się do przestrzeni nazw i `N` zawiera zagnieżdżone przestrzenie nazw o nazwie `I`, a następnie *namespace_or_type_name* odwołuje się do tego zagnieżdżone przestrzenie nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="cbd27-497">W przeciwnym razie, jeśli `N` odwołuje się do przestrzeni nazw i `N` zawiera dostępny typ o nazwie `I` i `K`  parametry typu, a następnie *namespace_or_type_name* odwołuje się do tego typu jest zbudowany z argumentami danego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="cbd27-498">W przeciwnym razie, jeśli `N` odwołuje się do (prawdopodobnie skonstruowany) typu klasy lub struktury i `N` lub dowolny z jej klas bazowych zawiera zagnieżdżony typ dostępny o nazwie `I` i `K`  wpisz parametry, a następnie *namespace_or_type_name* odwołuje się do tego typu skonstruowany przy użyciu argumentów danego typu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="cbd27-499">Jeśli istnieje więcej niż jeden taki typ, zostanie wybrany typem zadeklarowanym w ramach typu bardziej pochodnego.</span><span class="sxs-lookup"><span data-stu-id="cbd27-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="cbd27-500">Należy pamiętać, że jeśli znaczenie `N.I` określa się jako część obsługi klasy podstawowej specyfikacji `N` następnie bezpośrednie klasy bazowej `N` jest uważany za obiektu ([klas bazowych](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="cbd27-501">W przeciwnym razie `N.I` jest nieprawidłową *namespace_or_type_name*, i występuje błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="cbd27-502">A *namespace_or_type_name* może odwoływać się do klasy statycznej ([klas statycznych](classes.md#static-classes)) tylko wtedy, gdy</span><span class="sxs-lookup"><span data-stu-id="cbd27-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="cbd27-503">*Namespace_or_type_name* jest `T` w *namespace_or_type_name* formularza `T.I`, lub</span><span class="sxs-lookup"><span data-stu-id="cbd27-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="cbd27-504">*Namespace_or_type_name* jest `T` w *typeof_expression* ([listy argumentów](expressions.md#argument-lists)1) w postaci `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="cbd27-505">W pełni kwalifikowane nazwy</span><span class="sxs-lookup"><span data-stu-id="cbd27-505">Fully qualified names</span></span>

<span data-ttu-id="cbd27-506">Każdy obszar nazw i typ ma ***w pełni kwalifikowana nazwa***, który jednoznacznie identyfikuje przestrzeni nazw lub typu oraz wszystkich innych.</span><span class="sxs-lookup"><span data-stu-id="cbd27-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="cbd27-507">W pełni kwalifikowaną nazwę przestrzeni nazw lub typ `N` jest określany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="cbd27-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="cbd27-508">Jeśli `N` jest elementem członkowskim globalnej przestrzeni nazw, jego w pełni kwalifikowana nazwa jest `N`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="cbd27-509">W przeciwnym razie jest jego w pełni kwalifikowana nazwa `S.N`, gdzie `S` jest w pełni kwalifikowaną nazwę przestrzeni nazw lub typ, w którym `N` jest zadeklarowana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="cbd27-510">Innymi słowy, w pełni kwalifikowana nazwa `N` jest pełną ścieżką hierarchiczne identyfikatorów, które mogą prowadzić do `N`, poczynając od globalnej przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="cbd27-511">Ponieważ każdy członek przestrzeń nazw lub typ musi mieć unikatową nazwę, jest zgodna z w pełni kwalifikowaną nazwę przestrzeni nazw lub typ jest zawsze unikatowa.</span><span class="sxs-lookup"><span data-stu-id="cbd27-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="cbd27-512">W poniższym przykładzie pokazano kilka deklaracji przestrzeni nazw i typ wraz z ich skojarzone w pełni kwalifikowanych nazw.</span><span class="sxs-lookup"><span data-stu-id="cbd27-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="cbd27-513">Automatyczne zarządzanie pamięcią</span><span class="sxs-lookup"><span data-stu-id="cbd27-513">Automatic memory management</span></span>

<span data-ttu-id="cbd27-514">C# stosuje automatyczne zarządzanie pamięcią, która ułatwia deweloperom z ręcznie przydzielanie i zwalnianie pamięci zajmowane przez obiekty.</span><span class="sxs-lookup"><span data-stu-id="cbd27-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="cbd27-515">Zasady zarządzania pamięcią automatyczną są implementowane przez ***modułu zbierającego elementy bezużyteczne***.</span><span class="sxs-lookup"><span data-stu-id="cbd27-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="cbd27-516">Obiekt cyklu życia zarządzania pamięci jest następująca:</span><span class="sxs-lookup"><span data-stu-id="cbd27-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="cbd27-517">Po utworzeniu obiektu pamięć została przydzielona dla niego, Konstruktor jest uruchamiany i obiekt uznaje się na żywo.</span><span class="sxs-lookup"><span data-stu-id="cbd27-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="cbd27-518">Jeśli obiekt lub dowolnej jego części bez nie są dostępne przez wszystkie możliwe kontynuacji wykonywanie, innym niż działanie destruktory obiektu uznaje się już w użyciu i staje się kwalifikuje się do zniszczenia.</span><span class="sxs-lookup"><span data-stu-id="cbd27-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="cbd27-519">Kompilator języka C# i wyrzucanie elementów bezużytecznych może wybrać do analizowania kodu w celu określenia, która odwołuje się do obiektu może być używane w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="cbd27-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="cbd27-520">Na przykład jeśli zmienna lokalna, która znajduje się w zakresie jest tylko istniejące odwołanie do obiektu, ale tej zmiennej lokalnej nigdy nie jest określany w wszystkie możliwe kontynuacji wykonywanie z bieżącego wykonywania punkt w procedurze, wyrzucanie elementów bezużytecznych może (ale nie jest musieli) traktować obiektu jako nie jest już używana.</span><span class="sxs-lookup"><span data-stu-id="cbd27-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="cbd27-521">Po kwalifikuje się do zniszczenia obiektu w pewnym później nieokreślony czas destruktor ([destruktory](classes.md#destructors)) (jeśli istnieje) dla obiektu jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="cbd27-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="cbd27-522">W normalnych warunkach destruktor obiektu jest uruchamiany tylko raz, chociaż interfejsy API specyficzne dla implementacji może zezwolić na zastąpienie tego zachowania.</span><span class="sxs-lookup"><span data-stu-id="cbd27-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="cbd27-523">Po jego uruchomieniu destruktora dla obiektu, jeżeli tego obiektu lub dowolnej jego części bez nie może uzyskać dostępu do żadnych możliwych kontynuacja wykonania, w tym uruchamianie destruktory, obiekt jest uznawany za niedostępne i obiekt kwalifikuje się do kolekcji.</span><span class="sxs-lookup"><span data-stu-id="cbd27-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="cbd27-524">Na koniec w czasie po obiekcie kwalifikuje się do kolekcji, moduł zbierający elementy bezużyteczne zwalnia pamięć skojarzonej z tym obiektem.</span><span class="sxs-lookup"><span data-stu-id="cbd27-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="cbd27-525">Moduł odśmiecania pamięci przechowuje informacje na temat użycia obiektu i używa tych informacji do decyzje dotyczące pamięci zarządzania, takich jak miejsca w pamięci, aby zlokalizować nowo utworzonego obiektu, gdy przenosić obiekt, a gdy obiekt nie jest już używana lub jest niedostępny.</span><span class="sxs-lookup"><span data-stu-id="cbd27-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="cbd27-526">Podobnie jak inne języki założono moduł wyrzucania elementów bezużytecznych C# jest zaprojektowana tak, wyrzucanie elementów bezużytecznych może wdrożyć szerokiej gamy zasad zarządzania pamięci.</span><span class="sxs-lookup"><span data-stu-id="cbd27-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="cbd27-527">Na przykład C# nie wymaga uruchomić destruktorów lub zebrane obiekty tak szybko, jak jest uprawniony do lub że destruktory być uruchamiane w określonej kolejności lub na żadnym z wątków.</span><span class="sxs-lookup"><span data-stu-id="cbd27-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="cbd27-528">Zachowanie modułu odśmiecania pamięci mogą być kontrolowane w pewnym stopniu, za pomocą metod statycznych w klasie `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="cbd27-529">Ta klasa służy do żądania kolekcji nastąpi usunięcie przez destruktory można działać (lub nie działać) i tak dalej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="cbd27-530">Ponieważ moduł odśmiecania pamięci jest dozwolona szerokiego szerokości przy podejmowaniu decyzji podczas zbierania obiektów i uruchomić destruktory, odpowiadające implementacja może powodować danych wyjściowych, który różni się od wyświetlanych przez następujący kod.</span><span class="sxs-lookup"><span data-stu-id="cbd27-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="cbd27-531">Uruchamianie programu</span><span class="sxs-lookup"><span data-stu-id="cbd27-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="cbd27-532">tworzy wystąpienie klasy `A` i wystąpienia klasy `B`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="cbd27-533">Te obiekty kwalifikować się do wyrzucania elementów bezużytecznych po zmiennej `b` jest przypisywana wartość `null`, ponieważ po tym czasie nie ma możliwości każdy kod napisany przez użytkownika do nich dostęp.</span><span class="sxs-lookup"><span data-stu-id="cbd27-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="cbd27-534">Dane wyjściowe mogą być albo</span><span class="sxs-lookup"><span data-stu-id="cbd27-534">The output could be either</span></span>
```
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="cbd27-535">lub</span><span class="sxs-lookup"><span data-stu-id="cbd27-535">or</span></span>
```
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="cbd27-536">ponieważ język nakłada nie ograniczeń w kolejności, w których obiekty są bezużyteczne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="cbd27-537">W przypadku subtelne rozróżnienia między "kwalifikuje się do zniszczenia" i "kwalifikuje się do kolekcji" może być istotne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="cbd27-538">Na przykład</span><span class="sxs-lookup"><span data-stu-id="cbd27-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="cbd27-539">W programie powyżej, jeśli moduł zbierający elementy bezużyteczne zdecydował się uruchomić destruktor `A` przed destruktor `B`, a następnie może być danych wyjściowych tego programu:</span><span class="sxs-lookup"><span data-stu-id="cbd27-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="cbd27-540">Należy zauważyć, że wystąpienie programu `A` nie był używany i `A`firmy destruktor został uruchomiony, jest nadal możliwe dla metod `A` (w tym przypadku `F`) do wywoływania z innego destruktora.</span><span class="sxs-lookup"><span data-stu-id="cbd27-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="cbd27-541">Należy również zauważyć, że uruchomiona destruktora może spowodować, że obiekt, do znów można używać z linii głównej programu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="cbd27-542">W tym przypadku uruchamianie `B`przez destruktora spowodowała wystąpienie `A` który został wcześniej nieużywany zanim staną się dostępne z odwołania na żywo `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="cbd27-543">Po wywołaniu `WaitForPendingFinalizers`, wystąpienie `B` kwalifikuje się do kolekcji, ale wystąpienie `A` nie jest dostępna, ze względu na odwołanie `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="cbd27-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="cbd27-544">Aby uniknąć nieporozumień i nieoczekiwane zachowanie, zazwyczaj jest dobrym pomysłem destruktory wykonać tylko czyszczenie danych przechowywanych w polach tego obiektu, a nie wykonać żadnych innych akcji na obiekty lub pola statyczne.</span><span class="sxs-lookup"><span data-stu-id="cbd27-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="cbd27-545">Alternatywa dla użycia destruktory jest umożliwienie klasa implementuje `System.IDisposable` interfejsu.</span><span class="sxs-lookup"><span data-stu-id="cbd27-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="cbd27-546">Dzięki temu klientowi określenie, kiedy należy zwolnić zasoby obiektu, zwykle, uzyskując dostęp do obiektu jako zasób w obiekcie `using` — instrukcja ([za pomocą instrukcji](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="cbd27-547">Kolejność wykonywania</span><span class="sxs-lookup"><span data-stu-id="cbd27-547">Execution order</span></span>

<span data-ttu-id="cbd27-548">Wykonanie programu w języku C# działa w taki sposób, że efekty uboczne każdego wątku wykonywania są zachowywane w punktach krytycznych wykonań.</span><span class="sxs-lookup"><span data-stu-id="cbd27-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="cbd27-549">A ***efekt uboczny*** jest zdefiniowany jako odczyt lub zapis pola nietrwałego, zapis do zmiennej typu nieulotnego, zapis do zewnętrznego zasobu, a następnie Zgłaszanie wyjątku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="cbd27-550">Punkty wykonywania krytycznych, w których kolejność tych efekty uboczne muszą być chronione są odwołaniami do pola nietrwałego ([pola nietrwałego](classes.md#volatile-fields)), `lock` instrukcji ([instrukcję lock](statements.md#the-lock-statement)), i Tworzenie wątku i zakończenie.</span><span class="sxs-lookup"><span data-stu-id="cbd27-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="cbd27-551">Środowisko wykonawcze jest bezpłatna zmienić kolejność wykonywania programu w języku C#, z zastrzeżeniem następujące ograniczenia:</span><span class="sxs-lookup"><span data-stu-id="cbd27-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="cbd27-552">Zależność dane są zachowywane w obrębie wykonanie wątku.</span><span class="sxs-lookup"><span data-stu-id="cbd27-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="cbd27-553">Oznacza to, że wartość każdej zmiennej jest obliczana tak, jakby wszystkie instrukcje w wątku zostały wykonane w porządku program oryginalnej.</span><span class="sxs-lookup"><span data-stu-id="cbd27-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="cbd27-554">Inicjowanie kolejności, zasady są zachowywane ([inicjowania pola](classes.md#field-initialization) i [zmiennej inicjatory](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="cbd27-555">Kolejność efekty uboczne są zachowywane względem volatile odczytów i zapisów ([pola nietrwałego](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="cbd27-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="cbd27-556">Ponadto środowisko wykonawcze nie należy ocenić częścią wyrażenia, czy można ustalić, czy wartość tego wyrażenia nie jest używany i nie wymagane efekty uboczne są tworzone, (wraz ze wszystkimi spowodowane przez wywołanie metody lub uzyskiwania dostępu do pola nietrwałego).</span><span class="sxs-lookup"><span data-stu-id="cbd27-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="cbd27-557">Podczas wykonywania programu zostało przerwane przez zdarzenie asynchroniczne (np. wyjątek zgłoszony przez inny wątek), nie ma żadnej gwarancji czy dostrzegalnych efekty uboczne są widoczne w oryginalnym porządku program.</span><span class="sxs-lookup"><span data-stu-id="cbd27-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
