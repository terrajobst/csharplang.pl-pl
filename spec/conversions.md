---
ms.openlocfilehash: 4d6d28a3127bc701867afe157aa5496377a06f69
ms.sourcegitcommit: 63d276488c9770a565fd787020783ffc1d2af9d6
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 12/05/2019
ms.locfileid: "74868007"
---
# <a name="conversions"></a><span data-ttu-id="a29c7-101">Konwersje</span><span class="sxs-lookup"><span data-stu-id="a29c7-101">Conversions</span></span>

<span data-ttu-id="a29c7-102">***Konwersja*** umożliwia przetraktowanie wyrażenia jako elementu określonego typu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="a29c7-103">Konwersja może spowodować, że wyrażenie danego typu ma być traktowane jako mające inny typ lub może spowodować wyrażenie bez typu, aby uzyskać typ.</span><span class="sxs-lookup"><span data-stu-id="a29c7-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="a29c7-104">Konwersje mogą być ***niejawne*** lub ***jawne***, a to określa, czy jest wymagane jawne rzutowanie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="a29c7-105">Na przykład konwersja z typu `int` na typ `long` jest niejawna, dlatego wyrażenia typu `int` mogą być niejawnie traktowane jako `long`typu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="a29c7-106">Odwrotna konwersja z typu `long` do typu `int`, jest jawna i dlatego wymagane jest jawne rzutowanie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="a29c7-107">Niektóre konwersje są definiowane przez język.</span><span class="sxs-lookup"><span data-stu-id="a29c7-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="a29c7-108">Programy mogą także definiować własne konwersje ([konwersje zdefiniowane przez użytkownika](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="a29c7-109">Konwersje niejawne</span><span class="sxs-lookup"><span data-stu-id="a29c7-109">Implicit conversions</span></span>

<span data-ttu-id="a29c7-110">Następujące konwersje są klasyfikowane jako konwersje niejawne:</span><span class="sxs-lookup"><span data-stu-id="a29c7-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="a29c7-111">Konwersje tożsamości</span><span class="sxs-lookup"><span data-stu-id="a29c7-111">Identity conversions</span></span>
*  <span data-ttu-id="a29c7-112">Niejawne konwersje liczbowe</span><span class="sxs-lookup"><span data-stu-id="a29c7-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="a29c7-113">Niejawne konwersje wyliczenia</span><span class="sxs-lookup"><span data-stu-id="a29c7-113">Implicit enumeration conversions</span></span>
*  <span data-ttu-id="a29c7-114">Niejawne konwersje ciągu interpolowanego</span><span class="sxs-lookup"><span data-stu-id="a29c7-114">Implicit interpolated string conversions</span></span>
*  <span data-ttu-id="a29c7-115">Niejawne konwersje dopuszczające wartość null</span><span class="sxs-lookup"><span data-stu-id="a29c7-115">Implicit nullable conversions</span></span>
*  <span data-ttu-id="a29c7-116">Konwersje literałów null</span><span class="sxs-lookup"><span data-stu-id="a29c7-116">Null literal conversions</span></span>
*  <span data-ttu-id="a29c7-117">Niejawne konwersje odwołań</span><span class="sxs-lookup"><span data-stu-id="a29c7-117">Implicit reference conversions</span></span>
*  <span data-ttu-id="a29c7-118">Konwersje z opakowania</span><span class="sxs-lookup"><span data-stu-id="a29c7-118">Boxing conversions</span></span>
*  <span data-ttu-id="a29c7-119">Niejawne konwersje dynamiczne</span><span class="sxs-lookup"><span data-stu-id="a29c7-119">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="a29c7-120">Niejawne konwersje wyrażeń stałych</span><span class="sxs-lookup"><span data-stu-id="a29c7-120">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="a29c7-121">Konwersje niejawne zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-121">User-defined implicit conversions</span></span>
*  <span data-ttu-id="a29c7-122">Konwersje funkcji anonimowych</span><span class="sxs-lookup"><span data-stu-id="a29c7-122">Anonymous function conversions</span></span>
*  <span data-ttu-id="a29c7-123">Konwersje grup metod</span><span class="sxs-lookup"><span data-stu-id="a29c7-123">Method group conversions</span></span>

<span data-ttu-id="a29c7-124">Konwersje niejawne mogą odbywać się w różnych sytuacjach, w tym wywołaniach elementów członkowskich funkcji ([Sprawdzanie czasu kompilacji dynamicznego rozpoznawania przeciążenia](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), wyrażenia rzutowania ([wyrażenia rzutowania](expressions.md#cast-expressions)) i przypisania ([Operatory przypisywania](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-124">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="a29c7-125">Wstępnie zdefiniowane konwersje niejawne zawsze kończą się powodzeniem i nigdy nie powodują zgłaszania wyjątków.</span><span class="sxs-lookup"><span data-stu-id="a29c7-125">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="a29c7-126">Odpowiednio zaprojektowane zdefiniowane przez użytkownika Konwersje niejawne powinny również mieć te cechy.</span><span class="sxs-lookup"><span data-stu-id="a29c7-126">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="a29c7-127">Na potrzeby konwersji typy `object` i `dynamic` są uważane za równoważne.</span><span class="sxs-lookup"><span data-stu-id="a29c7-127">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="a29c7-128">Jednak konwersje dynamiczne ([niejawne konwersje dynamiczne](conversions.md#implicit-dynamic-conversions) i [jawne konwersje dynamiczne](conversions.md#explicit-dynamic-conversions)) mają zastosowanie tylko do wyrażeń typu `dynamic` ([Typ dynamiczny](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-128">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="a29c7-129">Konwersja tożsamości</span><span class="sxs-lookup"><span data-stu-id="a29c7-129">Identity conversion</span></span>

<span data-ttu-id="a29c7-130">Konwersja tożsamości jest konwertowana z dowolnego typu na ten sam typ.</span><span class="sxs-lookup"><span data-stu-id="a29c7-130">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="a29c7-131">Ta konwersja istnieje w taki sposób, aby jednostka, która już ma wymagany typ, mogła zostać poddana konwersji na ten typ.</span><span class="sxs-lookup"><span data-stu-id="a29c7-131">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="a29c7-132">Ponieważ `object` i `dynamic` są uważane za równoważne, istnieje konwersja tożsamości między `object` i `dynamic`i między tworzonymi typami, które są takie same podczas zastępowania wszystkich wystąpień `dynamic` z `object`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-132">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="a29c7-133">Niejawne konwersje liczbowe</span><span class="sxs-lookup"><span data-stu-id="a29c7-133">Implicit numeric conversions</span></span>

<span data-ttu-id="a29c7-134">Niejawne konwersje liczbowe są następujące:</span><span class="sxs-lookup"><span data-stu-id="a29c7-134">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="a29c7-135">Z `sbyte` do `short`, `int`, `long`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-135">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-136">Z `byte` do `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-136">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-137">Z `short` do `int`, `long`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-137">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-138">Z `ushort` do `int`, `uint`, `long`, `ulong`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-138">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-139">Od `int` do `long`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-139">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-140">Z `uint` do `long`, `ulong`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-140">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-141">Od `long` do `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-141">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-142">Od `ulong` do `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-142">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-143">Z `char` do `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-143">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-144">Z `float` `double`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-144">From `float` to `double`.</span></span>

<span data-ttu-id="a29c7-145">Konwersje z `int`, `uint`, `long`lub `ulong` do `float` oraz od `long` lub `ulong` do `double` mogą spowodować utratę precyzji, ale nigdy nie spowoduje utraty wielkości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-145">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="a29c7-146">Inne niejawne konwersje numeryczne nigdy nie tracą żadnych informacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-146">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="a29c7-147">Brak niejawnych konwersji do typu `char`, dlatego wartości innych typów całkowitych nie są automatycznie konwertowane na typ `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-147">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="a29c7-148">Niejawne konwersje wyliczenia</span><span class="sxs-lookup"><span data-stu-id="a29c7-148">Implicit enumeration conversions</span></span>

<span data-ttu-id="a29c7-149">Niejawna konwersja Wyliczenie zezwala na konwersję *decimal_integer_literal* `0` na dowolną *enum_type* i *nullable_type* , których typem podstawowym jest *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-149">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="a29c7-150">W tym drugim przypadku konwersja jest oceniana przez przekonwertowanie na bazowe *enum_type* i Zawijanie wyniku ([Typy dopuszczające wartość null](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-150">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="a29c7-151">Niejawne konwersje ciągu interpolowanego</span><span class="sxs-lookup"><span data-stu-id="a29c7-151">Implicit interpolated string conversions</span></span>

<span data-ttu-id="a29c7-152">Niejawna konwersja ciągu interpolowanego zezwala na konwersję *interpolated_string_expression* ([ciąg interpolowany](expressions.md#interpolated-strings)) na `System.IFormattable` lub `System.FormattableString` (który implementuje `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="a29c7-152">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="a29c7-153">Gdy ta konwersja jest stosowana, wartość ciągu nie jest złożona z ciągu interpolowanego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-153">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="a29c7-154">Zamiast tego tworzone jest wystąpienie `System.FormattableString`, jak dokładniej opisane w [ciągach interpolowanych](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="a29c7-154">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="a29c7-155">Niejawne konwersje dopuszczające wartość null</span><span class="sxs-lookup"><span data-stu-id="a29c7-155">Implicit nullable conversions</span></span>

<span data-ttu-id="a29c7-156">Wstępnie zdefiniowane konwersje niejawne, które działają na typach wartości, które nie dopuszczają wartości null, mogą również być używane z dopuszczaniem wartości null dla tych typów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-156">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="a29c7-157">Dla każdej wstępnie zdefiniowanej tożsamości niejawnej i konwersji liczbowych, które konwertują z typu wartości niedopuszczających wartości null `S` do `T`typu wartości niedopuszczających wartości null, istnieją następujące niejawne konwersje dopuszczające wartość null:</span><span class="sxs-lookup"><span data-stu-id="a29c7-157">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="a29c7-158">Niejawna konwersja z `S?` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-158">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="a29c7-159">Niejawna konwersja z `S` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-159">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="a29c7-160">Obliczanie niejawnej konwersji wartości null na podstawie bazowej konwersji z `S` na `T` postępuje w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a29c7-160">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="a29c7-161">Jeśli konwersja dopuszcza wartość null z `S?` do `T?`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-161">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="a29c7-162">Jeśli wartością źródłową jest null (`HasValue` właściwość ma wartość false), wynik jest wartością null typu `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-162">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="a29c7-163">W przeciwnym razie konwersja jest oceniana jako odpakowanie od `S?` do `S`, a po niej bazowa konwersja z `S` do `T`, po którym następuje Zawijanie ([Typy dopuszczające wartości null](types.md#nullable-types)) od `T` do `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-163">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="a29c7-164">Jeśli konwersja do wartości null jest z `S` do `T?`, konwersja jest szacowana jako bazowa konwersja z `S` do `T`, a po nim otoka z `T` `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-164">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="a29c7-165">Konwersje literałów null</span><span class="sxs-lookup"><span data-stu-id="a29c7-165">Null literal conversions</span></span>

<span data-ttu-id="a29c7-166">Niejawna konwersja istnieje w literale `null` do dowolnych typów dopuszczających wartość null.</span><span class="sxs-lookup"><span data-stu-id="a29c7-166">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="a29c7-167">Ta konwersja generuje wartość null ([Typy Nullable](types.md#nullable-types)) danego typu dopuszczającego wartości null.</span><span class="sxs-lookup"><span data-stu-id="a29c7-167">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="a29c7-168">Niejawne konwersje odwołań</span><span class="sxs-lookup"><span data-stu-id="a29c7-168">Implicit reference conversions</span></span>

<span data-ttu-id="a29c7-169">Konwersje niejawnych odwołań są następujące:</span><span class="sxs-lookup"><span data-stu-id="a29c7-169">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="a29c7-170">Z dowolnych *reference_type* do `object` i `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-170">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="a29c7-171">Z dowolnych `S` *class_type* do wszystkich *class_type* `T`dostarczone `S` pochodzą z `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-171">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="a29c7-172">Z dowolnego *class_typeu* `S` do dowolnego *INTERFACE_TYPE* `T`podano `S` implementuje `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-172">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="a29c7-173">Z dowolnych `S` *INTERFACE_TYPE* do wszystkich *interface_type* `T`dostarczone `S` pochodzą z `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-173">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="a29c7-174">Z *array_type* `S` z typem elementu `SE` do *array_type* `T` z typem elementu `TE`, pod warunkiem spełnione są wszystkie z następujących warunków:</span><span class="sxs-lookup"><span data-stu-id="a29c7-174">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="a29c7-175">`S` i `T` różnią się tylko w typie elementu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-175">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="a29c7-176">Innymi słowy, `S` i `T` mają taką samą liczbę wymiarów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-176">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="a29c7-177">Zarówno `SE`, jak i `TE` są *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="a29c7-177">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="a29c7-178">W `SE` do `TE`istnieje niejawna konwersja odwołania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-178">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="a29c7-179">Z dowolnego *array_type* do `System.Array` i interfejsów, które implementuje.</span><span class="sxs-lookup"><span data-stu-id="a29c7-179">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="a29c7-180">Z jednowymiarowego typu tablicy `S[]` do `System.Collections.Generic.IList<T>` i jego interfejsów podstawowych, pod warunkiem, że istnieje niejawna tożsamość lub konwersja odwołań z `S` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-180">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="a29c7-181">Z dowolnego *delegate_type* do `System.Delegate` i interfejsów, które implementuje.</span><span class="sxs-lookup"><span data-stu-id="a29c7-181">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="a29c7-182">Z literału null do dowolnego *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-182">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="a29c7-183">Z dowolnych *reference_type* do *reference_type* `T`, jeśli ma niejawną tożsamość lub konwersję odwołania do *reference_type* `T0` i `T0` ma konwersję tożsamości na `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-183">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="a29c7-184">Z dowolnego *reference_type* do interfejsu lub typu delegata `T`, jeśli ma niejawną tożsamość lub konwersję odniesienia do interfejsu lub typu delegata `T0` a `T0` jest konwersją wariancji ([Konwersja wariancji](interfaces.md#variance-conversion)) na `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-184">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="a29c7-185">Niejawne konwersje obejmujące parametry typu, które są znane jako typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="a29c7-185">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="a29c7-186">Zobacz [niejawne konwersje dotyczące parametrów typu](conversions.md#implicit-conversions-involving-type-parameters) , aby uzyskać więcej informacji na temat niejawnych konwersji obejmujących parametry typu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-186">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="a29c7-187">Konwersje niejawnych odwołań są tymi konwersjami między *reference_type*s, które mogą być sprawdzone, aby zawsze kończyły się powodzeniem, dlatego nie wymagają kontroli w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-187">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="a29c7-188">Konwersje odwołań, niejawne lub jawne, nigdy nie zmieniają tożsamości referencyjnej konwertowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-188">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="a29c7-189">Innymi słowy, podczas gdy konwersja odwołania może zmienić typ odwołania, nigdy nie zmienia typu lub wartości obiektu, do którego odwołuje się.</span><span class="sxs-lookup"><span data-stu-id="a29c7-189">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="a29c7-190">Konwersje z opakowania</span><span class="sxs-lookup"><span data-stu-id="a29c7-190">Boxing conversions</span></span>

<span data-ttu-id="a29c7-191">Konwersja z opakowania zezwala na niejawne przekonwertowanie *value_type* na typ referencyjny.</span><span class="sxs-lookup"><span data-stu-id="a29c7-191">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="a29c7-192">Konwersja napakowywania istnieje z dowolnego *non_nullable_value_type* do `object` i `dynamic`, do `System.ValueType` i do wszystkich *INTERFACE_TYPE* wdrożonych przez *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-192">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="a29c7-193">Ponadto *enum_type* można przekonwertować na typ `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-193">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="a29c7-194">Konwersja z opakowania istnieje z *nullable_type* do typu referencyjnego, jeśli i tylko wtedy, gdy istnieje konwersja z bazowego *non_nullable_value_type* do typu odwołania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-194">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="a29c7-195">Typ wartości ma zapakowywanie konwersji do typu interfejsu `I`, jeśli ma ona konwersję na typ interfejsu `I0` i `I0` ma konwersję tożsamości na `I`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="a29c7-196">Typ wartości ma konwersję z opakowaniem do typu interfejsu `I`, jeśli ma ona konwersję do interfejsu lub typu delegata `I0`, a `I0` jest zmienności wariancji ([Konwersja wariancji](interfaces.md#variance-conversion)) na `I`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-196">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="a29c7-197">Opakowanie wartości *non_nullable_value_type* obejmuje przydzielenie wystąpienia obiektu i skopiowanie wartości *value_type* do tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-197">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="a29c7-198">Struktura może być opakowana do typu `System.ValueType`, ponieważ jest klasą bazową dla wszystkich struktur ([dziedziczenie](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-198">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="a29c7-199">Wypakowywanie wartości *nullable_type* jest następująca:</span><span class="sxs-lookup"><span data-stu-id="a29c7-199">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="a29c7-200">Jeśli wartością źródłową jest null (`HasValue` właściwość ma wartość false), wynik jest odwołaniem null typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-200">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="a29c7-201">W przeciwnym razie wynik jest odwołaniem do opakowanej `T` wygenerowanej przez odpakowanie i opakowanie wartości źródłowej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-201">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="a29c7-202">Konwersje napakowywania są opisane w dalszej [konwersji opakowania](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="a29c7-202">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="a29c7-203">Niejawne konwersje dynamiczne</span><span class="sxs-lookup"><span data-stu-id="a29c7-203">Implicit dynamic conversions</span></span>

<span data-ttu-id="a29c7-204">Niejawna konwersja dynamiczna istnieje z wyrażenia typu `dynamic` do dowolnego typu `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-204">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="a29c7-205">Konwersja jest powiązana dynamicznie ([powiązanie dynamiczne](expressions.md#dynamic-binding)), co oznacza, że niejawna konwersja zostanie poszukiwana w czasie wykonywania z typu wyrażenia do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-205">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="a29c7-206">Jeśli konwersja nie zostanie znaleziona, zostanie zgłoszony wyjątek czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-206">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="a29c7-207">Należy zauważyć, że ta niejawna konwersja pozornie narusza wskazówkę na początku [konwersji niejawnych](conversions.md#implicit-conversions) , których niejawna konwersja nigdy nie powinna spowodować wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a29c7-207">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="a29c7-208">Nie jest to jednak sama konwersja, ale *Wyszukiwanie* konwersji, która powoduje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a29c7-208">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="a29c7-209">Ryzyko wyjątków w czasie wykonywania jest związane z użyciem powiązania dynamicznego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-209">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="a29c7-210">Jeśli dynamiczne powiązanie konwersji nie jest wymagane, można najpierw przekonwertować wyrażenie na `object`, a następnie do żądanego typu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-210">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="a29c7-211">Poniższy przykład ilustruje niejawne konwersje dynamiczne:</span><span class="sxs-lookup"><span data-stu-id="a29c7-211">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="a29c7-212">Przypisania do `s2` i `i` używają niejawnych konwersji dynamicznych, w przypadku których powiązanie operacji jest wstrzymane do czasu wykonania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-212">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="a29c7-213">W czasie wykonywania niejawne konwersje są poszukiwane z typu czasu wykonywania `d` -- `string`--do typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-213">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="a29c7-214">Znaleziono konwersję do `string` ale nie `int`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-214">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="a29c7-215">Niejawne konwersje wyrażeń stałych</span><span class="sxs-lookup"><span data-stu-id="a29c7-215">Implicit constant expression conversions</span></span>

<span data-ttu-id="a29c7-216">Niejawna konwersja wyrażeń stałych umożliwia wykonywanie następujących konwersji:</span><span class="sxs-lookup"><span data-stu-id="a29c7-216">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="a29c7-217">*Constant_expression* ([wyrażenia stałe](expressions.md#constant-expressions)) typu `int` można przekonwertować na typ `sbyte`, `byte`, `short`, `ushort`, `uint`lub `ulong`, pod warunkiem, że wartość *constant_expression* należy do zakresu typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-217">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="a29c7-218">*Constant_expression* typu `long` można przekonwertować na `ulong`typu, pod warunkiem, że wartość *constant_expression* nie jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="a29c7-218">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="a29c7-219">Niejawne konwersje obejmujące parametry typu</span><span class="sxs-lookup"><span data-stu-id="a29c7-219">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="a29c7-220">Następujące konwersje niejawne istnieją dla danego parametru typu `T`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-220">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="a29c7-221">Od `T` do swojej skutecznej klasy bazowej `C`, od `T` do dowolnej klasy bazowej `C`i od `T` do dowolnego interfejsu zaimplementowanego przez `C`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-221">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="a29c7-222">W czasie wykonywania, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja z opakowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-222">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="a29c7-223">W przeciwnym razie konwersja jest wykonywana jako niejawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-223">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="a29c7-224">Od `T` do typu interfejsu `I` w `T`obowiązującym interfejsie i od `T` do dowolnego interfejsu podstawowego `I`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-224">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="a29c7-225">W czasie wykonywania, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja z opakowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-225">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="a29c7-226">W przeciwnym razie konwersja jest wykonywana jako niejawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-226">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="a29c7-227">Z `T` do `U`parametru typu, udostępnione `T` zależy od `U` ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-227">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="a29c7-228">W czasie wykonywania, jeśli `U` jest typem wartości, wówczas `T` i `U` są takie same, a konwersja nie jest przeprowadzana.</span><span class="sxs-lookup"><span data-stu-id="a29c7-228">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="a29c7-229">W przeciwnym razie, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja z opakowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-229">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="a29c7-230">W przeciwnym razie konwersja jest wykonywana jako niejawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-230">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="a29c7-231">Z literału wartości null do `T`dostarczone `T` jest znany jako typ referencyjny.</span><span class="sxs-lookup"><span data-stu-id="a29c7-231">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="a29c7-232">Od `T` do typu referencyjnego `I`, jeśli ma niejawną konwersję na typ referencyjny, `S0` a `S0` ma konwersję tożsamości na `S`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-232">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="a29c7-233">W czasie wykonywania konwersja jest wykonywana w taki sam sposób, jak konwersja do `S0`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-233">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="a29c7-234">Od `T` do typu interfejsu `I`, jeśli ma niejawną konwersję do interfejsu lub typu delegata, `I0` a `I0` jest konwersją wariancji na `I` ([Konwersja wariancji](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-234">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="a29c7-235">W czasie wykonywania, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja z opakowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-235">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="a29c7-236">W przeciwnym razie konwersja jest wykonywana jako niejawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-236">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="a29c7-237">Jeśli `T` jest znany jako typ referencyjny ([ograniczenia parametru typu](classes.md#type-parameter-constraints)), powyższe konwersje są klasyfikowane jako niejawne konwersje odwołań ([niejawne konwersje odwołań](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-237">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="a29c7-238">Jeśli `T` nie jest znany jako typ referencyjny, powyższe konwersje są klasyfikowane jako konwersje z opakowaniem ([konwersje z opakowania](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-238">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="a29c7-239">Konwersje niejawne zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-239">User-defined implicit conversions</span></span>

<span data-ttu-id="a29c7-240">Niejawna konwersja zdefiniowana przez użytkownika składa się z opcjonalnej standardowej konwersji niejawnej, a następnie wykonania operatora niejawnej konwersji zdefiniowanej przez użytkownika, a następnie innej opcjonalnej standardowej konwersji niejawnej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-240">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="a29c7-241">Dokładne reguły oceniania niejawnych konwersji zdefiniowanych przez użytkownika są opisane w temacie [Przetwarzanie konwersji niejawnych zdefiniowanych przez użytkownika](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="a29c7-241">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="a29c7-242">Konwersje funkcji anonimowych i konwersje grup metod</span><span class="sxs-lookup"><span data-stu-id="a29c7-242">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="a29c7-243">Funkcje anonimowe i grupy metod nie mają typów w i samych siebie, ale mogą być niejawnie konwertowane na typy delegatów lub typy drzewa wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="a29c7-243">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="a29c7-244">Konwersje funkcji anonimowych są opisane bardziej szczegółowo w przypadku [konwersji funkcji anonimowych](conversions.md#anonymous-function-conversions) i konwersji grup metod w przypadku [konwersji grup metod](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="a29c7-244">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="a29c7-245">Konwersje jawne</span><span class="sxs-lookup"><span data-stu-id="a29c7-245">Explicit conversions</span></span>

<span data-ttu-id="a29c7-246">Następujące konwersje są klasyfikowane jako Konwersje jawne:</span><span class="sxs-lookup"><span data-stu-id="a29c7-246">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="a29c7-247">Wszystkie konwersje niejawne.</span><span class="sxs-lookup"><span data-stu-id="a29c7-247">All implicit conversions.</span></span>
*  <span data-ttu-id="a29c7-248">Jawne konwersje numeryczne.</span><span class="sxs-lookup"><span data-stu-id="a29c7-248">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="a29c7-249">Jawne konwersje Wyliczenie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-249">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="a29c7-250">Jawne konwersje dopuszczające wartość null.</span><span class="sxs-lookup"><span data-stu-id="a29c7-250">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="a29c7-251">Jawne konwersje odwołań.</span><span class="sxs-lookup"><span data-stu-id="a29c7-251">Explicit reference conversions.</span></span>
*  <span data-ttu-id="a29c7-252">Jawne konwersje interfejsów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-252">Explicit interface conversions.</span></span>
*  <span data-ttu-id="a29c7-253">Konwersje rozpakowywanie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-253">Unboxing conversions.</span></span>
*  <span data-ttu-id="a29c7-254">Jawne konwersje dynamiczne</span><span class="sxs-lookup"><span data-stu-id="a29c7-254">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="a29c7-255">Jawne konwersje zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-255">User-defined explicit conversions.</span></span>

<span data-ttu-id="a29c7-256">Jawne konwersje mogą wystąpić w wyrażeniach rzutowania ([wyrażenia rzutowania](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-256">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="a29c7-257">Zestaw jawnych konwersji zawiera wszystkie konwersje niejawne.</span><span class="sxs-lookup"><span data-stu-id="a29c7-257">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="a29c7-258">Oznacza to, że dozwolone są nadmiarowe wyrażenia rzutowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-258">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="a29c7-259">Konwersje jawne, które nie są konwersjemi niejawnymi to konwersje, które nie mogą być sprawdzane w celu pomyślnego przeprowadzenia konwersji, które są znane do utraty informacji, a konwersje w różnych domenach typów są wystarczająco różne, aby oznaczać jawne służąc.</span><span class="sxs-lookup"><span data-stu-id="a29c7-259">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="a29c7-260">Jawne konwersje numeryczne</span><span class="sxs-lookup"><span data-stu-id="a29c7-260">Explicit numeric conversions</span></span>

<span data-ttu-id="a29c7-261">Jawne konwersje numeryczne to konwersje z *numeric_type* do innej *numeric_type* , dla których niejawna konwersja liczbowa ([niejawne konwersje liczbowe](conversions.md#implicit-numeric-conversions)) jeszcze nie istnieje:</span><span class="sxs-lookup"><span data-stu-id="a29c7-261">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="a29c7-262">Z `sbyte` do `byte`, `ushort`, `uint`, `ulong`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-262">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-263">Z `byte` `sbyte` i `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-263">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="a29c7-264">Z `short` do `sbyte`, `byte`, `ushort`, `uint`, `ulong`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-264">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-265">Od `ushort` do `sbyte`, `byte`, `short`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-265">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-266">Z `int` do `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-266">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-267">Z `uint` do `sbyte`, `byte`, `short`, `ushort`, `int`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-267">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-268">Z `long` do `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-268">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-269">Z `ulong` do `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`lub `char`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-269">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="a29c7-270">Od `char` do `sbyte`, `byte`lub `short`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-270">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="a29c7-271">Z `float` do `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-271">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-272">Z `double` do `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-272">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-273">Z `decimal` do `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`lub `double`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-273">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="a29c7-274">Ponieważ jawne konwersje obejmują wszystkie niejawnych i jawnych konwersji liczbowych, zawsze możliwe jest przekonwertowanie z dowolnego *numeric_type* na inne *numeric_type* przy użyciu wyrażenia CAST ([wyrażenia rzutowania](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-274">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="a29c7-275">Jawne konwersje numeryczne mogą spowodować utratę informacji lub spowodować, że wyjątki mają być zgłaszane.</span><span class="sxs-lookup"><span data-stu-id="a29c7-275">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="a29c7-276">Jawna konwersja liczbowa jest przetwarzana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a29c7-276">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="a29c7-277">Dla konwersji z typu całkowitego na inny typ całkowity, przetwarzanie zależy od kontekstu sprawdzania przepełnienia ([Operatory sprawdzone i niesprawdzane](expressions.md#the-checked-and-unchecked-operators)), w którym odbywa się konwersja:</span><span class="sxs-lookup"><span data-stu-id="a29c7-277">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="a29c7-278">W kontekście `checked` konwersja kończy się powodzeniem, jeśli wartość operandu źródłowego należy do zakresu typu docelowego, ale zgłasza `System.OverflowException`, jeśli wartość operandu źródła jest spoza zakresu typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-278">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="a29c7-279">W kontekście `unchecked` konwersja zawsze kończy się powodzeniem i przechodzi w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="a29c7-279">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="a29c7-280">Jeśli typ źródła jest większy niż typ docelowy, wartość źródłowa zostanie obcięta przez odrzucenie jej najbardziej znaczących bitów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-280">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="a29c7-281">Następnie wynik jest traktowany jako wartość typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-281">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="a29c7-282">Jeśli typ źródła jest mniejszy niż typ docelowy, wartość źródłowa jest podwyższana lub równa zero, tak że jest to ten sam rozmiar, co typ docelowy.</span><span class="sxs-lookup"><span data-stu-id="a29c7-282">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="a29c7-283">Jeśli typ źródła jest podpisany, jest używane rozszerzenie-znak. Jeśli typ źródła jest niepodpisany, jest używane rozszerzenie o wartości zero.</span><span class="sxs-lookup"><span data-stu-id="a29c7-283">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="a29c7-284">Następnie wynik jest traktowany jako wartość typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-284">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="a29c7-285">Jeśli typ źródła ma taki sam rozmiar jak typ docelowy, wartość źródłowa jest traktowana jako wartość typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-285">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="a29c7-286">Dla konwersji z `decimal` na typ całkowity, wartość źródłowa jest zaokrąglana do zera do najbliższej wartości całkowitej, a ta wartość całkowita będzie wynikiem konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-286">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="a29c7-287">Jeśli uzyskana wartość całkowita jest poza zakresem typu docelowego, zostanie zgłoszony `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-287">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="a29c7-288">W przypadku konwersji z `float` lub `double` na typ całkowity, przetwarzanie zależy od kontekstu sprawdzania przepełnienia ([Operatory sprawdzone i niezaznaczone](expressions.md#the-checked-and-unchecked-operators)), w których odbywa się konwersja:</span><span class="sxs-lookup"><span data-stu-id="a29c7-288">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="a29c7-289">W kontekście `checked` konwersja wykonuje następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="a29c7-289">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="a29c7-290">Jeśli wartość operandu jest NaN lub nieskończona, zostanie zgłoszony `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-290">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="a29c7-291">W przeciwnym razie argument źródłowy jest zaokrąglany do zera do najbliższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-291">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="a29c7-292">Jeśli ta wartość całkowita znajduje się w zakresie typu docelowego, ta wartość jest wynikiem konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-292">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="a29c7-293">W przeciwnym razie zostanie zgłoszony `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-293">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="a29c7-294">W kontekście `unchecked` konwersja zawsze kończy się powodzeniem i przechodzi w następujący sposób.</span><span class="sxs-lookup"><span data-stu-id="a29c7-294">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="a29c7-295">Jeśli wartość operandu jest NaN lub nieskończona, wynik konwersji jest nieokreśloną wartością typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-295">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="a29c7-296">W przeciwnym razie argument źródłowy jest zaokrąglany do zera do najbliższej wartości całkowitej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-296">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="a29c7-297">Jeśli ta wartość całkowita znajduje się w zakresie typu docelowego, ta wartość jest wynikiem konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-297">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="a29c7-298">W przeciwnym razie wynik konwersji jest nieokreśloną wartością typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-298">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="a29c7-299">W przypadku konwersji z `double` na `float`wartość `double` jest zaokrąglana do najbliższej wartości `float`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-299">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="a29c7-300">Jeśli wartość `double` jest zbyt mała, aby reprezentować ją jako `float`, wynik przyjmie wartość dodatnią zero lub ujemną zero.</span><span class="sxs-lookup"><span data-stu-id="a29c7-300">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="a29c7-301">Jeśli wartość `double` jest zbyt duża, aby reprezentować ją jako `float`, wynik będzie dodatnią nieskończoność lub ujemną nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="a29c7-301">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="a29c7-302">Jeśli `double` wartością jest NaN, wynik jest również NaN.</span><span class="sxs-lookup"><span data-stu-id="a29c7-302">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="a29c7-303">Dla konwersji z `float` lub `double` do `decimal`, wartość źródłowa jest konwertowana na `decimal` reprezentacja i zaokrąglana do najbliższej liczby po 28 miejsc dziesiętnych, jeśli jest to wymagane ([Typ dziesiętny](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-303">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="a29c7-304">Jeśli wartość źródłowa jest zbyt mała, aby reprezentować ją jako `decimal`, wynik zmieni się na zero.</span><span class="sxs-lookup"><span data-stu-id="a29c7-304">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="a29c7-305">Jeśli wartością źródłową jest NaN, nieskończoność lub zbyt duża do reprezentowania jako `decimal`, zostanie zgłoszony `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-305">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="a29c7-306">W przypadku konwersji z `decimal` na `float` lub `double`wartość `decimal` jest zaokrąglana do najbliższej wartości `double` lub `float`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-306">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="a29c7-307">Ta konwersja może spowodować utratę precyzji, ale nigdy nie powoduje zgłoszenia wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a29c7-307">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="a29c7-308">Jawne konwersje wyliczenia</span><span class="sxs-lookup"><span data-stu-id="a29c7-308">Explicit enumeration conversions</span></span>

<span data-ttu-id="a29c7-309">Jawne konwersje Wyliczenie są następujące:</span><span class="sxs-lookup"><span data-stu-id="a29c7-309">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="a29c7-310">Z `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`lub `decimal` do dowolnej *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-310">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="a29c7-311">Z dowolnego *enum_type* do `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`lub `decimal`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-311">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="a29c7-312">Z dowolnego *enum_type* do dowolnego innego *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-312">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="a29c7-313">Jawna konwersja wyliczenia między dwoma typami jest przetwarzana przez traktowanie wszelkich uczestniczących *enum_type* jako typ podstawowy tego *enum_type*, a następnie wykonywanie niejawnej lub jawnej konwersji liczbowej między wynikiem.</span><span class="sxs-lookup"><span data-stu-id="a29c7-313">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="a29c7-314">Na przykład w przypadku *enum_type* `E` z i typem bazowym `int`konwersja z `E` na `byte` jest przetwarzana jako jawna konwersja liczbowa ([jawne konwersje liczbowe](conversions.md#explicit-numeric-conversions)) od `int` do `byte`, a konwersja z `byte` do `E` jest przetwarzana jako niejawna konwersja liczbowa ([niejawne konwersje liczbowe](conversions.md#implicit-numeric-conversions)) od `byte` do `int`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-314">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="a29c7-315">Jawne konwersje dopuszczające wartość null</span><span class="sxs-lookup"><span data-stu-id="a29c7-315">Explicit nullable conversions</span></span>

<span data-ttu-id="a29c7-316">***Jawne konwersje wartości null*** zezwalają na wstępnie zdefiniowane Konwersje jawne, które działają dla typów wartościowych niedopuszczających wartości null, aby były również używane z dopuszczaniem wartości null dla tych typów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-316">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="a29c7-317">Dla każdej z wstępnie zdefiniowanych konwersji jawnych, które konwertują z typu wartości niedopuszczających wartości null `S` na typ wartości niedopuszczających wartości null `T` ([konwersja tożsamości](conversions.md#identity-conversion), [niejawne konwersje liczbowe](conversions.md#implicit-numeric-conversions), [niejawne konwersje wyliczenia](conversions.md#implicit-enumeration-conversions), [jawne konwersje liczbowe](conversions.md#explicit-numeric-conversions)i [jawne konwersje wyliczenia](conversions.md#explicit-enumeration-conversions)), istnieją następujące konwersje dopuszczające wartość null:</span><span class="sxs-lookup"><span data-stu-id="a29c7-317">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="a29c7-318">Jawna konwersja z `S?` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-318">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="a29c7-319">Jawna konwersja z `S` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-319">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="a29c7-320">Jawna konwersja z `S?` na `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-320">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="a29c7-321">Obliczanie konwersji dopuszczającej wartość null na podstawie bazowej konwersji z `S`, aby `T` kontynuowały się w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a29c7-321">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="a29c7-322">Jeśli konwersja dopuszcza wartość null z `S?` do `T?`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-322">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="a29c7-323">Jeśli wartością źródłową jest null (`HasValue` właściwość ma wartość false), wynik jest wartością null typu `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-323">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="a29c7-324">W przeciwnym razie konwersja jest oceniana jako odpakowanie od `S?` do `S`, a po niej bazowa konwersja z `S` do `T`, po którym następuje Zawijanie z `T` `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-324">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="a29c7-325">Jeśli konwersja do wartości null jest z `S` do `T?`, konwersja jest szacowana jako bazowa konwersja z `S` do `T`, a po nim otoka z `T` `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-325">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="a29c7-326">Jeśli konwersja do wartości null jest z `S?` do `T`, konwersja jest oceniana jako odpakowanie od `S?` do `S`, a następnie bazowa konwersja z `S` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-326">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="a29c7-327">Należy zauważyć, że próba odpakowania wartości null spowoduje zgłoszenie wyjątku, jeśli wartość jest `null`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-327">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="a29c7-328">Jawne konwersje odwołań</span><span class="sxs-lookup"><span data-stu-id="a29c7-328">Explicit reference conversions</span></span>

<span data-ttu-id="a29c7-329">Jawne konwersje odwołań są następujące:</span><span class="sxs-lookup"><span data-stu-id="a29c7-329">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="a29c7-330">Z `object` i `dynamic` do innych *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-330">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="a29c7-331">Z dowolnego *class_type* `S` do dowolnego *class_type* `T`, podane `S` jest klasą bazową `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-331">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="a29c7-332">Z dowolnego *class_type* `S` do dowolnego *INTERFACE_TYPE* `T`, podane `S` nie jest zapieczętowane i podane `S` nie implementuje `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-332">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="a29c7-333">Z dowolnego *interface_type* `S` do dowolnego *class_type* `T`, podane `T` nie jest zapieczętowane ani dostarczone `T` implementuje `S`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-333">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="a29c7-334">Z dowolnego *interface_type* `S` do dowolnego *INTERFACE_TYPE* `T`, dostarczony `S` nie pochodzi od `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-334">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="a29c7-335">Z *array_type* `S` z typem elementu `SE` do *array_type* `T` z typem elementu `TE`, pod warunkiem spełnione są wszystkie z następujących warunków:</span><span class="sxs-lookup"><span data-stu-id="a29c7-335">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="a29c7-336">`S` i `T` różnią się tylko w typie elementu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-336">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="a29c7-337">Innymi słowy, `S` i `T` mają taką samą liczbę wymiarów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-337">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="a29c7-338">Zarówno `SE`, jak i `TE` są *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="a29c7-338">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="a29c7-339">Istnieje jawna konwersja odwołań z `SE` do `TE`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-339">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="a29c7-340">Z `System.Array` i interfejsów, które implementuje do dowolnego *array_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-340">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="a29c7-341">Z jednowymiarowego typu tablicy `S[]` do `System.Collections.Generic.IList<T>` i jego interfejsów podstawowych, pod warunkiem, że istnieje jawna konwersja odwołań z `S` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-341">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="a29c7-342">Od `System.Collections.Generic.IList<S>` i jego interfejsów podstawowych do jednowymiarowego typu tablicy `T[]`, pod warunkiem, że istnieje jawna tożsamość lub konwersja odwołania z `S` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-342">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="a29c7-343">Z `System.Delegate` i interfejsów, które implementuje do dowolnego *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-343">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="a29c7-344">Z typu referencyjnego do typu referencyjnego `T`, jeśli ma on jawną konwersję referencyjną do typu referencyjnego `T0` i `T0` ma `T`konwersji tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-344">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="a29c7-345">Z typu referencyjnego do interfejsu lub typu delegata `T`, jeśli ma on jawną konwersję referencyjną do interfejsu lub typu delegata `T0`, a `T0` jest konwersją wariancji do `T` lub `T`, można przekonwertować wariancję na `T0` ([Konwersja wariancji](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-345">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="a29c7-346">Od `D<S1...Sn>` do `D<T1...Tn>`, gdzie `D<X1...Xn>` jest ogólnym typem delegata, `D<S1...Sn>` nie jest zgodny z lub identyczna z `D<T1...Tn>`, a dla każdego parametru typu `Xi` `D`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-346">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="a29c7-347">Jeśli `Xi` jest niezmienna, `Si` jest taka sama jak `Ti`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-347">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="a29c7-348">Jeśli `Xi` jest współwariantem, istnieje niejawna lub jawna tożsamość lub konwersja odwołania z `Si` do `Ti`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-348">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="a29c7-349">Jeśli `Xi` jest kontrawariantne, wówczas `Si` i `Ti` są identyczne lub oba typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="a29c7-349">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="a29c7-350">Jawne konwersje obejmujące parametry typu, które są znane jako typy odwołań.</span><span class="sxs-lookup"><span data-stu-id="a29c7-350">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="a29c7-351">Aby uzyskać więcej informacji na temat jawnych konwersji obejmujących parametry typu, zobacz [jawne konwersje dotyczące parametrów typu](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="a29c7-351">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="a29c7-352">Jawne konwersje referencyjne to konwersje między typami referencyjnymi wymagającymi kontroli w czasie wykonywania, aby upewnić się, że są poprawne.</span><span class="sxs-lookup"><span data-stu-id="a29c7-352">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="a29c7-353">Aby konwersja jawnego odwołania powiodła się w czasie wykonywania, wartość operandu źródła musi być `null`lub rzeczywisty typ obiektu, do którego odwołuje się operand źródłowy, musi być typem, który można przekonwertować na typ docelowy przez niejawną konwersję odwołania ([niejawne konwersje odwołań](conversions.md#implicit-reference-conversions)) lub konwersję z opakowaniem ([konwersje na opakowanie](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-353">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="a29c7-354">Jeśli jawna konwersja referencyjna nie powiedzie się, zostanie zgłoszony `System.InvalidCastException`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-354">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="a29c7-355">Konwersje odwołań, niejawne lub jawne, nigdy nie zmieniają tożsamości referencyjnej konwertowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-355">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="a29c7-356">Innymi słowy, podczas gdy konwersja odwołania może zmienić typ odwołania, nigdy nie zmienia typu lub wartości obiektu, do którego odwołuje się.</span><span class="sxs-lookup"><span data-stu-id="a29c7-356">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="a29c7-357">Odpakowywanie konwersji</span><span class="sxs-lookup"><span data-stu-id="a29c7-357">Unboxing conversions</span></span>

<span data-ttu-id="a29c7-358">Konwersja rozpakowywania umożliwia jawne przekonwertowanie typu odwołania na *value_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-358">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="a29c7-359">Konwersja rozpakowywania istnieje z typów `object`, `dynamic` i `System.ValueType` do wszelkich *non_nullable_value_type*oraz od dowolnego *interface_type* do dowolnego *non_nullable_value_type* implementującego *INTERFACE_TYPE*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-359">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="a29c7-360">Ponadto typ `System.Enum` może być rozpakowany do dowolnego *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-360">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="a29c7-361">Konwersja rozpakowywania istnieje z typu referencyjnego na *nullable_type* , jeśli istnieje konwersja rozpakowywanie z typu referencyjnego na bazowe *non_nullable_value_type* *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-361">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="a29c7-362">Typ wartości `S` ma rozpakowywanie konwersji z typu interfejsu `I`, jeśli ma ona konwersję rozpakowywanie z typu interfejsu, `I0` a `I0` ma konwersję tożsamości na `I`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="a29c7-363">Typ wartości `S` ma rozpakowywanie konwersji z typu interfejsu `I`, jeśli ma ona konwersję rozpakowywania z interfejsu lub typu delegata, `I0` a `I0` jest konwersją wariancji do `I` lub `I` jest konwertowany na `I0` ([Konwersja wariancji](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-363">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="a29c7-364">Operacja rozpakowywania polega na pierwszym sprawdzeniu, że wystąpienie obiektu jest wartością opakowaną danego *value_type*, a następnie kopiując wartość z wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-364">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="a29c7-365">Rozpakowywanie odwołania o wartości null do *nullable_type* powoduje utworzenie wartości null *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-365">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="a29c7-366">Struktura może być oddzielna od typu `System.ValueType`, ponieważ jest klasą bazową dla wszystkich struktur ([dziedziczenie](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-366">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="a29c7-367">Konwersje rozpakowywania są szczegółowo opisane w [konwersji](types.md#unboxing-conversions)rozpakowywania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-367">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="a29c7-368">Jawne konwersje dynamiczne</span><span class="sxs-lookup"><span data-stu-id="a29c7-368">Explicit dynamic conversions</span></span>

<span data-ttu-id="a29c7-369">Jawna konwersja dynamiczna istnieje w wyrażeniu typu `dynamic` do dowolnego typu `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-369">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="a29c7-370">Konwersja jest powiązana dynamicznie ([powiązanie dynamiczne](expressions.md#dynamic-binding)), co oznacza, że jawna konwersja będzie poszukiwana w czasie wykonywania z typu wyrażenia do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-370">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="a29c7-371">Jeśli konwersja nie zostanie znaleziona, zostanie zgłoszony wyjątek czasu wykonywania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-371">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="a29c7-372">Jeśli dynamiczne powiązanie konwersji nie jest wymagane, można najpierw przekonwertować wyrażenie na `object`, a następnie do żądanego typu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-372">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="a29c7-373">Załóżmy, że zdefiniowano następującą klasę:</span><span class="sxs-lookup"><span data-stu-id="a29c7-373">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="a29c7-374">Poniższy przykład ilustruje jawne konwersje dynamiczne:</span><span class="sxs-lookup"><span data-stu-id="a29c7-374">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="a29c7-375">Najlepszą konwersją `o` na `C` można znaleźć w czasie kompilacji jako jawną konwersję odwołań.</span><span class="sxs-lookup"><span data-stu-id="a29c7-375">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="a29c7-376">To nie powiedzie się w czasie wykonywania, ponieważ `"1"` nie jest w rzeczywistości `C`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-376">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="a29c7-377">Konwersja `d` na `C` jednak jako jawna konwersja dynamiczna jest zawieszona do czasu wykonywania, w której zdefiniowana przez użytkownika konwersja z typu czasu wykonywania `d` -- `string`--do `C` zostanie znaleziona i powiedzie się.</span><span class="sxs-lookup"><span data-stu-id="a29c7-377">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="a29c7-378">Jawne konwersje obejmujące parametry typu</span><span class="sxs-lookup"><span data-stu-id="a29c7-378">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="a29c7-379">Następujące Konwersje jawne istnieją dla danego parametru typu `T`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-379">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="a29c7-380">Od efektywnej klasy bazowej `C` `T` do `T` oraz z dowolnej klasy podstawowej `C` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-380">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="a29c7-381">W czasie wykonywania, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja rozpakowywanie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-381">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="a29c7-382">W przeciwnym razie konwersja jest wykonywana jako jawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-382">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="a29c7-383">Z dowolnego typu interfejsu do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-383">From any interface type to `T`.</span></span> <span data-ttu-id="a29c7-384">W czasie wykonywania, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja rozpakowywanie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-384">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="a29c7-385">W przeciwnym razie konwersja jest wykonywana jako jawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-385">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="a29c7-386">Od `T` do wszelkich *interface_type* `I` z zastrzeżeniem, że nie istnieje jeszcze niejawna konwersja z `T` na `I`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-386">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="a29c7-387">W czasie wykonywania, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja z opakowania, po którym następuje jawna konwersja odwołania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-387">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="a29c7-388">W przeciwnym razie konwersja jest wykonywana jako jawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-388">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="a29c7-389">Z parametru typu `U` do `T`, podane `T` zależy od `U` ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-389">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="a29c7-390">W czasie wykonywania, jeśli `U` jest typem wartości, wówczas `T` i `U` są takie same, a konwersja nie jest przeprowadzana.</span><span class="sxs-lookup"><span data-stu-id="a29c7-390">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="a29c7-391">W przeciwnym razie, jeśli `T` jest typem wartości, konwersja jest wykonywana jako konwersja rozpakowywanie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-391">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="a29c7-392">W przeciwnym razie konwersja jest wykonywana jako jawna konwersja odwołania lub konwersja tożsamości.</span><span class="sxs-lookup"><span data-stu-id="a29c7-392">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="a29c7-393">Jeśli `T` jest znany jako typ referencyjny, powyższe konwersje są wszystkie klasyfikowane jako jawne konwersje odwołań ([jawne konwersje odwołań](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-393">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="a29c7-394">Jeśli `T` nie jest znany jako typ referencyjny, konwersje powyżej są klasyfikowane jako konwersje rozpakowywania ([konwersje rozpakowywanie](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-394">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="a29c7-395">Powyższe zasady nie zezwalają na bezpośrednią jawną konwersję z nieograniczonego parametru typu do typu innego niż interfejs, który może być zaskakujące.</span><span class="sxs-lookup"><span data-stu-id="a29c7-395">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="a29c7-396">Przyczyną tej reguły jest zapobieganie nieporozumieniu i wykonywanie semantyki takich konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-396">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="a29c7-397">Na przykład przeanalizujmy następującą deklarację:</span><span class="sxs-lookup"><span data-stu-id="a29c7-397">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="a29c7-398">Jeśli dozwolone jest bezpośrednie przekonwertowanie `t` na `int`, jeden z nich może łatwo oczekiwać, że `X<int>.F(7)` zwróci `7L`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-398">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="a29c7-399">Jednakże, ponieważ standardowe konwersje liczbowe są brane pod uwagę tylko wtedy, gdy typy są znane jako liczbowe w czasie trwania powiązania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-399">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="a29c7-400">Aby semantyka była oczywista, należy napisać powyższy przykład:</span><span class="sxs-lookup"><span data-stu-id="a29c7-400">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="a29c7-401">Ten kod zostanie teraz skompilowany, ale wykonanie `X<int>.F(7)` następnie zgłosi wyjątek w czasie wykonywania, ponieważ `int` opakowane nie mogą być konwertowane bezpośrednio do `long`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-401">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="a29c7-402">Jawne konwersje zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-402">User-defined explicit conversions</span></span>

<span data-ttu-id="a29c7-403">Jawna konwersja zdefiniowana przez użytkownika składa się z opcjonalnej standardowej konwersji jawnej, po której następuje wykonanie zdefiniowanego przez użytkownika operatora konwersji jawnej lub jawnej, a następnie innej opcjonalnej konwersji jawnej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-403">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="a29c7-404">Dokładne reguły oceniania jawnych konwersji zdefiniowanych przez użytkownika są opisane w temacie [Przetwarzanie konwersji jawnych zdefiniowanych przez użytkownika](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="a29c7-404">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="a29c7-405">Konwersje standardowe</span><span class="sxs-lookup"><span data-stu-id="a29c7-405">Standard conversions</span></span>

<span data-ttu-id="a29c7-406">Standardowe konwersje są wstępnie zdefiniowanymi konwersjemi, które mogą wystąpić w ramach konwersji zdefiniowanej przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-406">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="a29c7-407">Standardowe konwersje niejawne</span><span class="sxs-lookup"><span data-stu-id="a29c7-407">Standard implicit conversions</span></span>

<span data-ttu-id="a29c7-408">Następujące niejawne konwersje są klasyfikowane jako standardowe konwersje niejawne:</span><span class="sxs-lookup"><span data-stu-id="a29c7-408">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="a29c7-409">Konwersje tożsamości ([konwersja tożsamości](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="a29c7-409">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="a29c7-410">Niejawne konwersje numeryczne ([niejawne konwersje liczbowe](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="a29c7-410">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="a29c7-411">Niejawne konwersje null ([niejawne konwersje dopuszczające wartość null](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="a29c7-411">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="a29c7-412">Niejawne konwersje odwołań ([niejawne konwersje odwołań](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="a29c7-412">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="a29c7-413">Konwersje z opakowaniem ([konwersje z opakowania](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="a29c7-413">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="a29c7-414">Niejawne konwersje wyrażeń stałych ([niejawne konwersje dynamiczne](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="a29c7-414">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="a29c7-415">Niejawne konwersje dotyczące parametrów typu ([niejawne konwersje obejmujące parametry typu](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="a29c7-415">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="a29c7-416">Standardowe konwersje niejawne wykluczają specjalne konwersje niejawne zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-416">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="a29c7-417">Standardowe Konwersje jawne</span><span class="sxs-lookup"><span data-stu-id="a29c7-417">Standard explicit conversions</span></span>

<span data-ttu-id="a29c7-418">Standardowe Konwersje jawne to wszystkie standardowe konwersje niejawne oraz podzestaw jawnych konwersji, dla których istnieje odwrotna niejawna konwersja.</span><span class="sxs-lookup"><span data-stu-id="a29c7-418">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="a29c7-419">Innymi słowy, jeśli istnieje standardowa niejawna konwersja z typu `A` do typu `B`, wówczas istnieje standardowa jawna konwersja z typu `A`, aby wpisać `B` i z typu `B` do typu `A`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-419">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="a29c7-420">Konwersje zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-420">User-defined conversions</span></span>

<span data-ttu-id="a29c7-421">C#zezwala na rozszerzanie wstępnie zdefiniowanych niejawnych i jawnych konwersji przez ***zdefiniowane przez użytkownika Konwersje***.</span><span class="sxs-lookup"><span data-stu-id="a29c7-421">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="a29c7-422">Konwersje zdefiniowane przez użytkownika są wprowadzane przez deklarując operatory konwersji ([Operatory konwersji](classes.md#conversion-operators)) w typach klasy i struktury.</span><span class="sxs-lookup"><span data-stu-id="a29c7-422">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="a29c7-423">Dozwolone konwersje zdefiniowane przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-423">Permitted user-defined conversions</span></span>

<span data-ttu-id="a29c7-424">C#zezwala na zadeklarowanie tylko określonych konwersji zdefiniowanych przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-424">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="a29c7-425">W szczególności nie jest możliwe ponowne zdefiniowanie istniejącej konwersji niejawnej lub jawnej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-425">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="a29c7-426">Dla danego typu źródła `S` i typu docelowego `T`, jeśli `S` lub `T` są typami dopuszczających wartości null, pozwól `S0` i `T0` odnoszą się do ich typów podstawowych, w przeciwnym razie `S0` i `T0` są równe `S` i `T` odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="a29c7-426">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="a29c7-427">Klasa lub struktura może deklarować konwersję z typu źródłowego `S` do typu docelowego `T` tylko wtedy, gdy spełnione są wszystkie następujące warunki:</span><span class="sxs-lookup"><span data-stu-id="a29c7-427">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="a29c7-428">`S0` i `T0` są różnymi typami.</span><span class="sxs-lookup"><span data-stu-id="a29c7-428">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="a29c7-429">`S0` lub `T0` jest klasą lub typem struktury, w której odbywa się deklaracja operatora.</span><span class="sxs-lookup"><span data-stu-id="a29c7-429">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="a29c7-430">Ani `S0` ani `T0` jest *interface_typeem*.</span><span class="sxs-lookup"><span data-stu-id="a29c7-430">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="a29c7-431">Oprócz konwersji zdefiniowanych przez użytkownika konwersja nie istnieje z `S` do `T` lub `T` do `S`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-431">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="a29c7-432">Ograniczenia dotyczące konwersji zdefiniowanych przez użytkownika są szczegółowo omówione w [operatorach konwersji](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="a29c7-432">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="a29c7-433">Przenoszone operatory konwersji</span><span class="sxs-lookup"><span data-stu-id="a29c7-433">Lifted conversion operators</span></span>

<span data-ttu-id="a29c7-434">Po zdefiniowaniu zdefiniowanego przez użytkownika operatora konwersji, który konwertuje typ wartości niedopuszczający wartości null `S` na typ wartości niedopuszczający wartości null `T`, istnieje ***zniesiony Operator konwersji*** , który konwertuje z `S?` na `T?`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-434">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="a29c7-435">Ten podnieśny Operator konwersji wykonuje odpakowanie od `S?` do `S`, a po nim konwersja zdefiniowana przez użytkownika z `S` na `T`, a następnie otokę z `T` do `T?`, z tą różnicą, że `S?` wartość null jest konwertowana bezpośrednio na `T?`ową wartość null.</span><span class="sxs-lookup"><span data-stu-id="a29c7-435">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="a29c7-436">Przenoszone operatory konwersji mają tę samą niejawną lub niejawną klasyfikację, jak jej podstawowy zdefiniowany przez użytkownika Operator konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-436">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="a29c7-437">Termin "konwersja zdefiniowana przez użytkownika" dotyczy użycia operatorów konwersji zdefiniowanych przez użytkownika i podnoszenia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-437">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="a29c7-438">Obliczanie konwersji zdefiniowanych przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-438">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="a29c7-439">Zdefiniowana przez użytkownika konwersja konwertuje wartość z typu, nazywaną ***typem źródła***, na inny typ o nazwie ***Typ docelowy***.</span><span class="sxs-lookup"><span data-stu-id="a29c7-439">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="a29c7-440">Ocena zdefiniowanych przez użytkownika centrów konwersji na potrzeby znajdowania ***najbardziej określonego*** zdefiniowanego przez użytkownika operatora konwersji dla określonych typów źródłowych i docelowych.</span><span class="sxs-lookup"><span data-stu-id="a29c7-440">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="a29c7-441">To oznaczenie jest podzielone na kilka kroków:</span><span class="sxs-lookup"><span data-stu-id="a29c7-441">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="a29c7-442">Znajdowanie zestawu klas i struktur, z których będą brane operatory konwersji zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-442">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="a29c7-443">Ten zestaw składa się z typu źródła i jego klas bazowych oraz typu docelowego i jego klas bazowych (z niejawnymi założeniami, które tylko klasy i struktury mogą deklarować operatorów zdefiniowanych przez użytkownika, a typy nieklasowe nie mają klas bazowych).</span><span class="sxs-lookup"><span data-stu-id="a29c7-443">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="a29c7-444">Na potrzeby tego kroku, jeśli typem źródłowym lub docelowym jest *nullable_type*, zamiast niego zostanie użyty ich typ podstawowy.</span><span class="sxs-lookup"><span data-stu-id="a29c7-444">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="a29c7-445">Z tego zestawu typów można określić, które operatory konwersji zdefiniowane przez użytkownika i przenoszone.</span><span class="sxs-lookup"><span data-stu-id="a29c7-445">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="a29c7-446">Aby operator konwersji miał zastosowanie, musi być możliwe wykonanie konwersji standardowej ([Konwersje standardowe](conversions.md#standard-conversions)) z typu źródłowego na typ operandu operatora i musi być możliwe wykonanie konwersji standardowej z typu wynikowego operatora na typ docelowy.</span><span class="sxs-lookup"><span data-stu-id="a29c7-446">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="a29c7-447">Z zestawu odpowiednich operatorów zdefiniowanych przez użytkownika, określający, który operator jest jednoznacznie najbardziej specyficzny.</span><span class="sxs-lookup"><span data-stu-id="a29c7-447">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="a29c7-448">Ogólnie rzecz biorąc, najbardziej konkretny operator jest operatorem, którego typ operandu jest "najbliższy" do typu źródłowego i którego typ wyniku to "najbliższy" do typu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-448">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="a29c7-449">Zdefiniowane przez użytkownika operatory konwersji są preferowane przez przenoszone operatory konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-449">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="a29c7-450">Dokładne reguły dotyczące ustanawiania najbardziej określonego zdefiniowanego przez użytkownika operatora konwersji są zdefiniowane w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="a29c7-450">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="a29c7-451">Po zidentyfikowaniu określonego zdefiniowanego przez użytkownika operatora konwersji rzeczywiste wykonanie konwersji zdefiniowanej przez użytkownika obejmuje trzy kroki:</span><span class="sxs-lookup"><span data-stu-id="a29c7-451">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="a29c7-452">Po pierwsze, w razie potrzeby, przeprowadzenie konwersji standardowej z typu źródłowego na typ operandu operatora konwersji zdefiniowanego przez użytkownika lub podnoszenia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-452">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="a29c7-453">Następnie wywoływanie operatora konwersji zdefiniowanego przez użytkownika lub zniesionego w celu przeprowadzenia konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-453">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="a29c7-454">Na koniec, w razie potrzeby, przeprowadzenie standardowej konwersji z typu wynikowego operatora konwersji zdefiniowanego przez użytkownika lub przekształcenia na typ docelowy.</span><span class="sxs-lookup"><span data-stu-id="a29c7-454">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="a29c7-455">Obliczanie zdefiniowanej przez użytkownika konwersji nigdy nie obejmuje więcej niż jednego operatora konwersji zdefiniowanego przez użytkownika lub podniesionego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-455">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="a29c7-456">Inaczej mówiąc, konwersja z typu `S` do typu `T` nigdy nie wykona najpierw konwersji zdefiniowanej przez użytkownika z `S` na `X`, a następnie wykonaj konwersję zdefiniowaną przez użytkownika z `X` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-456">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="a29c7-457">Dokładne definicje oceny niejawnych lub jawnych konwersji zdefiniowanych przez użytkownika są podano w poniższych sekcjach.</span><span class="sxs-lookup"><span data-stu-id="a29c7-457">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="a29c7-458">Definicje korzystają z następujących warunków:</span><span class="sxs-lookup"><span data-stu-id="a29c7-458">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="a29c7-459">Jeśli standardowa niejawna konwersja ([niejawne konwersje](conversions.md#standard-implicit-conversions)) istnieje z typu `A` do typu `B`, a jeśli nie `A` ani `B` są *INTERFACE_TYPE*s, wówczas `A` jest określana ***przez*** `B`, a `B` jest określana ***jako `A`*** .</span><span class="sxs-lookup"><span data-stu-id="a29c7-459">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="a29c7-460">***Najbardziej obejmujący typ*** w zestawie typów to jeden typ, który obejmuje wszystkie inne typy w zestawie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-460">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="a29c7-461">Jeśli żaden typ pojedynczy nie obejmuje wszystkich innych typów, zestaw nie ma żadnego typu obejmującego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-461">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="a29c7-462">W bardziej intuicyjnych warunkach, najbardziej obejmujący typ to "największy" typ w zestawie — jeden typ, do którego każdy inny typ może być niejawnie konwertowany.</span><span class="sxs-lookup"><span data-stu-id="a29c7-462">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="a29c7-463">Najbardziej pożądany ***Typ*** w zestawie typów to jeden typ, który jest obejmujący wszystkie inne typy w zestawie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-463">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="a29c7-464">Jeśli żaden typ pojedynczy nie zostanie określony przez wszystkie inne typy, zestaw nie ma żadnego typu z typem.</span><span class="sxs-lookup"><span data-stu-id="a29c7-464">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="a29c7-465">W bardziej intuicyjnych warunkach, najbardziej odnoszące się do typu "najmniejszy" typ w zestawie — jeden typ, który może być niejawnie konwertowany na każdy z innych typów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-465">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="a29c7-466">Przetwarzanie konwersji niejawnych zdefiniowanych przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-466">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="a29c7-467">Zdefiniowana przez użytkownika niejawna konwersja z typu `S` na typ `T` jest przetwarzana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a29c7-467">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="a29c7-468">Określ typy `S0` i `T0`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-468">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="a29c7-469">Jeśli `S` lub `T` mają Typy dopuszczające wartość null, `S0` i `T0` są ich typami podstawowymi, w przeciwnym razie `S0` i `T0` są równe odpowiednio `S` i `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-469">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="a29c7-470">Znajdź zestaw typów, `D`, z których będą rozpatrywane operatory konwersji zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-470">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="a29c7-471">Ten zestaw składa się z `S0` (jeśli `S0` jest klasą lub strukturą), klasy bazowe `S0` (jeśli `S0` jest klasą) i `T0` (jeśli `T0` jest klasą lub strukturą).</span><span class="sxs-lookup"><span data-stu-id="a29c7-471">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="a29c7-472">Znajdź zestaw odpowiednich operatorów konwersji zdefiniowanych przez użytkownika i podnoszenia, `U`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-472">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="a29c7-473">Ten zestaw składa się z zdefiniowanych przez użytkownika i poddanych niejawnych operatorów konwersji zadeklarowanych przez klasy lub struktury w `D`, które konwertują z typu obejmującego `S` do typu, który obejmuje `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-473">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="a29c7-474">Jeśli `U` jest pusty, konwersja jest niezdefiniowana i wystąpi błąd podczas kompilowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-474">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-475">Znajdź najbardziej konkretny typ źródła, `SX`w `U`operatory:</span><span class="sxs-lookup"><span data-stu-id="a29c7-475">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="a29c7-476">Jeśli którykolwiek z operatorów w `U` skonwertować z `S`, `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-476">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="a29c7-477">W przeciwnym razie `SX` jest najbardziej powiązanego typu w połączonym zestawie typów źródłowych operatorów w `U`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-477">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="a29c7-478">Jeśli nie można znaleźć dokładnie jednego z najbardziej pokrytych typów, konwersja jest niejednoznaczna i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-478">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-479">Znajdź najbardziej konkretny typ docelowy, `TX`w `U`operatory:</span><span class="sxs-lookup"><span data-stu-id="a29c7-479">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="a29c7-480">Jeśli którykolwiek z operatorów w `U` skonwertować na `T`, `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-480">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="a29c7-481">W przeciwnym razie `TX` to najbardziej obejmujący typ w połączonym zestawie typów docelowych operatorów w `U`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-481">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="a29c7-482">Jeśli nie można znaleźć dokładnie jednego typu, który nie zawiera, konwersja jest niejednoznaczna i wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-482">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-483">Znajdź najbardziej specyficzny Operator konwersji:</span><span class="sxs-lookup"><span data-stu-id="a29c7-483">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="a29c7-484">Jeśli `U` zawiera dokładnie jeden operator konwersji zdefiniowany przez użytkownika, który konwertuje z `SX` na `TX`, to jest to najbardziej specyficzny Operator konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-484">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="a29c7-485">W przeciwnym razie, jeśli `U` zawiera dokładnie jeden podnieśny Operator konwersji, który konwertuje z `SX` na `TX`, to jest to najbardziej konkretny Operator konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-485">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="a29c7-486">W przeciwnym razie konwersja jest niejednoznaczna i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-486">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-487">Na koniec zastosuj konwersję:</span><span class="sxs-lookup"><span data-stu-id="a29c7-487">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="a29c7-488">Jeśli `S` nie jest `SX`, zostanie przeprowadzona standardowa niejawna konwersja z `S` na `SX`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-488">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="a29c7-489">Najbardziej specyficzny Operator konwersji jest wywoływany do konwersji z `SX` na `TX`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-489">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="a29c7-490">Jeśli `TX` nie jest `T`, zostanie przeprowadzona standardowa niejawna konwersja z `TX` na `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-490">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="a29c7-491">Przetwarzanie konwersji jawnych zdefiniowanych przez użytkownika</span><span class="sxs-lookup"><span data-stu-id="a29c7-491">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="a29c7-492">Jawna konwersja zdefiniowana przez użytkownika z typu `S` na typ `T` jest przetwarzana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a29c7-492">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="a29c7-493">Określ typy `S0` i `T0`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-493">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="a29c7-494">Jeśli `S` lub `T` mają Typy dopuszczające wartość null, `S0` i `T0` są ich typami podstawowymi, w przeciwnym razie `S0` i `T0` są równe odpowiednio `S` i `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-494">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="a29c7-495">Znajdź zestaw typów, `D`, z których będą rozpatrywane operatory konwersji zdefiniowane przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a29c7-495">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="a29c7-496">Ten zestaw składa się z `S0` (jeśli `S0` jest klasą lub strukturą), klasy bazowe `S0` (jeśli `S0` jest klasą), `T0` (jeśli `T0` jest klasą lub strukturą), a klasy bazowe `T0` (jeśli `T0` jest klasą).</span><span class="sxs-lookup"><span data-stu-id="a29c7-496">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="a29c7-497">Znajdź zestaw odpowiednich operatorów konwersji zdefiniowanych przez użytkownika i podnoszenia, `U`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-497">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="a29c7-498">Ten zestaw składa się z zdefiniowanych przez użytkownika i podnoszenia niejawnych lub jawnych operatorów konwersji zadeklarowanych przez klasy lub struktury w `D`, które konwertują z typu obejmującego lub ponoszące `S` do typu, który obejmuje lub podano przez `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-498">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="a29c7-499">Jeśli `U` jest pusty, konwersja jest niezdefiniowana i wystąpi błąd podczas kompilowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-499">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-500">Znajdź najbardziej konkretny typ źródła, `SX`w `U`operatory:</span><span class="sxs-lookup"><span data-stu-id="a29c7-500">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="a29c7-501">Jeśli którykolwiek z operatorów w `U` skonwertować z `S`, `SX` `S`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-501">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="a29c7-502">W przeciwnym razie, jeśli którykolwiek z operatorów w `U` konwertować z typów, które obejmują `S`, `SX` jest najbardziej połączoną typu w połączonym zestawie typów źródłowych tych operatorów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-502">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="a29c7-503">Jeśli nie można znaleźć typu z większością typów, konwersja jest niejednoznaczna i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-503">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="a29c7-504">W przeciwnym razie `SX` to najbardziej obejmujący typ w połączonym zestawie typów źródłowych operatorów w `U`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-504">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="a29c7-505">Jeśli nie można znaleźć dokładnie jednego typu, który nie zawiera, konwersja jest niejednoznaczna i wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-505">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-506">Znajdź najbardziej konkretny typ docelowy, `TX`w `U`operatory:</span><span class="sxs-lookup"><span data-stu-id="a29c7-506">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="a29c7-507">Jeśli którykolwiek z operatorów w `U` skonwertować na `T`, `TX` `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-507">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="a29c7-508">W przeciwnym razie, jeśli którykolwiek z operatorów w `U` skonwertować na typy, które są objęte `T`, wówczas `TX` to najbardziej obejmujący typ w połączonym zestawie typów docelowych tych operatorów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-508">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="a29c7-509">Jeśli nie można znaleźć dokładnie jednego typu, który nie zawiera, konwersja jest niejednoznaczna i wystąpi błąd kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-509">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="a29c7-510">W przeciwnym razie `TX` jest najbardziej powiązanego typu w połączonym zestawie typów docelowych operatorów w `U`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-510">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="a29c7-511">Jeśli nie można znaleźć typu z większością typów, konwersja jest niejednoznaczna i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-511">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-512">Znajdź najbardziej specyficzny Operator konwersji:</span><span class="sxs-lookup"><span data-stu-id="a29c7-512">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="a29c7-513">Jeśli `U` zawiera dokładnie jeden operator konwersji zdefiniowany przez użytkownika, który konwertuje z `SX` na `TX`, to jest to najbardziej specyficzny Operator konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-513">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="a29c7-514">W przeciwnym razie, jeśli `U` zawiera dokładnie jeden podnieśny Operator konwersji, który konwertuje z `SX` na `TX`, to jest to najbardziej konkretny Operator konwersji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-514">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="a29c7-515">W przeciwnym razie konwersja jest niejednoznaczna i wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-515">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-516">Na koniec zastosuj konwersję:</span><span class="sxs-lookup"><span data-stu-id="a29c7-516">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="a29c7-517">Jeśli `S` nie jest `SX`, zostanie przeprowadzona standardowa jawna konwersja z `S` do `SX`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-517">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="a29c7-518">Najbardziej szczegółowy zdefiniowany przez użytkownika Operator konwersji jest wywoływany do konwersji z `SX` na `TX`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-518">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="a29c7-519">Jeśli `TX` nie jest `T`, zostanie przeprowadzona standardowa jawna konwersja z `TX` do `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-519">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="a29c7-520">Konwersje funkcji anonimowych</span><span class="sxs-lookup"><span data-stu-id="a29c7-520">Anonymous function conversions</span></span>

<span data-ttu-id="a29c7-521">*Anonymous_method_expression* lub *lambda_expression* są klasyfikowane jako funkcja anonimowa ([wyrażenia funkcji anonimowych](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-521">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="a29c7-522">Wyrażenie nie ma typu, ale może być niejawnie konwertowane na zgodny typ delegata lub typ drzewa wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-522">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="a29c7-523">W specjalnej postaci funkcja anonimowa `F` jest zgodna z typem delegata `D` udostępnionym:</span><span class="sxs-lookup"><span data-stu-id="a29c7-523">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="a29c7-524">Jeśli `F` zawiera *anonymous_function_signature*, `D` i `F` mają taką samą liczbę parametrów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-524">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="a29c7-525">Jeśli `F` nie zawiera *anonymous_function_signature*, `D` mogą mieć zero lub więcej parametrów dowolnego typu, o ile żaden parametr elementu `D` ma modyfikator parametru `out`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-525">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="a29c7-526">Jeśli `F` ma jawnie wpisaną listę parametrów, każdy parametr w `D` ma ten sam typ i Modyfikatory co odpowiedni parametr w `F`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-526">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="a29c7-527">Jeśli `F` zawiera niejawnie wpisaną listę parametrów, `D` nie ma `ref` lub `out` parametrów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-527">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="a29c7-528">Jeśli treść `F` jest wyrażeniem, a `D` ma `void` typem zwracanym lub `F` jest Async i `D` ma typ zwracany `Task`, wtedy gdy każdy parametr z `F` ma typ odpowiadającego parametru w `D`, treść `F` jest prawidłowym wyrażeniem ( [wyrażenia](expressions.md)WRT), które byłyby dozwolone jako *statement_expression* ([instrukcje wyrażeń](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-528">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="a29c7-529">Jeśli treść `F` jest blokiem instrukcji, a `D` ma `void` typem zwracanym lub `F` jest Async, a `D` ma zwracany typ `Task`, wtedy gdy każdy parametr z `F` ma typ odpowiadającego parametru w `D`, treść `F` jest prawidłowym blokiem instrukcji (WRT [Blocks](statements.md#blocks)), w którym żadna instrukcja `return` nie określa wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-529">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="a29c7-530">Jeśli treść `F` jest wyrażeniem, *a `F` jest* nieasynchroniczna i `D` ma typ zwracany inny niż void `T`*lub* `F` jest Async i `D` ma typ zwracany `Task<T>`, wtedy gdy każdy parametr z `F` ma typ odpowiadającego parametru w `D`, treść `F` jest prawidłowym wyrażeniem [(WRT](expressions.md)Expressions), które jest niejawnie konwertowane na `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-530">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="a29c7-531">Jeśli treść `F` jest blokiem instrukcji, *a `F` nie jest Async i `D`* ma typ zwracany inny niż void `T`, *lub* `F` jest Async i `D` ma typ zwracany `Task<T>`, a następnie, gdy każdy parametr `F` ma typ odpowiadającego parametru w `D`, treść `F` jest prawidłowym blokiem instrukcji ( [bloki](statements.md#blocks)WRT) z nieosiągalnym punktem końcowym, w którym każda instrukcja `return` określa wyrażenie, które jest niejawnie konwertowane na `T`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-531">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="a29c7-532">Na potrzeby zwięzłości Ta sekcja używa krótkiej formy typów zadań `Task` i `Task<T>` ([funkcje asynchroniczne](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-532">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="a29c7-533">Wyrażenie lambda `F` jest zgodne z typem drzewa wyrażenia `Expression<D>`, jeśli `F` jest zgodne z typem delegata `D`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-533">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="a29c7-534">Należy zauważyć, że nie dotyczy to metod anonimowych, tylko wyrażeń lambda.</span><span class="sxs-lookup"><span data-stu-id="a29c7-534">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="a29c7-535">Niektóre wyrażenia lambda nie mogą być konwertowane na typy drzewa wyrażeń: nawet jeśli konwersja *istnieje*, kończy się niepowodzeniem w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-535">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="a29c7-536">Dzieje się tak, jeśli wyrażenie lambda:</span><span class="sxs-lookup"><span data-stu-id="a29c7-536">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="a29c7-537">Ma treść *bloku*</span><span class="sxs-lookup"><span data-stu-id="a29c7-537">Has a *block* body</span></span>
*  <span data-ttu-id="a29c7-538">Zawiera proste lub złożone operatory przypisania</span><span class="sxs-lookup"><span data-stu-id="a29c7-538">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="a29c7-539">Zawiera dynamiczne wyrażenie powiązane</span><span class="sxs-lookup"><span data-stu-id="a29c7-539">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="a29c7-540">Jest asynchroniczny</span><span class="sxs-lookup"><span data-stu-id="a29c7-540">Is async</span></span>

<span data-ttu-id="a29c7-541">Poniższe przykłady używają ogólnego typu delegata `Func<A,R>`, który reprezentuje funkcję, która przyjmuje argument typu `A` i zwraca wartość typu `R`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-541">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="a29c7-542">W przypisaniach</span><span class="sxs-lookup"><span data-stu-id="a29c7-542">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="a29c7-543">parametry i zwracane typy każdej funkcji anonimowej są określane na podstawie typu zmiennej, do której jest przypisana funkcja anonimowa.</span><span class="sxs-lookup"><span data-stu-id="a29c7-543">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="a29c7-544">Pierwsze przypisanie pomyślnie konwertuje funkcję anonimową na typ delegata `Func<int,int>` ponieważ, gdy `x` jest określony typ `int`, `x+1` jest prawidłowym wyrażeniem, które jest niejawnie konwertowane na typ `int`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-544">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="a29c7-545">Podobnie drugie przypisanie pomyślnie konwertuje funkcję anonimową na typ delegata `Func<int,double>`, ponieważ wynik `x+1` (typu `int`) jest niejawnie konwertowany na typ `double`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-545">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="a29c7-546">Jednak trzecie przypisanie jest błędem czasu kompilacji, ponieważ w przypadku `x` danego typu `double`, wynik `x+1` (typu `double`) nie jest niejawnie konwertowany na typ `int`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-546">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="a29c7-547">Czwarte przypisanie pomyślnie konwertuje anonimową funkcję asynchroniczną na typ delegata `Func<int, Task<int>>`, ponieważ wynik `x+1` (typu `int`) jest niejawnie konwertowany na typ wyniku `int` typu zadania `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-547">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="a29c7-548">Funkcje anonimowe mogą mieć wpływ na rozwiązanie przeciążania i uczestniczyć w wnioskach o typie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-548">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="a29c7-549">Aby uzyskać więcej informacji, zobacz [elementy członkowskie funkcji](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="a29c7-549">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="a29c7-550">Obliczanie konwersji funkcji anonimowych na typy delegatów</span><span class="sxs-lookup"><span data-stu-id="a29c7-550">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="a29c7-551">Konwersja funkcji anonimowej na typ delegata tworzy wystąpienie delegata, które odwołuje się do funkcji anonimowej i (prawdopodobnie puste) zestaw przechwyconych zmiennych zewnętrznych, które są aktywne w czasie szacowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-551">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="a29c7-552">Gdy obiekt delegowany jest wywoływany, jest wykonywana treść funkcji anonimowej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-552">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="a29c7-553">Kod w treści jest wykonywany przy użyciu zestawu przechwyconych zmiennych zewnętrznych, do których odwołuje się delegat.</span><span class="sxs-lookup"><span data-stu-id="a29c7-553">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="a29c7-554">Lista wywołań delegata utworzonego na podstawie funkcji anonimowej zawiera pojedynczy wpis.</span><span class="sxs-lookup"><span data-stu-id="a29c7-554">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="a29c7-555">Nie określono dokładnego obiektu docelowego i docelowej metody delegata.</span><span class="sxs-lookup"><span data-stu-id="a29c7-555">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="a29c7-556">W szczególności nie określono, czy obiekt docelowy delegata jest `null`, `this` wartość elementu członkowskiego otaczającej funkcji lub innego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-556">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="a29c7-557">Konwersje semantycznie identycznych funkcji anonimowych z tym samym (prawdopodobnie pustym) zestawem przechwyconych wystąpień zmiennych zewnętrznych do tych samych typów delegatów są dozwolone (ale nie są wymagane) do zwrócenia tego samego wystąpienia delegata.</span><span class="sxs-lookup"><span data-stu-id="a29c7-557">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="a29c7-558">Termin o wartości semantycznie jest używany w tym miejscu do oznaczania, że wykonanie funkcji anonimowych będzie we wszystkich przypadkach dawać te same skutki mające te same argumenty.</span><span class="sxs-lookup"><span data-stu-id="a29c7-558">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="a29c7-559">Ta reguła umożliwia zoptymalizowanie kodu, takiego jak poniższe.</span><span class="sxs-lookup"><span data-stu-id="a29c7-559">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="a29c7-560">Ponieważ dwie Delegaty funkcji anonimowych mają ten sam (pusty) zbiór przechwyconych zmiennych zewnętrznych i ponieważ funkcje anonimowe są semantycznie identyczne, kompilator może odwoływać się do tej samej metody docelowej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-560">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="a29c7-561">W rzeczywistości kompilator może zwrócić to samo wystąpienie delegata z obu wyrażeń funkcji anonimowej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-561">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="a29c7-562">Obliczanie konwersji funkcji anonimowych na typy drzewa wyrażeń</span><span class="sxs-lookup"><span data-stu-id="a29c7-562">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="a29c7-563">Konwersja funkcji anonimowej na typ drzewa wyrażenia tworzy drzewo wyrażenia ([Typy drzewa wyrażeń](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-563">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="a29c7-564">Dokładniejsze Obliczanie konwersji funkcji anonimowych prowadzi do konstrukcji struktury obiektu, która reprezentuje strukturę samej funkcji anonimowej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-564">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="a29c7-565">Precyzyjna struktura drzewa wyrażenia, a także dokładny proces tworzenia go, to implementacja zdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="a29c7-565">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="a29c7-566">Przykład implementacji</span><span class="sxs-lookup"><span data-stu-id="a29c7-566">Implementation example</span></span>

<span data-ttu-id="a29c7-567">W tej sekcji opisano możliwe implementację konwersji funkcji anonimowych w warunkach innych C# konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-567">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="a29c7-568">Opisana tutaj implementacja opiera się na tych samych zasadach, które są używane przez C# kompilator firmy Microsoft, ale nie oznacza to, że jest to dozwolone wdrożenie, ani nie jest jedynym możliwym z nich.</span><span class="sxs-lookup"><span data-stu-id="a29c7-568">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="a29c7-569">Zawiera krótkie informacje tylko o konwersjach na drzewa wyrażeń, ponieważ ich dokładna semantyka wykracza poza zakres tej specyfikacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-569">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="a29c7-570">W pozostałej części tej sekcji przedstawiono kilka przykładów kodu, który zawiera anonimowe funkcje o różnych właściwościach.</span><span class="sxs-lookup"><span data-stu-id="a29c7-570">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="a29c7-571">Dla każdego przykładu podano odpowiednie tłumaczenie dla kodu, który używa C# tylko innych konstrukcji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-571">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="a29c7-572">W przykładach identyfikator `D` jest uznawany za reprezentujący następujący typ delegata:</span><span class="sxs-lookup"><span data-stu-id="a29c7-572">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="a29c7-573">Najprostsza forma funkcji anonimowej to taka, która nie przechwytuje żadnych zmiennych zewnętrznych:</span><span class="sxs-lookup"><span data-stu-id="a29c7-573">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="a29c7-574">Można to przetłumaczyć na wystąpienie delegata, który odwołuje się do metody statycznej wygenerowanej przez kompilator, w której umieszczony jest kod funkcji anonimowej:</span><span class="sxs-lookup"><span data-stu-id="a29c7-574">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="a29c7-575">W poniższym przykładzie funkcja anonimowa odwołuje się do członków wystąpienia `this`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-575">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="a29c7-576">Można to przetłumaczyć na metodę wystąpienia wygenerowanego przez kompilator zawierający kod funkcji anonimowej:</span><span class="sxs-lookup"><span data-stu-id="a29c7-576">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="a29c7-577">W tym przykładzie funkcja anonimowa przechwytuje zmienną lokalną:</span><span class="sxs-lookup"><span data-stu-id="a29c7-577">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="a29c7-578">Okres istnienia zmiennej lokalnej musi zostać przedłużony do co najmniej okresu istnienia delegata funkcji anonimowej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-578">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="a29c7-579">Można to osiągnąć przez "podnoszenia" zmiennej lokalnej do pola klasy wygenerowanej przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="a29c7-579">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="a29c7-580">Utworzenie wystąpienia zmiennej lokalnej (utworzenie wystąpienia[zmiennych lokalnych](expressions.md#instantiation-of-local-variables)) odpowiada za utworzenie wystąpienia klasy wygenerowanej przez kompilator i uzyskanie dostępu do zmiennej lokalnej odpowiada na dostęp do pola w wystąpieniu klasy wygenerowanej przez kompilator.</span><span class="sxs-lookup"><span data-stu-id="a29c7-580">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="a29c7-581">Ponadto funkcja anonimowa jest metodą wystąpienia klasy wygenerowanej przez kompilator:</span><span class="sxs-lookup"><span data-stu-id="a29c7-581">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="a29c7-582">Na koniec następująca funkcja anonimowa przechwytuje `this` a także dwie zmienne lokalne o różnych okresach istnienia:</span><span class="sxs-lookup"><span data-stu-id="a29c7-582">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="a29c7-583">W tym przykładzie Klasa wygenerowana przez kompilator jest tworzona dla każdego bloku instrukcji, w którym są przechwytywane elementy lokalne, tak że lokalne w różnych blokach mogą mieć niezależne okresy istnienia.</span><span class="sxs-lookup"><span data-stu-id="a29c7-583">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="a29c7-584">Wystąpienie `__Locals2`, Klasa wygenerowana przez kompilator dla wewnętrznego bloku instrukcji, zawiera zmienną lokalną `z` i pole odwołujące się do wystąpienia `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-584">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="a29c7-585">Wystąpienie `__Locals1`, Klasa wygenerowana przez kompilator dla bloku instrukcji zewnętrznych, zawiera zmienną lokalną `y` i pole, które odwołuje się do `this` otaczającego elementu członkowskiego funkcji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-585">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="a29c7-586">Dzięki tym strukturom danych możliwe jest dotarcie do wszystkich przechwyconych zmiennych zewnętrznych za pomocą wystąpienia `__Local2`, a kod funkcji anonimowej może zostać zaimplementowany jako metoda wystąpienia tej klasy.</span><span class="sxs-lookup"><span data-stu-id="a29c7-586">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="a29c7-587">Ta sama technika zastosowana w tym miejscu do przechwytywania zmiennych lokalnych może być również używana podczas konwertowania funkcji anonimowych na drzewa wyrażeń: odwołania do obiektów generowanych przez kompilator mogą być przechowywane w drzewie wyrażenia, a dostęp do zmiennych lokalnych może być reprezentowane jako dostęp do pól dla tych obiektów.</span><span class="sxs-lookup"><span data-stu-id="a29c7-587">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="a29c7-588">Zaletą tego podejścia jest umożliwienie współdzielenia "podnoszenia" zmiennych lokalnych między delegatami i drzewami wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="a29c7-588">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="a29c7-589">Konwersje grup metod</span><span class="sxs-lookup"><span data-stu-id="a29c7-589">Method group conversions</span></span>

<span data-ttu-id="a29c7-590">Niejawna konwersja ([niejawne konwersje](conversions.md#implicit-conversions)) istnieje z grupy metod ([klasyfikacje wyrażeń](expressions.md#expression-classifications)) do zgodnego typu delegata.</span><span class="sxs-lookup"><span data-stu-id="a29c7-590">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="a29c7-591">Uwzględniając typ delegata `D` i wyrażenie `E`, które jest sklasyfikowane jako grupa metod, niejawna konwersja istnieje z `E` do `D`, jeśli `E` zawiera co najmniej jedną metodę, która jest stosowana w jej normalnej formie ([odpowiedni element członkowski funkcji](expressions.md#applicable-function-member)) do listy argumentów skonstruowanej przy użyciu typów parametrów i modyfikatorów `D`, zgodnie z opisem w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="a29c7-591">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="a29c7-592">Aplikacja czasu kompilowania konwersji z grupy metod `E` do typu delegata `D` została opisana w poniższej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-592">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="a29c7-593">Należy zauważyć, że istnienie niejawnej konwersji z `E` na `D` nie gwarantuje, że konwersja aplikacji w czasie kompilacji zakończy się powodzeniem bez błędu.</span><span class="sxs-lookup"><span data-stu-id="a29c7-593">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="a29c7-594">Wybrano jedną metodę `M` odpowiadającą wywołaniu metody ([wywołania metody](expressions.md#method-invocations)) `E(A)`formularza, z następującymi modyfikacjami:</span><span class="sxs-lookup"><span data-stu-id="a29c7-594">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="a29c7-595">Lista argumentów `A` jest listą wyrażeń, z których każda została sklasyfikowana jako zmienna i z typem i modyfikatorem (`ref` lub `out`) odpowiedniego parametru w *formal_parameter_list* `D`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-595">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="a29c7-596">Metody kandydata są brane pod uwagę tylko te metody, które są stosowane w ich normalnej formie ([element członkowski funkcji](expressions.md#applicable-function-member)), a nie tylko w ich rozwiniętej postaci.</span><span class="sxs-lookup"><span data-stu-id="a29c7-596">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="a29c7-597">Jeśli algorytm [wywołań metod](expressions.md#method-invocations) wywołuje błąd, wystąpi błąd czasu kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-597">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="a29c7-598">W przeciwnym razie algorytm tworzy jedną najlepszą metodę `M` ma taką samą liczbę parametrów jak `D`, a konwersja jest uznawana za istnieje.</span><span class="sxs-lookup"><span data-stu-id="a29c7-598">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="a29c7-599">Wybrana metoda `M` musi być zgodna ([zgodność z delegatem](delegates.md#delegate-compatibility)) z typem delegata `D`lub w przeciwnym razie wystąpi błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a29c7-599">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="a29c7-600">Jeśli wybrana metoda `M` jest metodą wystąpienia, wyrażenie wystąpienia skojarzone z `E` określa obiekt docelowy delegata.</span><span class="sxs-lookup"><span data-stu-id="a29c7-600">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="a29c7-601">Jeśli wybrana metoda M jest metodą rozszerzenia, która jest oznaczona za pomocą dostępu do elementu członkowskiego w wyrażeniu wystąpienia, to wyrażenie wystąpienia określa obiekt docelowy delegata.</span><span class="sxs-lookup"><span data-stu-id="a29c7-601">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="a29c7-602">Wynikiem konwersji jest wartość typu `D`, a mianowicie nowo utworzonego delegata, który odwołuje się do wybranej metody i obiektu docelowego.</span><span class="sxs-lookup"><span data-stu-id="a29c7-602">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="a29c7-603">Należy zauważyć, że ten proces może prowadzić do utworzenia delegata metody rozszerzenia, jeśli algorytm [wywołania metody](expressions.md#method-invocations) nie może znaleźć metody wystąpienia, ale kończy przetwarzanie wywołania `E(A)` jako wywołanie metody rozszerzenia ([wywołania metody rozszerzenia](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="a29c7-603">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="a29c7-604">Delegat utworzony w ten sposób przechwytuje również metodę rozszerzenia oraz jej pierwszy argument.</span><span class="sxs-lookup"><span data-stu-id="a29c7-604">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="a29c7-605">Poniższy przykład ilustruje konwersje grup metod:</span><span class="sxs-lookup"><span data-stu-id="a29c7-605">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="a29c7-606">Przypisanie do `d1` niejawnie konwertuje `F` grupy metod na wartość typu `D1`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-606">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="a29c7-607">Przypisanie do `d2` pokazuje, jak można utworzyć delegata do metody, która ma mniej pochodne typy parametrów (kontrawariantne) i bardziej pochodny typ zwracany (współvariant).</span><span class="sxs-lookup"><span data-stu-id="a29c7-607">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="a29c7-608">Przypisanie do `d3` pokazuje, jak taka konwersja nie istnieje, jeśli metoda nie ma zastosowania.</span><span class="sxs-lookup"><span data-stu-id="a29c7-608">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="a29c7-609">Przypisanie do `d4` pokazuje, jak metoda musi być stosowana w jego normalnej postaci.</span><span class="sxs-lookup"><span data-stu-id="a29c7-609">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="a29c7-610">Przypisanie do `d5` pokazuje, jak parametry i zwracane typy delegata i metody mogą się różnić tylko dla typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="a29c7-610">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="a29c7-611">Podobnie jak w przypadku wszystkich innych konwersji niejawnych i jawnych, operator rzutowania może służyć do jawnego wykonania konwersji grup metod.</span><span class="sxs-lookup"><span data-stu-id="a29c7-611">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="a29c7-612">W tym przykładzie przykład</span><span class="sxs-lookup"><span data-stu-id="a29c7-612">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="a29c7-613">Zamiast tego może być zapisany</span><span class="sxs-lookup"><span data-stu-id="a29c7-613">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="a29c7-614">Grupy metod mogą mieć wpływ na rozwiązanie przeciążania i uczestniczyć w wnioskach o typie.</span><span class="sxs-lookup"><span data-stu-id="a29c7-614">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="a29c7-615">Aby uzyskać więcej informacji, zobacz [elementy członkowskie funkcji](expressions.md#function-members) .</span><span class="sxs-lookup"><span data-stu-id="a29c7-615">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="a29c7-616">Obliczanie w czasie wykonywania konwersji grup metod odbywa się w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a29c7-616">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="a29c7-617">Jeśli metoda wybrana w czasie kompilacji to metoda wystąpienia lub jest to metoda rozszerzająca, do której można uzyskać dostęp jako metoda wystąpienia, obiekt docelowy delegata jest określany na podstawie wyrażenia wystąpienia skojarzonego z `E`:</span><span class="sxs-lookup"><span data-stu-id="a29c7-617">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="a29c7-618">Wyrażenie wystąpienia jest oceniane.</span><span class="sxs-lookup"><span data-stu-id="a29c7-618">The instance expression is evaluated.</span></span> <span data-ttu-id="a29c7-619">Jeśli ta Ocena spowoduje wyjątek, nie są wykonywane żadne dalsze kroki.</span><span class="sxs-lookup"><span data-stu-id="a29c7-619">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="a29c7-620">Jeśli wyrażenie wystąpienia ma *reference_type*, wartość obliczona przez wyrażenie wystąpienia zostaje obiektem docelowym.</span><span class="sxs-lookup"><span data-stu-id="a29c7-620">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="a29c7-621">Jeśli wybrana metoda jest metodą wystąpienia, a obiekt docelowy jest `null`, zostanie zgłoszony `System.NullReferenceException` i nie są wykonywane żadne dalsze kroki.</span><span class="sxs-lookup"><span data-stu-id="a29c7-621">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="a29c7-622">Jeśli wyrażenie wystąpienia ma *value_type*, operacja pakowania ([konwersje z opakowania](types.md#boxing-conversions)) jest wykonywana w celu przekonwertowania wartości na obiekt, a obiekt ten zostaje obiektem docelowym.</span><span class="sxs-lookup"><span data-stu-id="a29c7-622">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="a29c7-623">W przeciwnym razie wybrana metoda jest częścią wywołania metody statycznej, a obiekt docelowy delegata jest `null`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-623">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="a29c7-624">Zostanie przydzielono nowe wystąpienie typu delegata `D`.</span><span class="sxs-lookup"><span data-stu-id="a29c7-624">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="a29c7-625">Jeśli nie ma wystarczającej ilości pamięci do przydzielenia nowego wystąpienia, zostanie zgłoszony `System.OutOfMemoryException` i nie są wykonywane żadne dalsze kroki.</span><span class="sxs-lookup"><span data-stu-id="a29c7-625">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="a29c7-626">Nowe wystąpienie delegata jest inicjowane z odwołaniem do metody, która została określona w czasie kompilacji i odwołaniem do obiektu docelowego obliczonego powyżej.</span><span class="sxs-lookup"><span data-stu-id="a29c7-626">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
