---
ms.openlocfilehash: b7bb7dd575d9e2e6d5dd85bdd3e535411e29fcf4
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/25/2019
ms.locfileid: "64488864"
---
# <a name="variables"></a><span data-ttu-id="d51bf-101">Zmienne</span><span class="sxs-lookup"><span data-stu-id="d51bf-101">Variables</span></span>

<span data-ttu-id="d51bf-102">Zmienne reprezentują lokalizacje przechowywania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-102">Variables represent storage locations.</span></span> <span data-ttu-id="d51bf-103">Co zmienna ma typ, który określa, jakie wartości mogą być przechowywane w zmiennej.</span><span class="sxs-lookup"><span data-stu-id="d51bf-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="d51bf-104">C# to język bezpieczny i kompilator języka C# gwarantuje, że wartości przechowywane w zmiennych są zawsze odpowiedniego typu.</span><span class="sxs-lookup"><span data-stu-id="d51bf-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="d51bf-105">Wartość zmiennej można zmienić za pośrednictwem przydziału lub za pośrednictwem `++` i `--` operatorów.</span><span class="sxs-lookup"><span data-stu-id="d51bf-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="d51bf-106">Zmienna musi być ***zdecydowanie przypisywany*** ([asercję określonego przypisania](variables.md#definite-assignment)) przed jej wartość można uzyskać.</span><span class="sxs-lookup"><span data-stu-id="d51bf-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="d51bf-107">Zgodnie z opisem w poniższych sekcjach, zmienne są ***przypisane początkowo*** lub ***początkowo nieprzypisane***.</span><span class="sxs-lookup"><span data-stu-id="d51bf-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="d51bf-108">Początkowo przypisanej zmiennej ma dobrze zdefiniowanych wartości początkowej i zawsze jest uznawany za zdecydowanie przypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="d51bf-109">Początkowo nieprzypisanej zmiennej nie ma początkowej wartości.</span><span class="sxs-lookup"><span data-stu-id="d51bf-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="d51bf-110">Początkowo nieprzypisane zmiennej wziąć pod uwagę zdecydowanie przypisane w określonej lokalizacji przypisania do zmiennej musi występować w każdej ścieżce możliwe wykonanie, co prowadzi do tej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="d51bf-111">Kategorie zmiennej</span><span class="sxs-lookup"><span data-stu-id="d51bf-111">Variable categories</span></span>

<span data-ttu-id="d51bf-112">Język C# definiuje siedem kategorii zmiennych: zmiennych statycznych, zmienne wystąpienia, elementy tablicy, wartości parametrów, parametrów w formie odwołań, parametry wyjściowe i zmiennych lokalnych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="d51bf-113">W kolejnych sekcjach opisano każdy z tych kategorii.</span><span class="sxs-lookup"><span data-stu-id="d51bf-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="d51bf-114">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="d51bf-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="d51bf-115">`x` Zmienna statyczna jest `y` jest zmienną instance `v[0]` jest element tablicy `a` jest wartość parametru, `b` jest parametr przekazany przez odwołanie, `c` jest parametrem wyjściowym i `i` jest zmienną lokalną.</span><span class="sxs-lookup"><span data-stu-id="d51bf-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="d51bf-116">Zmienne statyczne</span><span class="sxs-lookup"><span data-stu-id="d51bf-116">Static variables</span></span>

<span data-ttu-id="d51bf-117">Pole jest zadeklarowane za pomocą `static` nosi nazwę modyfikator ***zmienna statyczna***.</span><span class="sxs-lookup"><span data-stu-id="d51bf-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="d51bf-118">Zmienna statyczna trafia do istnienia przed wykonaniem konstruktora statycznego ([konstruktorów statycznych](classes.md#static-constructors)) jego zawierający typ i przestaje istnieć, gdy domena skojarzona aplikacja przestanie istnieć.</span><span class="sxs-lookup"><span data-stu-id="d51bf-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="d51bf-119">Początkowa wartość Zmienna statyczna jest wartością domyślną ([wartości domyślne](variables.md#default-values)) typu zmiennej.</span><span class="sxs-lookup"><span data-stu-id="d51bf-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="d51bf-120">Do celów sprawdzania asercję określonego przypisania zmienna statyczna jest uznawany za początkowo przypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="d51bf-121">Zmienne wystąpienia</span><span class="sxs-lookup"><span data-stu-id="d51bf-121">Instance variables</span></span>

<span data-ttu-id="d51bf-122">Pole zadeklarowana bez `static` nosi nazwę modyfikator ***zmienną instance***.</span><span class="sxs-lookup"><span data-stu-id="d51bf-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="d51bf-123">Zmienne wystąpienia klas</span><span class="sxs-lookup"><span data-stu-id="d51bf-123">Instance variables in classes</span></span>

<span data-ttu-id="d51bf-124">Zmiennej wystąpienia klasy trafia do istnienia, nowe wystąpienie tej klasy jest tworzona, gdy przestanie istnieć, gdy nie ma żadnych odwołań do tego wystąpienia i destruktor wystąpienia (jeśli istnieje) zostanie wykonany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="d51bf-125">Początkowa wartość zmiennej wystąpienia klasy jest wartością domyślną ([wartości domyślne](variables.md#default-values)) typu zmiennej.</span><span class="sxs-lookup"><span data-stu-id="d51bf-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="d51bf-126">Na potrzeby sprawdzania, asercja określonego przydziału, zmiennej wystąpienia klasy jest uważany za początkowo przypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="d51bf-127">Zmienne wystąpienia w strukturach</span><span class="sxs-lookup"><span data-stu-id="d51bf-127">Instance variables in structs</span></span>

<span data-ttu-id="d51bf-128">Zmienną instance struktury ma dokładnie ten sam okres istnienia jako zmiennej struktury, do której należy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="d51bf-129">Innymi słowy, gdy zmienną typu struktury trafia do istnienia lub przestaje istnieć, więc zbyt czy zmienne wystąpienia struktury.</span><span class="sxs-lookup"><span data-stu-id="d51bf-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="d51bf-130">Stan początkowego przydziału zmienną instance struktury jest taka sama jak zawierającego zmiennej struktury.</span><span class="sxs-lookup"><span data-stu-id="d51bf-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="d51bf-131">Innymi słowy, po zmiennej struktury jest uznawany za początkowo przypisane, więc za jego zmienne wystąpienia i po zmiennej struktury jest uznawany za początkowo nieprzypisane, jego zmienne wystąpienia są podobnie nieprzypisane.</span><span class="sxs-lookup"><span data-stu-id="d51bf-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="d51bf-132">Elementy tablicy</span><span class="sxs-lookup"><span data-stu-id="d51bf-132">Array elements</span></span>

<span data-ttu-id="d51bf-133">Elementy tablicy rozpoczęciu istnienie, gdy tworzone jest wystąpienie tablicy i przestaną istnieć, gdy istnieją żadnych odwołań do tego wystąpienia tablicy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="d51bf-134">Początkowa wartość każdego z elementów tablicy jest wartością domyślną ([wartości domyślne](variables.md#default-values)) typ elementów tablicy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="d51bf-135">Na potrzeby sprawdzania, asercja określonego przydziału, do elementu tablicy jest uważany za początkowo przypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="d51bf-136">Wartości parametrów</span><span class="sxs-lookup"><span data-stu-id="d51bf-136">Value parameters</span></span>

<span data-ttu-id="d51bf-137">Parametr zadeklarowana bez `ref` lub `out` modyfikator jest ***wartość parametru***.</span><span class="sxs-lookup"><span data-stu-id="d51bf-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="d51bf-138">Wartość parametru trafia do istnienia na wywołanie funkcji elementu członkowskiego, (metody, konstruktora wystąpienia, metody dostępu lub operator) lub funkcja anonimowa do których parametr należy i jest inicjowany z wartością argumentu wywołania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="d51bf-139">Parametr wartości zwykle przestanie istnieć po powrocie funkcja składowa lub funkcja anonimowa.</span><span class="sxs-lookup"><span data-stu-id="d51bf-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="d51bf-140">Jednakże jeśli parametr wartości są przechwytywane przez funkcję anonimową ([wyrażenia funkcji anonimowych](expressions.md#anonymous-function-expressions)), jego okres istnienia co najmniej rozszerza aż delegat lub drzewa wyrażeń utworzone na podstawie tego funkcja anonimowa kwalifikuje się do wyrzucanie elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="d51bf-141">Na potrzeby sprawdzania, asercja określonego przydziału, parametr wartości jest uważany za początkowo przypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="d51bf-142">Parametry odwołania</span><span class="sxs-lookup"><span data-stu-id="d51bf-142">Reference parameters</span></span>

<span data-ttu-id="d51bf-143">Parametr zadeklarowana za pomocą `ref` modyfikator jest ***odwołać się do parametru***.</span><span class="sxs-lookup"><span data-stu-id="d51bf-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="d51bf-144">Parametr przekazany przez odwołanie, nie powoduje utworzenia nowej lokalizacji magazynu.</span><span class="sxs-lookup"><span data-stu-id="d51bf-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="d51bf-145">Zamiast tego parametru odwołania reprezentuje tę samą lokalizację magazynu zmienna, podane jako argument w funkcji składowej lub wywołania funkcji anonimowych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="d51bf-146">W związku z tym wartość parametru odwołania jest zawsze taki sam, jako zmienna bazowego.</span><span class="sxs-lookup"><span data-stu-id="d51bf-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="d51bf-147">Asercja określonego przydziału obowiązują następujące reguły do parametrów odwołania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="d51bf-148">Należy pamiętać, różne reguły dla parametrów wyjściowych, które opisano w [parametrów wyjściowych](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="d51bf-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="d51bf-149">Zmienna musi zostać zdecydowanie przypisany ([asercję określonego przypisania](variables.md#definite-assignment)) zanim może być przekazywany jako parametr w wywołaniu funkcji elementu członkowskiego lub delegata przekazany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="d51bf-150">Funkcja składowa lub funkcja anonimowa parametr przekazany przez odwołanie jest traktowany jako wstępnie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="d51bf-151">Wewnątrz metody wystąpienia lub metoda dostępu do wystąpienia typu struktury `this` — słowo kluczowe zachowuje się dokładnie tak jak parametr typu struktury przekazany przez odwołanie ([dostęp](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="d51bf-152">Parametry wyjściowe</span><span class="sxs-lookup"><span data-stu-id="d51bf-152">Output parameters</span></span>

<span data-ttu-id="d51bf-153">Parametr zadeklarowana za pomocą `out` modyfikator jest ***parametr wyjściowy***.</span><span class="sxs-lookup"><span data-stu-id="d51bf-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="d51bf-154">Parametr wyjściowy nie powoduje utworzenia nowej lokalizacji magazynu.</span><span class="sxs-lookup"><span data-stu-id="d51bf-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="d51bf-155">Zamiast tego parametru output reprezentuje tę samą lokalizację magazynu zmienna, podane jako argument w wywołaniu funkcji elementu członkowskiego lub delegata.</span><span class="sxs-lookup"><span data-stu-id="d51bf-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="d51bf-156">W związku z tym wartość parametru wyjściowego jest zawsze taki sam, jako zmienna bazowego.</span><span class="sxs-lookup"><span data-stu-id="d51bf-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="d51bf-157">Asercja określonego przydziału obowiązują następujące reguły do parametrów danych wyjściowych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="d51bf-158">Należy pamiętać, różne reguły odniesienia parametrów opisanych w [odwołania do parametrów](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="d51bf-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="d51bf-159">Zmienna musi nie być zdecydowanie przypisana może być przekazywany jako parametr wyjściowy w funkcji składowej, lub delegować wywołania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="d51bf-160">Po zakończeniu normalne wywołanie funkcji elementu członkowskiego lub delegata każda zmienna, która została przekazana jako parametr wyjściowy jest uznawany za przypisane w tej ścieżce wykonywania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="d51bf-161">Funkcja składowa lub funkcja anonimowa początkowo nieprzypisane jest traktowany jako parametr wyjściowy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="d51bf-162">Każdy parametr wyjściowy, funkcja składowa lub funkcja anonimowa musi być zdecydowanie przypisana ([asercję określonego przypisania](variables.md#definite-assignment)) przed funkcją członka lub funkcja anonimowa zwraca normalnie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="d51bf-163">W konstruktorze wystąpienia typu struktury `this` — słowo kluczowe zachowuje się dokładnie jako parametr wyjściowy typu struktury ([dostęp](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="d51bf-164">Zmienne lokalne</span><span class="sxs-lookup"><span data-stu-id="d51bf-164">Local variables</span></span>

<span data-ttu-id="d51bf-165">A ***zmienna lokalna*** zadeklarowano *local_variable_declaration*, które mogą wystąpić w *bloku*, *for_statement*, *switch_statement* lub *using_statement*; lub *foreach_statement* lub *specific_catch_clause* dla *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="d51bf-166">Okres istnienia zmiennej lokalnej jest części wykonywania programu, w którym magazyn jest gwarantowane do zarezerwowania dla niego.</span><span class="sxs-lookup"><span data-stu-id="d51bf-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="d51bf-167">Ten okres istnienia co najmniej rozciąga się od wejścia *bloku*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, lub *specific_catch_clause* za pomocą którego jest skojarzony, aż do wykonania tego *bloku*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, lub *specific_catch_clause* kończy się w dowolny sposób.</span><span class="sxs-lookup"><span data-stu-id="d51bf-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="d51bf-168">(Wprowadź ujęty *bloku* lub wywołanie metody wstrzymuje, ale nie kończy wykonywanie bieżącego *bloku*, *for_statement*, *switch_statement* , *using_statement*, *foreach_statement*, lub *specific_catch_clause*.) Jeśli zmienna lokalna jest przechwytywany przez funkcja anonimowa ([przechwyconych zmiennych zewnętrznych](expressions.md#captured-outer-variables)), jego okres istnienia co najmniej rozszerza aż delegat lub wyrażenie drzewa, utworzone na podstawie funkcja anonimowa, wraz ze wszystkimi innymi obiektami, które zaczynają odwoływać się do przechwyconej zmiennej, kwalifikują się do wyrzucania elementów bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="d51bf-169">Jeśli element nadrzędny *bloku*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, lub *specific_catch_clause* jest wprowadzana cyklicznie, nowe wystąpienie zmiennej lokalnej jest tworzony za każdym razem i jego *local_variable_initializer*, jeśli istnieje, nie zostało ocenione każdorazowo.</span><span class="sxs-lookup"><span data-stu-id="d51bf-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="d51bf-170">Zmienna lokalna wynikające z *local_variable_declaration* nie została zainicjowana automatycznie i w związku z tym nie ma wartości domyślnej.</span><span class="sxs-lookup"><span data-stu-id="d51bf-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="d51bf-171">Na potrzeby sprawdzania, asercja określonego przydziału, zmienna lokalna wprowadzone przez *local_variable_declaration* jest uznawany za początkowo nieprzypisane.</span><span class="sxs-lookup"><span data-stu-id="d51bf-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="d51bf-172">A *local_variable_declaration* mogą obejmować *local_variable_initializer*, w którym to przypadku zmienna jest uznawany za zdecydowanie przypisany dopiero po wyrażenie inicjujące ([ Instrukcje deklaracji](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="d51bf-173">W zakresie zmienną lokalną, wynikające z *local_variable_declaration*, jest to błąd czasu kompilacji do odwoływania się do tej zmiennej lokalnej w stanie tekstową poprzedzającym jego *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="d51bf-174">Jeśli w deklaracji zmiennej lokalnej jest niejawne ([deklaracje zmiennych lokalnych](statements.md#local-variable-declarations)), również jest błędem do odwoływania się do zmiennej w ramach jego *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="d51bf-175">Zmienna lokalna wynikające z *foreach_statement* lub *specific_catch_clause* jest uważana za cały zakres zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="d51bf-176">Rzeczywisty okres istnienia zmiennej lokalnej jest zależna od implementacji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="d51bf-177">Na przykład kompilatora statycznie określić, że zmienna lokalna w bloku jest używana tylko dla małych części tego bloku.</span><span class="sxs-lookup"><span data-stu-id="d51bf-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="d51bf-178">Za pomocą tej analizy, kompilator może wygenerować kod, który skutkuje magazynu zmiennej o krótszy okres istnienia niż bloku go zawierającego.</span><span class="sxs-lookup"><span data-stu-id="d51bf-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="d51bf-179">Magazyn, określone przez zmienną lokalnego odwołania jest odzyskiwane niezależnie od okresu istnienia tej zmiennej lokalnego odwołania ([automatyczne zarządzanie pamięcią](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="d51bf-180">Wartości domyślne</span><span class="sxs-lookup"><span data-stu-id="d51bf-180">Default values</span></span>

<span data-ttu-id="d51bf-181">Następujące kategorie zmienne są automatycznie inicjowane do wartości domyślnych:</span><span class="sxs-lookup"><span data-stu-id="d51bf-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="d51bf-182">Zmienne statyczne.</span><span class="sxs-lookup"><span data-stu-id="d51bf-182">Static variables.</span></span>
*  <span data-ttu-id="d51bf-183">Zmienne wystąpienia wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="d51bf-184">Elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-184">Array elements.</span></span>

<span data-ttu-id="d51bf-185">Wartość domyślna zmiennej zależy od typu zmiennej i jest określany w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="d51bf-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="d51bf-186">Dla zmiennej *value_type*, wartością domyślną jest taka sama jak wartość obliczona przez *value_type*firmy domyślnego konstruktora ([domyślne konstruktory](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="d51bf-187">Dla zmiennej *reference_type*, wartość domyślna to `null`.</span><span class="sxs-lookup"><span data-stu-id="d51bf-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="d51bf-188">Inicjowanie do wartości domyślnych jest zazwyczaj wykonywane przez Menedżera pamięci lub modułu zbierającego elementy bezużyteczne zainicjowanie pamięci, aby wszystkie bity zero, zanim jest przydzielany do użycia.</span><span class="sxs-lookup"><span data-stu-id="d51bf-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="d51bf-189">Z tego powodu jest łatwa w użyciu wszystkie bity zero do reprezentowania odwołanie o wartości null.</span><span class="sxs-lookup"><span data-stu-id="d51bf-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="d51bf-190">Asercja określonego przydziału</span><span class="sxs-lookup"><span data-stu-id="d51bf-190">Definite assignment</span></span>

<span data-ttu-id="d51bf-191">W podanej lokalizacji w kod wykonywalny funkcji elementu członkowskiego, zmienna jest nazywany ***zdecydowanie przypisywany*** w przypadku kompilator może potwierdzić podczas analizy statycznej przepływu ([dokładne zasady ustalania określony Przypisanie](variables.md#precise-rules-for-determining-definite-assignment)), zmienna automatycznie zainicjować lub zostało celem co najmniej jedno przypisanie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="d51bf-192">Nieformalnie wspomniano, są następujące reguły asercję określonego przypisania:</span><span class="sxs-lookup"><span data-stu-id="d51bf-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="d51bf-193">Początkowo przypisanej zmiennej ([początkowo przypisana zmienne](variables.md#initially-assigned-variables)) zawsze jest uznawany za zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="d51bf-194">Początkowo nieprzypisanej zmiennej ([początkowo nieprzypisane zmienne](variables.md#initially-unassigned-variables)) jest uznawana za zdecydowanie przypisany w danej lokalizacji, jeśli wszystkie możliwe wykonania ścieżki prowadzące do tej lokalizacji zawiera co najmniej jeden z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="d51bf-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="d51bf-195">Przypisanie proste ([przypisanie proste](expressions.md#simple-assignment)), w którym zmienna jest lewy operand.</span><span class="sxs-lookup"><span data-stu-id="d51bf-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="d51bf-196">Wyrażenie wywołania ([wyrażenia wywołania](expressions.md#invocation-expressions)) lub wyrażenie tworzenia obiektu ([wyrażenia tworzenia obiektów](expressions.md#object-creation-expressions)) który przekazuje zmiennej jako parametr wyjściowy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="d51bf-197">Dla zmiennej lokalnej deklaracji zmiennej lokalnej ([deklaracje zmiennych lokalnych](statements.md#local-variable-declarations)) zawierającej inicjatorze zmiennych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="d51bf-198">Formalną specyfikację nieformalne powyższych zasad podstawowych jest opisana w [początkowo przypisana zmienne](variables.md#initially-assigned-variables), [początkowo nieprzypisane zmienne](variables.md#initially-unassigned-variables), i [dokładne zasady ustalania asercja określonego przydziału](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="d51bf-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="d51bf-199">Stany asercję określonego przypisania zmiennych wystąpienia *struct_type* zmiennej są śledzone osobno również jak zbiorczo.</span><span class="sxs-lookup"><span data-stu-id="d51bf-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="d51bf-200">W dodatkowych reguł powyżej, następujące reguły dotyczą *struct_type* zmienne oraz ich zmienne wystąpienia:</span><span class="sxs-lookup"><span data-stu-id="d51bf-200">In additional to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="d51bf-201">Zmienną instance jest uznawana za zdecydowanie przypisany jeśli jego zawierający *struct_type* zmienna jest uznawany za zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="d51bf-202">A *struct_type* zmienna jest uznawana za zdecydowanie przypisany Jeśli każdego z jego zmienne wystąpienia jest uznawany za zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="d51bf-203">Asercja określonego przydziału jest to wymagane w następujących okolicznościach:</span><span class="sxs-lookup"><span data-stu-id="d51bf-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="d51bf-204">Zmienna musi być zdecydowanie przypisana w każdej lokalizacji, w których uzyskuje się wartość.</span><span class="sxs-lookup"><span data-stu-id="d51bf-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="d51bf-205">Daje to gwarancję, niezdefiniowane wartości nigdy nie wystąpi.</span><span class="sxs-lookup"><span data-stu-id="d51bf-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="d51bf-206">Wystąpienie zmiennej w wyrażeniu jest uważany za uzyskiwanie wartości zmiennej, chyba że</span><span class="sxs-lookup"><span data-stu-id="d51bf-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="d51bf-207">zmienna jest lewy operand przypisanie proste</span><span class="sxs-lookup"><span data-stu-id="d51bf-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="d51bf-208">zmienna jest przekazywana jako parametr wyjściowy lub</span><span class="sxs-lookup"><span data-stu-id="d51bf-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="d51bf-209">zmienna jest *struct_type* zmiennej i pojawia się jako lewy operand dostępu elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="d51bf-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="d51bf-210">Zmienna musi być zdecydowanie przypisana w każdej lokalizacji, w której jest przekazywany jako parametr przekazany przez odwołanie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="d51bf-211">Gwarantuje to, czy funkcja składowa, wywoływana można wziąć pod uwagę parametr odwołania początkowo przypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="d51bf-212">Wszystkie parametry wyjściowe funkcji elementu członkowskiego musi być zdecydowanie przypisana w każdej lokalizacji, w którym element członkowski funkcji zwraca (za pośrednictwem `return` instrukcji lub za pośrednictwem wykonywania osiągnięcia końca treści funkcji składowej).</span><span class="sxs-lookup"><span data-stu-id="d51bf-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="d51bf-213">Daje to gwarancję, że funkcji elementów członkowskich nie zwracają niezdefiniowane wartości w parametry wyjściowe kompilatora wziąć pod uwagę wywołania elementu funkcji, która przyjmuje zmienną jako parametr wyjściowy równoważne do przypisania do zmiennej umożliwiając w ten sposób.</span><span class="sxs-lookup"><span data-stu-id="d51bf-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="d51bf-214">`this` Zmiennej *struct_type* konstruktora wystąpienia musi być zdecydowanie przypisana w każdej lokalizacji, w których zwraca tego konstruktora wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="d51bf-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="d51bf-215">Początkowo zmiennymi</span><span class="sxs-lookup"><span data-stu-id="d51bf-215">Initially assigned variables</span></span>

<span data-ttu-id="d51bf-216">Następujące kategorie zmienne są klasyfikowane jako początkowo przypisana:</span><span class="sxs-lookup"><span data-stu-id="d51bf-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="d51bf-217">Zmienne statyczne.</span><span class="sxs-lookup"><span data-stu-id="d51bf-217">Static variables.</span></span>
*  <span data-ttu-id="d51bf-218">Zmienne wystąpienia wystąpienia klasy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="d51bf-219">Zmienne wystąpienia struktury wstępnie przypisanych zmiennych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="d51bf-220">Elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="d51bf-220">Array elements.</span></span>
*  <span data-ttu-id="d51bf-221">Wartości parametrów.</span><span class="sxs-lookup"><span data-stu-id="d51bf-221">Value parameters.</span></span>
*  <span data-ttu-id="d51bf-222">Parametry odwołania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-222">Reference parameters.</span></span>
*  <span data-ttu-id="d51bf-223">Zmienne zadeklarowane w `catch` klauzuli lub `foreach` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="d51bf-224">Początkowo nieprzypisane zmiennych</span><span class="sxs-lookup"><span data-stu-id="d51bf-224">Initially unassigned variables</span></span>

<span data-ttu-id="d51bf-225">Następujące kategorie zmienne są klasyfikowane jako początkowo nieprzypisane:</span><span class="sxs-lookup"><span data-stu-id="d51bf-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="d51bf-226">Zmienne wystąpienia struktury początkowo nieprzypisane zmiennych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="d51bf-227">Dane wyjściowe parametrów, w tym `this` zmiennej konstruktorów wystąpienia struktury.</span><span class="sxs-lookup"><span data-stu-id="d51bf-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="d51bf-228">Zmienne lokalne, oprócz tych zadeklarowanych w `catch` klauzuli lub `foreach` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="d51bf-229">Dokładne zasady określania asercję określonego przypisania</span><span class="sxs-lookup"><span data-stu-id="d51bf-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="d51bf-230">Aby określić, że zmiennych używanych jest zdecydowanie przypisany, kompilator korzystać procesu, który jest odpowiednikiem to opisane w tej sekcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="d51bf-231">Kompilator przetwarza treść każdy element członkowski funkcji, który ma co najmniej jednej zmiennej początkowo nieprzypisane.</span><span class="sxs-lookup"><span data-stu-id="d51bf-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="d51bf-232">Dla każdej zmiennej początkowo nieprzypisane *v*, kompilator Określa ***stanu asercję określonego przypisania*** dla *v* w każdym z następujących punktów w elemencie członkowskim funkcji:</span><span class="sxs-lookup"><span data-stu-id="d51bf-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="d51bf-233">Na początku każdej instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="d51bf-234">W punkcie końcowym ([punktów końcowych i osiągalności](statements.md#end-points-and-reachability)) każdej instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="d51bf-235">Na każdym łuku który przekazuje sterowanie do innej instrukcji lub punkt końcowy w instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="d51bf-236">Na początku każdego wyrażenia</span><span class="sxs-lookup"><span data-stu-id="d51bf-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="d51bf-237">Na koniec każdego wyrażenia</span><span class="sxs-lookup"><span data-stu-id="d51bf-237">At the end of each expression</span></span>

<span data-ttu-id="d51bf-238">Stan asercję określonego przypisania *v* może być albo:</span><span class="sxs-lookup"><span data-stu-id="d51bf-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="d51bf-239">Zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-239">Definitely assigned.</span></span> <span data-ttu-id="d51bf-240">Oznacza to, że na wszystkich przepływów sterowania możliwe do tej pory *v* zostanie przypisana wartość.</span><span class="sxs-lookup"><span data-stu-id="d51bf-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="d51bf-241">Zdecydowanie Nieprzypisana.</span><span class="sxs-lookup"><span data-stu-id="d51bf-241">Not definitely assigned.</span></span> <span data-ttu-id="d51bf-242">Stan zmiennej na końcu wyrażenia typu `bool`, stan zmienna, która nie jest zdecydowanie przypisywany może (ale nie zawsze) można podzielić na jeden z następujących stanów podrzędnych:</span><span class="sxs-lookup"><span data-stu-id="d51bf-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="d51bf-243">Zdecydowanie przypisana po wartość true, wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="d51bf-244">Ten stan wskazuje, że *v* jest zdecydowanie przypisana, jeśli wyrażenie logiczne oceniane jako PRAWDA, ale nie jest koniecznie przypisany, jeśli wyrażenie logiczne ocenione jako fałszywe.</span><span class="sxs-lookup"><span data-stu-id="d51bf-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="d51bf-245">Zdecydowanie przypisana po wyrażeniu false.</span><span class="sxs-lookup"><span data-stu-id="d51bf-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="d51bf-246">Ten stan wskazuje, że *v* jest zdecydowanie przypisana, jeśli wyrażenie logiczne ocenione jako fałszywe, ale nie jest koniecznie przypisany, jeśli wyrażenie logiczne jest oceniane jako PRAWDA.</span><span class="sxs-lookup"><span data-stu-id="d51bf-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="d51bf-247">Następujące reguły określają sposób, w jaki stan zmiennej *v* jest określana w każdej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="d51bf-248">Ogólne zasady dla instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-248">General rules for statements</span></span>

*  <span data-ttu-id="d51bf-249">*v* nie jest zdecydowanie przypisany na początku treści funkcji składowej.</span><span class="sxs-lookup"><span data-stu-id="d51bf-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="d51bf-250">*v* jest zdecydowanie przypisany na początku każdej instrukcji jest nieosiągalny.</span><span class="sxs-lookup"><span data-stu-id="d51bf-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="d51bf-251">Stan asercję określonego przypisania *v* na początku innych instrukcji jest określany przez sprawdzenie stanu asercję określonego przypisania *v* na wszystkie transfery przepływu sterowania, przeznaczonych dla początku, Instrukcja.</span><span class="sxs-lookup"><span data-stu-id="d51bf-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="d51bf-252">Gdy (i tylko wtedy, gdy) *v* zdecydowanie jest przypisany na wszystkich takich transferu przepływu sterowania, na następnie *v* jest zdecydowanie przypisany na początku instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="d51bf-253">Zbiór transfery przepływu sterowania możliwe jest określana w taki sam sposób jak w przypadku sprawdzania osiągalności — instrukcja ([punktów końcowych i osiągalności](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="d51bf-254">Stan asercję określonego przypisania *v* w punkcie końcowym bloku `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, lub `switch` instrukcji jest określany przez sprawdzenie stanu asercję określonego przypisania *v* na wszystkie transfery przepływu sterowania, przeznaczonych dla punktu końcowego w tej instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="d51bf-255">Jeśli *v* zdecydowanie jest przypisany na wszystkich takich transferu przepływu sterowania, na następnie *v* jest zdecydowanie przypisana w punkcie końcowym instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="d51bf-256">W przeciwnym razie; *v* zdecydowanie nie jest przypisana w punkcie końcowym instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="d51bf-257">Zbiór transfery przepływu sterowania możliwe jest określana w taki sam sposób jak w przypadku sprawdzania osiągalności — instrukcja ([punktów końcowych i osiągalności](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="d51bf-258">Blok instrukcji, pole jest zaznaczone oraz instrukcje niezaznaczone</span><span class="sxs-lookup"><span data-stu-id="d51bf-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="d51bf-259">Stan asercję określonego przypisania *v* w kontrolce transferu do pierwszej instrukcji listy instrukcji w bloku (lub punkt końcowy w bloku, jeśli lista instrukcji jest pusta) jest taka sama jak instrukcja asercję określonego przypisania *v* przed blokiem `checked`, lub `unchecked` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="d51bf-260">Instrukcje wyrażeń</span><span class="sxs-lookup"><span data-stu-id="d51bf-260">Expression statements</span></span>

<span data-ttu-id="d51bf-261">Dla instrukcji wyrażenia *instrukcji INSERT* składający się z wyrażenia *expr*:</span><span class="sxs-lookup"><span data-stu-id="d51bf-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="d51bf-262">*v* ma ten sam stan asercję określonego przypisania na początku *expr* podobnie jak na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-263">Jeśli *v* Jeśli zdecydowanie przypisany na końcu *expr*, zdecydowanie jest przypisana w momencie zakończenia *instrukcji INSERT*; w przeciwnym razie; nie jest zdecydowanie przypisany na punkt końcowy *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="d51bf-264">Instrukcje deklaracji</span><span class="sxs-lookup"><span data-stu-id="d51bf-264">Declaration statements</span></span>

*  <span data-ttu-id="d51bf-265">Jeśli *instrukcji INSERT* jest następnie instrukcji deklaracji bez inicjatorów, *v* ma ten sam stan asercję określonego przypisania w momencie zakończenia *instrukcji INSERT* podobnie jak na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-266">Jeśli *instrukcji INSERT* jest następnie instrukcji deklaracji z inicjatorami, jego stan asercję określonego przypisania *v* jest określane tak, jakby *instrukcji INSERT* zostały listę instrukcji, za pomocą jednego przypisania Instrukcja dla każdej deklaracji za pomocą inicjatora (wymienione w kolejności deklaracji).</span><span class="sxs-lookup"><span data-stu-id="d51bf-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="d51bf-267">Jeśli instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-267">If statements</span></span>

<span data-ttu-id="d51bf-268">Aby uzyskać `if` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="d51bf-269">*v* ma ten sam stan asercję określonego przypisania na początku *expr* podobnie jak na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-270">Jeśli *v* jest zdecydowanie przypisany na końcu *expr*, a następnie jest zdecydowanie przypisany na przesyłanie przepływu sterowania do *then_stmt* i albo *else_stmt*  lub do punktu końcowego *instrukcji INSERT* przypadku nie klauzuli else.</span><span class="sxs-lookup"><span data-stu-id="d51bf-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="d51bf-271">Jeśli *v* ma stan "zdecydowanie przypisana, aby po wartość true, wyrażenie" na końcu *expr*, a następnie jest zdecydowanie przypisany na przesyłanie przepływu sterowania do *then_stmt*, a nie Zdecydowanie przypisany na transfer przepływu sterowania do jednej *else_stmt* lub do punktu końcowego *instrukcji INSERT* przypadku nie klauzuli else.</span><span class="sxs-lookup"><span data-stu-id="d51bf-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="d51bf-272">Jeśli *v* ma stan "zdecydowanie przypisana, aby po wyrażeniu false" na końcu *expr*, a następnie jest zdecydowanie przypisany na przesyłanie przepływu sterowania do *else_stmt*, a nie Zdecydowanie przypisany na przesyłanie przepływu sterowania do *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="d51bf-273">Zdecydowanie jest przypisana w punktu końcowego *instrukcji INSERT* tylko wtedy, gdy jest zdecydowanie przypisany na punktu końcowego *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="d51bf-274">W przeciwnym razie *v* zostanie uznane za zdecydowanie przypisany na transfer przepływu sterowania do jednej *then_stmt* lub *else_stmt*, lub do punktu końcowego  *instrukcji INSERT* przypadku nie klauzuli else.</span><span class="sxs-lookup"><span data-stu-id="d51bf-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="d51bf-275">Instrukcje Switch</span><span class="sxs-lookup"><span data-stu-id="d51bf-275">Switch statements</span></span>

<span data-ttu-id="d51bf-276">W `switch` instrukcji *instrukcji INSERT* z wyrażeniem kontrolowania *expr*:</span><span class="sxs-lookup"><span data-stu-id="d51bf-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="d51bf-277">Stan asercję określonego przypisania *v* na początku *expr* jest taka sama jak stan *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-278">Stan asercję określonego przypisania *v* przepływowi sterowania przesyłanie danych do instrukcji zablokowanych przełącznika dostępny jest taka sama jak stan asercję określonego przypisania *v* na końcu *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="d51bf-279">Podczas gdy instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-279">While statements</span></span>

<span data-ttu-id="d51bf-280">Aby uzyskać `while` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="d51bf-281">*v* ma ten sam stan asercję określonego przypisania na początku *expr* podobnie jak na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-282">Jeśli *v* jest zdecydowanie przypisany na końcu *expr*, a następnie jest zdecydowanie przypisany na przesyłanie przepływu sterowania do *while_body* i punkt końcowy  *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-283">Jeśli *v* ma stan "zdecydowanie przypisana, aby po wartość true, wyrażenie" na końcu *expr*, a następnie jest zdecydowanie przypisany na przesyłanie przepływu sterowania do *while_body*, ale nie Zdecydowanie przypisany na punktu końcowego *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-284">Jeśli *v* ma stan "zdecydowanie przypisana, aby po wyrażeniu false" na końcu *expr*, a następnie jest zdecydowanie przypisany na transfer przepływu sterowania do punktu końcowego *instrukcji INSERT* , ale zdecydowanie nie przypisano na przesyłanie przepływu sterowania do *while_body*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="d51bf-285">Wykonaj instrukcje</span><span class="sxs-lookup"><span data-stu-id="d51bf-285">Do statements</span></span>

<span data-ttu-id="d51bf-286">Aby uzyskać `do` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="d51bf-287">*v* ma ten sam stan asercję określonego przypisania przeniesienia przepływ sterowania od początku *instrukcji INSERT* do *do_body* podobnie jak na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-288">*v* ma ten sam stan asercję określonego przypisania na początku *expr* na punkt końcowy *do_body*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="d51bf-289">Jeśli *v* jest zdecydowanie przypisany na końcu *expr*, a następnie jest zdecydowanie przypisany na transfer przepływu sterowania do punktu końcowego *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-290">Jeśli *v* ma stan "zdecydowanie przypisana, aby po wyrażeniu false" na końcu *expr*, a następnie jest zdecydowanie przypisany na transfer przepływu sterowania do punktu końcowego *instrukcji INSERT* .</span><span class="sxs-lookup"><span data-stu-id="d51bf-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="d51bf-291">Aby uzyskać instrukcje</span><span class="sxs-lookup"><span data-stu-id="d51bf-291">For statements</span></span>

<span data-ttu-id="d51bf-292">Asercja określonego przydziału sprawdzania pod kątem `for` instrukcji formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="d51bf-293">odbywa się tak, jakby zostały napisane instrukcji:</span><span class="sxs-lookup"><span data-stu-id="d51bf-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="d51bf-294">Jeśli *for_condition* pominięto w `for` instrukcji, a następnie oceny asercję określonego przypisania kontynuowane tak, jakby *for_condition* zostały zastąpione `true` w rozwinięciu powyżej .</span><span class="sxs-lookup"><span data-stu-id="d51bf-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="d51bf-295">Przerwij, Kontynuuj i instrukcje goto</span><span class="sxs-lookup"><span data-stu-id="d51bf-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="d51bf-296">Stan asercję określonego przypisania *v* na transfer przepływu sterowania spowodowane `break`, `continue`, lub `goto` instrukcji jest taka sama jak stan asercję określonego przypisania *v* w Początek instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="d51bf-297">Throw — instrukcje</span><span class="sxs-lookup"><span data-stu-id="d51bf-297">Throw statements</span></span>

<span data-ttu-id="d51bf-298">Dla instrukcji *instrukcji INSERT* formularza</span><span class="sxs-lookup"><span data-stu-id="d51bf-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="d51bf-299">Stan asercję określonego przypisania *v* na początku *expr* jest taka sama jak stan asercję określonego przypisania *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="d51bf-300">Instrukcje powrotu</span><span class="sxs-lookup"><span data-stu-id="d51bf-300">Return statements</span></span>

<span data-ttu-id="d51bf-301">Dla instrukcji *instrukcji INSERT* formularza</span><span class="sxs-lookup"><span data-stu-id="d51bf-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="d51bf-302">Stan asercję określonego przypisania *v* na początku *expr* jest taka sama jak stan asercję określonego przypisania *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-303">Jeśli *v* to parametr wyjściowy, a następnie go musi być zdecydowanie przypisana albo:</span><span class="sxs-lookup"><span data-stu-id="d51bf-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="d51bf-304">Po *expr*</span><span class="sxs-lookup"><span data-stu-id="d51bf-304">after *expr*</span></span>
    * <span data-ttu-id="d51bf-305">lub na końcu `finally` bloku `try` - `finally` lub `try` - `catch` - `finally` który otacza `return` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="d51bf-306">Dla instrukcji INSERT instrukcji formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="d51bf-307">Jeśli *v* to parametr wyjściowy, a następnie go musi być zdecydowanie przypisana albo:</span><span class="sxs-lookup"><span data-stu-id="d51bf-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="d51bf-308">przed *instrukcji INSERT*</span><span class="sxs-lookup"><span data-stu-id="d51bf-308">before *stmt*</span></span>
    * <span data-ttu-id="d51bf-309">lub na końcu `finally` bloku `try` - `finally` lub `try` - `catch` - `finally` który otacza `return` instrukcji.</span><span class="sxs-lookup"><span data-stu-id="d51bf-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="d51bf-310">Instrukcje try-catch</span><span class="sxs-lookup"><span data-stu-id="d51bf-310">Try-catch statements</span></span>

<span data-ttu-id="d51bf-311">Dla instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="d51bf-312">Stan asercję określonego przypisania *v* na początku *try_block* jest taka sama jak stan asercję określonego przypisania *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-313">Stan asercję określonego przypisania *v* na początku *catch_block_i* (dla dowolnej *i*) jest taka sama jak stan asercję określonego przypisania *v*na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-314">Stan asercję określonego przypisania *v* na punktu końcowego *instrukcji INSERT* jest zdecydowanie przypisany if (i tylko wtedy, gdy) *v* zdecydowanie przydzielono punktu końcowego  *try_block* , a następnie co *catch_block_i* (dla każdego *i* z zakresu od 1 do *n*).</span><span class="sxs-lookup"><span data-stu-id="d51bf-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="d51bf-315">Try-finally-instrukcje</span><span class="sxs-lookup"><span data-stu-id="d51bf-315">Try-finally statements</span></span>

<span data-ttu-id="d51bf-316">Aby uzyskać `try` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="d51bf-317">Stan asercję określonego przypisania *v* na początku *try_block* jest taka sama jak stan asercję określonego przypisania *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-318">Stan asercję określonego przypisania *v* na początku *finally_block* jest taka sama jak stan asercję określonego przypisania *v* na początku *instrukcji INSERT* .</span><span class="sxs-lookup"><span data-stu-id="d51bf-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-319">Stan asercję określonego przypisania *v* na punktu końcowego *instrukcji INSERT* jest zdecydowanie przypisany if (i tylko wtedy, gdy) dotyczy co najmniej jeden z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="d51bf-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="d51bf-320">*v* zdecydowanie przydzielono punktu końcowego *try_block*</span><span class="sxs-lookup"><span data-stu-id="d51bf-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="d51bf-321">*v* zdecydowanie przydzielono punktu końcowego *finally_block*</span><span class="sxs-lookup"><span data-stu-id="d51bf-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="d51bf-322">Jeśli transfer przepływu sterowania (na przykład `goto` instrukcji) wykonano, który rozpoczyna się w ramach *try_block*i kończy się poza *try_block*, następnie *v* jest również uznawany za zdecydowanie przypisany na ten transfer przepływu sterowania, jeśli *v* zdecydowanie przydzielono punktu końcowego *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="d51bf-323">(Nie jest to tylko wtedy, gdy — Jeśli *v* jest zdecydowanie przypisana z innego powodu na to przeniesienie przepływu sterowania, a następnie go jest nadal uważana za zdecydowanie przypisany.)</span><span class="sxs-lookup"><span data-stu-id="d51bf-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="d51bf-324">Instrukcje try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="d51bf-324">Try-catch-finally statements</span></span>

<span data-ttu-id="d51bf-325">Analiza asercję określonego przypisania `try` - `catch` - `finally` instrukcji formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="d51bf-326">odbywa się tak, jakby były instrukcji `try` - `finally` otaczającej instrukcji `try` - `catch` instrukcji:</span><span class="sxs-lookup"><span data-stu-id="d51bf-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="d51bf-327">Poniższy przykład pokazuje, jak różne bloki `try` — instrukcja ([instrukcjami "try"](statements.md#the-try-statement)) wpływają na asercję określonego przypisania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="d51bf-328">Instrukcji foreach</span><span class="sxs-lookup"><span data-stu-id="d51bf-328">Foreach statements</span></span>

<span data-ttu-id="d51bf-329">Aby uzyskać `foreach` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="d51bf-330">Stan asercję określonego przypisania *v* na początku *expr* jest taka sama jak stan *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-331">Stan asercję określonego przypisania *v* na przesyłanie przepływu sterowania do *embedded_statement* lub punkt końcowy *instrukcji INSERT* jest taka sama jak stan *v* na końcu *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="d51bf-332">Za pomocą instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-332">Using statements</span></span>

<span data-ttu-id="d51bf-333">Aby uzyskać `using` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="d51bf-334">Stan asercję określonego przypisania *v* na początku *resource_acquisition* jest taka sama jak stan *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-335">Stan asercję określonego przypisania *v* na przesyłanie przepływu sterowania do *embedded_statement* jest taka sama jak stan *v* na końcu *resource_ pozyskiwanie*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="d51bf-336">Blokady instrukcji</span><span class="sxs-lookup"><span data-stu-id="d51bf-336">Lock statements</span></span>

<span data-ttu-id="d51bf-337">Aby uzyskać `lock` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="d51bf-338">Stan asercję określonego przypisania *v* na początku *expr* jest taka sama jak stan *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-339">Stan asercję określonego przypisania *v* na przesyłanie przepływu sterowania do *embedded_statement* jest taka sama jak stan *v* na końcu *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="d51bf-340">Instrukcje YIELD</span><span class="sxs-lookup"><span data-stu-id="d51bf-340">Yield statements</span></span>

<span data-ttu-id="d51bf-341">Aby uzyskać `yield return` instrukcji *instrukcji INSERT* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="d51bf-342">Stan asercję określonego przypisania *v* na początku *expr* jest taka sama jak stan *v* na początku *instrukcji INSERT*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="d51bf-343">Stan asercję określonego przypisania *v* na końcu *instrukcji INSERT* jest taka sama jak stan *v* na końcu *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="d51bf-344">A `yield break` instrukcji nie ma wpływu na stan asercję określonego przypisania.</span><span class="sxs-lookup"><span data-stu-id="d51bf-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="d51bf-345">Ogólne zasady proste wyrażenia</span><span class="sxs-lookup"><span data-stu-id="d51bf-345">General rules for simple expressions</span></span>

<span data-ttu-id="d51bf-346">Następująca reguła ma zastosowanie do tego rodzaju wyrażeń: literały ([literały](expressions.md#literals)), nazwy proste ([proste nazwy](expressions.md#simple-names)), wyrażenia dostępu do składowych ([dostęp do elementu członkowskiego](expressions.md#member-access)), wyrażenia dostępu bazowego nieindeksowaną ([podstawowa dostępu](expressions.md#base-access)), `typeof` wyrażenia ([typeof — operator](expressions.md#the-typeof-operator)), domyślna wartość wyrażenia ([wyrażenia wartości domyślne ](expressions.md#default-value-expressions)) i `nameof` wyrażenia ([wyrażeń Nameof](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="d51bf-347">Stan asercję określonego przypisania *v* na końcu wyrażenia jest taka sama jak stan asercję określonego przypisania *v* na początku wyrażenia.</span><span class="sxs-lookup"><span data-stu-id="d51bf-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="d51bf-348">Ogólne reguły dotyczące wyrażeń z wyrażenia osadzone</span><span class="sxs-lookup"><span data-stu-id="d51bf-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="d51bf-349">Następujące reguły mają zastosowanie do tego rodzaju wyrażeń: wyrażenia ujętego w nawiasy ([wyrażeniach z nawiasami](expressions.md#parenthesized-expressions)), wyrażeniach dostępu do elementu ([dostępu do elementu](expressions.md#element-access)), podstawowej dostęp do wyrażenia z Indeksowanie ([podstawowa dostępu](expressions.md#base-access)), zwiększyć i zmniejszyć wyrażenia ([przyrostka inkrementacji i dekrementacji operatory](expressions.md#postfix-increment-and-decrement-operators), [prefiksów inkrementacji i dekrementacji operatory](expressions.md#prefix-increment-and-decrement-operators)), rzutowane wyrażenia ([rzutowane wyrażenia,](expressions.md#cast-expressions)), jednoargumentowe `+`, `-`, `~`, `*` wyrażenia binarnego `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` wyrażenia ([operatorów arytmetycznych](expressions.md#arithmetic-operators), [operatory przesunięcia](expressions.md#shift-operators), [relacyjne i badania typu operatory](expressions.md#relational-and-type-testing-operators) [Operatorów logicznych](expressions.md#logical-operators)), złożone wyrażenia przypisania ([przydział złożony](expressions.md#compound-assignment)), `checked` i `unchecked` wyrażenia ([checked i unchecked operatory](expressions.md#the-checked-and-unchecked-operators)), oraz wyrażeń tworzenia tablicy i delegata ([operatora new](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="d51bf-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="d51bf-350">Każda z tych wyrażeń ma jeden lub więcej wyrażeń podrzędnych, które bezwarunkowo są obliczane w ustalonej kolejności.</span><span class="sxs-lookup"><span data-stu-id="d51bf-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="d51bf-351">Na przykład plik binarny `%` operator ocenia po lewej stronie operatora, a następnie po prawej stronie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="d51bf-352">Operacja indeksowania oblicza wyrażenie indeksowane, a następnie ocenia każdy wyrażenia indeksu, w kolejności od lewej do prawej.</span><span class="sxs-lookup"><span data-stu-id="d51bf-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="d51bf-353">Wyrażenie *expr*, który ma podrzędną wyrażeniach *e1 i e2,..., eN*, ocenione w podanej kolejności:</span><span class="sxs-lookup"><span data-stu-id="d51bf-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="d51bf-354">Stan asercję określonego przypisania *v* na początku *e1* jest taka sama jak stan asercję określonego przypisania na początku *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="d51bf-355">Stan asercję określonego przypisania *v* na początku *ei* (*i* więcej niż jeden) jest taka sama jak stan asercję określonego przypisania na końcu poprzednie Podwyrażenie.</span><span class="sxs-lookup"><span data-stu-id="d51bf-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="d51bf-356">Stan asercję określonego przypisania *v* na końcu *expr* jest taka sama jak stan asercję określonego przypisania na końcu *eN*</span><span class="sxs-lookup"><span data-stu-id="d51bf-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="d51bf-357">Wyrażenia wywołania i wyrażenia tworzenia obiektów</span><span class="sxs-lookup"><span data-stu-id="d51bf-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="d51bf-358">Wyrażenie wywołania *expr* formularza:</span><span class="sxs-lookup"><span data-stu-id="d51bf-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="d51bf-359">lub wyrażenie tworzenia obiektu w postaci:</span><span class="sxs-lookup"><span data-stu-id="d51bf-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="d51bf-360">Wyrażenie wywołania, stan asercję określonego przypisania *v* przed *primary_expression* jest taka sama jak stan *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-361">Wyrażenie wywołania, stan asercję określonego przypisania *v* przed *arg1* jest taka sama jak stan *v* po *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="d51bf-362">Wyrażenie tworzenia obiektu, stan asercję określonego przypisania *v* przed *arg1* jest taka sama jak stan *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-363">Dla każdego argumentu *argi*, stan asercję określonego przypisania *v* po *argi* jest określana przez reguły wyrażenie normalne, ignorowanie dowolne `ref` lub `out`modyfikatorów.</span><span class="sxs-lookup"><span data-stu-id="d51bf-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="d51bf-364">Dla każdego argumentu *argi* dla każdego *i* więcej niż jeden stan asercję określonego przypisania *v* przed *argi* jest taka sama jak stanu *v* po poprzednim *arg*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="d51bf-365">Jeśli zmienna *v* jest przekazywany jako `out` argumentu (czyli argument w postaci `out v`) w jednym z argumentów, a następnie stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="d51bf-366">W przeciwnym razie; Stan *v* po *expr* jest taka sama jak stan *v* po *argN*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="d51bf-367">Dla inicjatora tablicy ([wyrażenie tworzenia tablicy](expressions.md#array-creation-expressions)), inicjatorach obiektów ([inicjatorach obiektów](expressions.md#object-initializers)), inicjatory kolekcji ([inicjatory kolekcji](expressions.md#collection-initializers)) i Inicjatory obiektów anonimowe ([wyrażenia tworzenia obiektu anonimowego](expressions.md#anonymous-object-creation-expressions)), stan asercja określonego przydziału jest określana przez rozszerzenie, które te konstrukcje są definiowane w kategoriach.</span><span class="sxs-lookup"><span data-stu-id="d51bf-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="d51bf-368">Przypisanie proste wyrażenia</span><span class="sxs-lookup"><span data-stu-id="d51bf-368">Simple assignment expressions</span></span>

<span data-ttu-id="d51bf-369">Wyrażenie *expr* formularza `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="d51bf-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="d51bf-370">Stan asercję określonego przypisania *v* przed *expr_rhs* jest taka sama jak stan asercję określonego przypisania *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-371">Stan asercję określonego przypisania *v* po *expr* jest określana przez:</span><span class="sxs-lookup"><span data-stu-id="d51bf-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="d51bf-372">Jeśli *w* jest tę samą zmienną jako *v*, następnie asercję określonego przypisania stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="d51bf-373">W przeciwnym razie, jeśli przypisania występuje w ramach konstruktora wystąpienia typu struktury, jeśli *w* jest dostęp do właściwości wyznaczanie automatycznie implementowanej właściwości *P* wystąpieniu budowany i *v* jest pole ukryte zapasowy *P*, następnie asercję określonego przypisania stan *v* po *expr* to przypisane.</span><span class="sxs-lookup"><span data-stu-id="d51bf-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="d51bf-374">W przeciwnym razie stan asercję określonego przypisania *v* po *expr* jest taka sama jak stan asercję określonego przypisania *v* po *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="d51bf-375">& & (oraz warunkowego) wyrażeń</span><span class="sxs-lookup"><span data-stu-id="d51bf-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="d51bf-376">Wyrażenie *expr* formularza `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="d51bf-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="d51bf-377">Stan asercję określonego przypisania *v* przed *expr_first* jest taka sama jak stan asercję określonego przypisania *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-378">Stan asercję określonego przypisania *v* przed *expr_second* jest zdecydowanie przypisana, jeśli stan *v* po *expr_first* jest Zdecydowanie przypisany lub "zdecydowanie przypisany po wartość true, wyrażenie".</span><span class="sxs-lookup"><span data-stu-id="d51bf-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="d51bf-379">W przeciwnym razie nie jest zdecydowanie przydzielone.</span><span class="sxs-lookup"><span data-stu-id="d51bf-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="d51bf-380">Stan asercję określonego przypisania *v* po *expr* jest określana przez:</span><span class="sxs-lookup"><span data-stu-id="d51bf-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="d51bf-381">Jeśli *expr_first* jest wyrażeniem stałym wartością `false`, następnie asercję określonego przypisania stan *v* po *expr* jest taka sama jak asercję określonego przypisania Stan *v* po *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="d51bf-382">W przeciwnym razie, jeśli stan *v* po *expr_first* jest zdecydowanie przypisana, następnie stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-383">W przeciwnym razie, jeśli stan *v* po *expr_second* jest zdecydowanie przypisana, a stan *v* po *expr_first* to " przypisane po wyrażeniu false", a następnie stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-384">W przeciwnym razie, jeśli stan *v* po *expr_second* jest zdecydowanie przypisany lub "zdecydowanie przypisany po wartość true, wyrażenie", a następnie stan *v* po  *wyrażenie* jest "zdecydowanie przypisana po wartość true, wyrażenie".</span><span class="sxs-lookup"><span data-stu-id="d51bf-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="d51bf-385">W przeciwnym razie, jeśli stan *v* po *expr_first* jest "zdecydowanie przypisany po wyrażeniu false", a stan *v* po *expr_second* jest "zdecydowanie przypisany po wyrażeniu false", a następnie stan *v* po *expr* jest "zdecydowanie przypisana po wyrażeniu false".</span><span class="sxs-lookup"><span data-stu-id="d51bf-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="d51bf-386">W przeciwnym razie stan *v* po *expr* nie jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="d51bf-387">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="d51bf-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="d51bf-388">Zmienna `i` jest uznawany za zdecydowanie przypisane w jednym z osadzonych instrukcji dla `if` instrukcji, ale nie w innych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="d51bf-389">W `if` instrukcji w metodzie `F`, zmienna `i` zdecydowanie jest przypisana w pierwszej instrukcji osadzony, ponieważ wykonywania wyrażenia `(i = y)` zawsze poprzedza wykonywania części tekstu niniejszych osadzonych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="d51bf-390">Z drugiej strony, zmienna `i` nie jest zdecydowanie przypisana w drugiej instrukcji osadzony, ponieważ `x >= 0` może zostały przetestowane "false", co w zmiennej `i` trwa nieprzypisane.</span><span class="sxs-lookup"><span data-stu-id="d51bf-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="d51bf-391">|| (OR warunkowe) wyrażeń</span><span class="sxs-lookup"><span data-stu-id="d51bf-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="d51bf-392">Wyrażenie *expr* formularza `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="d51bf-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="d51bf-393">Stan asercję określonego przypisania *v* przed *expr_first* jest taka sama jak stan asercję określonego przypisania *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-394">Stan asercję określonego przypisania *v* przed *expr_second* jest zdecydowanie przypisana, jeśli stan *v* po *expr_first* jest Zdecydowanie przypisany lub "zdecydowanie przypisany po wyrażeniu false".</span><span class="sxs-lookup"><span data-stu-id="d51bf-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="d51bf-395">W przeciwnym razie nie jest zdecydowanie przydzielone.</span><span class="sxs-lookup"><span data-stu-id="d51bf-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="d51bf-396">Instrukcja asercję określonego przypisania *v* po *expr* jest określana przez:</span><span class="sxs-lookup"><span data-stu-id="d51bf-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="d51bf-397">Jeśli *expr_first* jest wyrażeniem stałym wartością `true`, następnie asercję określonego przypisania stan *v* po *expr* jest taka sama jak asercję określonego przypisania Stan *v* po *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="d51bf-398">W przeciwnym razie, jeśli stan *v* po *expr_first* jest zdecydowanie przypisana, następnie stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-399">W przeciwnym razie, jeśli stan *v* po *expr_second* jest zdecydowanie przypisana, a stan *v* po *expr_first* to " przypisane po wartość true, wyrażenie", a następnie stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-400">W przeciwnym razie, jeśli stan *v* po *expr_second* jest zdecydowanie przypisany lub "zdecydowanie przypisany po wyrażeniu false", a następnie stan *v* po *expr* jest "zdecydowanie przypisana po wyrażeniu false".</span><span class="sxs-lookup"><span data-stu-id="d51bf-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="d51bf-401">W przeciwnym razie, jeśli stan *v* po *expr_first* "zdecydowanie przypisany po wartość true, wyrażenie" i stan *v* po *expr_second*jest "zdecydowanie przypisany po wartość true, wyrażenie", a następnie stan *v* po *expr* jest "zdecydowanie przypisana po wartość true, wyrażenie".</span><span class="sxs-lookup"><span data-stu-id="d51bf-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="d51bf-402">W przeciwnym razie stan *v* po *expr* nie jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="d51bf-403">W przykładzie</span><span class="sxs-lookup"><span data-stu-id="d51bf-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="d51bf-404">Zmienna `i` jest uznawany za zdecydowanie przypisane w jednym z osadzonych instrukcji dla `if` instrukcji, ale nie w innych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="d51bf-405">W `if` instrukcji w metodzie `G`, zmienna `i` zdecydowanie jest przypisana w drugiej instrukcji osadzony, ponieważ wykonywania wyrażenia `(i = y)` zawsze poprzedza wykonywania części tekstu niniejszych osadzonych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="d51bf-406">Z drugiej strony, zmienna `i` nie jest zdecydowanie przypisana w pierwszej instrukcji osadzony, ponieważ `x >= 0` może zostały przetestowane ma wartość true, co w zmiennej `i` trwa nieprzypisane.</span><span class="sxs-lookup"><span data-stu-id="d51bf-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="d51bf-407">!</span><span class="sxs-lookup"><span data-stu-id="d51bf-407">!</span></span> <span data-ttu-id="d51bf-408">wyrażenia (negacja logiczna)</span><span class="sxs-lookup"><span data-stu-id="d51bf-408">(logical negation) expressions</span></span>

<span data-ttu-id="d51bf-409">Wyrażenie *expr* formularza `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="d51bf-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="d51bf-410">Stan asercję określonego przypisania *v* przed *expr_operand* jest taka sama jak stan asercję określonego przypisania *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-411">Stan asercję określonego przypisania *v* po *expr* jest określana przez:</span><span class="sxs-lookup"><span data-stu-id="d51bf-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="d51bf-412">Jeśli stan *v* po \* expr_operand \* jest zdecydowanie przypisana, następnie stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-413">Jeśli stan *v* po \* expr_operand \* nie jest zdecydowanie przypisana, następnie stan *v* po *expr* nie jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-414">Jeśli stan *v* po \* expr_operand \* jest "zdecydowanie przypisany po wyrażeniu false", a następnie stan *v* po *expr* jest "zdecydowanie przypisana po true wyrażenie".</span><span class="sxs-lookup"><span data-stu-id="d51bf-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="d51bf-415">Jeśli stan *v* po \* expr_operand \* jest "zdecydowanie przypisany po wartość true, wyrażenie", a następnie stan *v* po *expr* jest "zdecydowanie przypisana po false wyrażenie".</span><span class="sxs-lookup"><span data-stu-id="d51bf-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="d51bf-416">??</span><span class="sxs-lookup"><span data-stu-id="d51bf-416">??</span></span> <span data-ttu-id="d51bf-417">wyrażenia (łączenie wartości null)</span><span class="sxs-lookup"><span data-stu-id="d51bf-417">(null coalescing) expressions</span></span>

<span data-ttu-id="d51bf-418">Wyrażenie *expr* formularza `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="d51bf-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="d51bf-419">Stan asercję określonego przypisania *v* przed *expr_first* jest taka sama jak stan asercję określonego przypisania *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-420">Stan asercję określonego przypisania *v* przed *expr_second* jest taka sama jak stan asercję określonego przypisania *v* po *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="d51bf-421">Instrukcja asercję określonego przypisania *v* po *expr* jest określana przez:</span><span class="sxs-lookup"><span data-stu-id="d51bf-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="d51bf-422">Jeśli *expr_first* jest wyrażeniem stałym ([wyrażeń stałych](expressions.md#constant-expressions)) o wartości null, a następnie stan *v* po *expr* jest taka sama jako stan *v* po *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="d51bf-423">W przeciwnym razie stan *v* po *expr* jest taka sama jak stan asercję określonego przypisania *v* po *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="d51bf-424">?: wyrażenia (warunkowe)</span><span class="sxs-lookup"><span data-stu-id="d51bf-424">?: (conditional) expressions</span></span>

<span data-ttu-id="d51bf-425">Wyrażenie *expr* formularza `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="d51bf-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="d51bf-426">Stan asercję określonego przypisania *v* przed *expr_cond* jest taka sama jak stan *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="d51bf-427">Stan asercję określonego przypisania *v* przed *expr_true* jest zdecydowanie przypisana tylko wtedy, gdy posiada jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="d51bf-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="d51bf-428">*expr_cond* jest wyrażeniem stałym z wartością `false`</span><span class="sxs-lookup"><span data-stu-id="d51bf-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="d51bf-429">Stan *v* po *expr_cond* jest zdecydowanie przypisana, lub "zdecydowanie przypisana, aby po wartość true, wyrażenie".</span><span class="sxs-lookup"><span data-stu-id="d51bf-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="d51bf-430">Stan asercję określonego przypisania *v* przed *expr_false* jest zdecydowanie przypisana tylko wtedy, gdy posiada jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="d51bf-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="d51bf-431">*expr_cond* jest wyrażeniem stałym z wartością `true`</span><span class="sxs-lookup"><span data-stu-id="d51bf-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="d51bf-432">Stan *v* po *expr_cond* jest zdecydowanie przypisana, lub "zdecydowanie przypisana, aby po wyrażeniu false".</span><span class="sxs-lookup"><span data-stu-id="d51bf-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="d51bf-433">Stan asercję określonego przypisania *v* po *expr* jest określana przez:</span><span class="sxs-lookup"><span data-stu-id="d51bf-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="d51bf-434">Jeśli *expr_cond* jest wyrażeniem stałym ([wyrażeń stałych](expressions.md#constant-expressions)) z wartością `true` następnie stan *v* po *expr* jest taka sama jak stan *v* po *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="d51bf-435">W przeciwnym razie, jeśli *expr_cond* jest wyrażeniem stałym ([wyrażeń stałych](expressions.md#constant-expressions)) z wartością `false` następnie stan *v* po *expr* jest taka sama jak stan *v* po *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="d51bf-436">W przeciwnym razie, jeśli stan *v* po *expr_true* jest zdecydowanie przypisany i stan *v* po *expr_false* to następnie przypisano mu stan *v* po *expr* jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="d51bf-437">W przeciwnym razie stan *v* po *expr* nie jest zdecydowanie przypisany.</span><span class="sxs-lookup"><span data-stu-id="d51bf-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="d51bf-438">Funkcje anonimowe</span><span class="sxs-lookup"><span data-stu-id="d51bf-438">Anonymous functions</span></span>

<span data-ttu-id="d51bf-439">Aby uzyskać *lambda_expression* lub *anonymous_method_expression* *wyrażenie* z treścią (albo *bloku* lub *wyrażenia* ) *treści*:</span><span class="sxs-lookup"><span data-stu-id="d51bf-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="d51bf-440">Stan asercję określonego przypisania zewnętrzna zmienna *v* przed *treści* jest taka sama jak stan *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="d51bf-441">Oznacza to, że stan asercję określonego przypisania zmiennych zewnętrznych jest dziedziczona z kontekstu funkcja anonimowa.</span><span class="sxs-lookup"><span data-stu-id="d51bf-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="d51bf-442">Stan asercję określonego przypisania zewnętrzna zmienna *v* po *expr* jest taka sama jak stan *v* przed *expr*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="d51bf-443">Przykład</span><span class="sxs-lookup"><span data-stu-id="d51bf-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="d51bf-444">generuje błąd w czasie kompilacji od `max` nie jest zdecydowanie przypisany której jest zadeklarowana funkcja anonimowa.</span><span class="sxs-lookup"><span data-stu-id="d51bf-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="d51bf-445">Przykład</span><span class="sxs-lookup"><span data-stu-id="d51bf-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="d51bf-446">również generuje błąd w czasie kompilacji od przypisania do `n` w funkcja anonimowa nie ma wpływu na stan asercję określonego przypisania `n` poza funkcja anonimowa.</span><span class="sxs-lookup"><span data-stu-id="d51bf-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="d51bf-447">Odwołań do zmiennych</span><span class="sxs-lookup"><span data-stu-id="d51bf-447">Variable references</span></span>

<span data-ttu-id="d51bf-448">A *variable_reference* jest *wyrażenie* , zostanie sklasyfikowany jako zmienną.</span><span class="sxs-lookup"><span data-stu-id="d51bf-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="d51bf-449">A *variable_reference* oznacza lokalizację magazynu, który jest możliwy do pobrania bieżącą wartość i przechowywać nową wartość.</span><span class="sxs-lookup"><span data-stu-id="d51bf-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="d51bf-450">W języku C i C++, *variable_reference* jest znany jako *l-wartości*.</span><span class="sxs-lookup"><span data-stu-id="d51bf-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="d51bf-451">Niepodzielność odwołań do zmiennych</span><span class="sxs-lookup"><span data-stu-id="d51bf-451">Atomicity of variable references</span></span>

<span data-ttu-id="d51bf-452">Odczyty i zapisy następujące typy danych są niepodzielne: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`i typy referencyjne.</span><span class="sxs-lookup"><span data-stu-id="d51bf-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="d51bf-453">Ponadto odczyty i zapisy typach wyliczeniowych z typu podstawowego na poprzedniej liście również są niepodzielne.</span><span class="sxs-lookup"><span data-stu-id="d51bf-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="d51bf-454">Odczytuje i zapisuje je w innych typów, w tym `long`, `ulong`, `double`, i `decimal`, a także typy zdefiniowane przez użytkownika nie ma gwarancji niepodzielnych.</span><span class="sxs-lookup"><span data-stu-id="d51bf-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="d51bf-455">Oprócz funkcji biblioteki przeznaczone do tego celu nie ma żadnej gwarancji elementu atomic odczytu modify-write, takie jak w przypadku inkrementacyjna lub dekrementacyjna.</span><span class="sxs-lookup"><span data-stu-id="d51bf-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

