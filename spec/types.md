---
ms.openlocfilehash: a28397b1ce97dbead6d5014e2b20e108a1018502
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/25/2019
ms.locfileid: "64488790"
---
# <a name="types"></a><span data-ttu-id="93eb1-101">Types</span><span class="sxs-lookup"><span data-stu-id="93eb1-101">Types</span></span>

<span data-ttu-id="93eb1-102">Typy w języku C# są podzielone na dwie główne kategorie: ***typy wartości*** i ***typy odwołań***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="93eb1-103">Typy wartości i typy referencyjne mogą być ***typów ogólnych***, który wykonać co najmniej jeden ***parametry typu***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="93eb1-104">Parametrów typu można wyznaczyć obu typów wartości i typy referencyjne.</span><span class="sxs-lookup"><span data-stu-id="93eb1-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="93eb1-105">Końcowe kategorii typów, wskaźników, jest dostępna tylko w niebezpieczny kod.</span><span class="sxs-lookup"><span data-stu-id="93eb1-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="93eb1-106">Zostało to omówione w dalszych [typy wskaźników](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="93eb1-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="93eb1-107">Typy wartości różnią się z typami odwołań, zmienne typu wartości zawierają bezpośrednio swoje dane, natomiast zmienne odwołania do typów magazynu ***odwołania*** praw dotyczących danych, te ostatnie są nazywane ***obiektów***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="93eb1-108">W przypadku typów referencyjnych jest możliwe w dwóch zmiennych odwoływać się do tego samego obiektu, a zatem możliwe dla operacji na jednej zmiennej miały wpływ na obiekt odwołuje się druga zmienna.</span><span class="sxs-lookup"><span data-stu-id="93eb1-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="93eb1-109">Z typami wartości zmiennych każda ma własne kopię danych, a nie jest możliwe dla operacji na jednym wpływa na drugi.</span><span class="sxs-lookup"><span data-stu-id="93eb1-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="93eb1-110">W systemie typu C# jest jednolita w taki sposób, że wartość dowolnego typu może być traktowana jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="93eb1-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="93eb1-111">Każdy typ w języku C#, bezpośrednio lub pośrednio pochodzi z `object` typ, klasy i `object` jest ultimate klasą bazową wszystkich typów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="93eb1-112">Wartości typu referencyjnego są traktowane jako obiekty poprzez wyświetlanie wartości jako typu `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="93eb1-113">Wartości typu wartości są traktowane jako obiekty, wykonując operacje pakowania, jak i rozpakowania ([pakowania i rozpakowywania](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="93eb1-114">Typy wartości</span><span class="sxs-lookup"><span data-stu-id="93eb1-114">Value types</span></span>

<span data-ttu-id="93eb1-115">Typ wartości jest typu struktury lub typem wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="93eb1-116">C# zawiera zestaw wstępnie zdefiniowanych struktura typów o nazwie ***typów prostych***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="93eb1-117">Proste typy są identyfikowane za pomocą słów zastrzeżonych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="93eb1-118">W przeciwieństwie do zmiennej typu odwołania, zmienna typu wartości może zawierać wartość `null` tylko wtedy, gdy typ wartości jest typu dopuszczającego wartość null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="93eb1-119">Dla każdego typu wartości niedopuszczającym wartości jest odpowiedni typ wartości null, określające elementy tego samego zestawu wartości i wartości `null`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="93eb1-120">Przypisanie do zmiennej typu wartości tworzona jest kopia wartości jest przypisane.</span><span class="sxs-lookup"><span data-stu-id="93eb1-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="93eb1-121">To różni się od przypisania do zmiennej typu odwołania, która kopiuje odwołania, ale nie identyfikowane przez odwołanie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="93eb1-122">Typ System.ValueType</span><span class="sxs-lookup"><span data-stu-id="93eb1-122">The System.ValueType type</span></span>

<span data-ttu-id="93eb1-123">Wszystkie typy wartości są niejawnie dziedziczą z klasy `System.ValueType`, która z kolei dziedziczy z klasy `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="93eb1-124">Nie jest możliwe dla dowolnego typu do pochodzić od typu wartości i typy wartości, dlatego są niejawnie zamknięte ([zapieczętowanych klas](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="93eb1-125">Należy pamiętać, że `System.ValueType` sama nie jest *value_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="93eb1-126">Jest to raczej *class_type* z wszystkie *value_type*s wywodzą się automatycznie.</span><span class="sxs-lookup"><span data-stu-id="93eb1-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="93eb1-127">Konstruktory domyślne</span><span class="sxs-lookup"><span data-stu-id="93eb1-127">Default constructors</span></span>

<span data-ttu-id="93eb1-128">Wszystkie typy wartości niejawnie zadeklarować Konstruktor wystąpienia bez parametrów publicznego o nazwie ***domyślnego konstruktora***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="93eb1-129">Domyślny konstruktor Zwraca wystąpienie inicjowany z wartością zerową znane jako ***wartość domyślna*** jako typ wartości:</span><span class="sxs-lookup"><span data-stu-id="93eb1-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="93eb1-130">Dla wszystkich *simple_type*, wartością domyślną jest wartość produkowane przez wzorzec bitowy w postaci samych zer:</span><span class="sxs-lookup"><span data-stu-id="93eb1-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="93eb1-131">Aby uzyskać `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, i `ulong`, wartość domyślna to `0`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="93eb1-132">Aby uzyskać `char`, wartość domyślna to `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="93eb1-133">Aby uzyskać `float`, wartość domyślna to `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="93eb1-134">Aby uzyskać `double`, wartość domyślna to `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="93eb1-135">Aby uzyskać `decimal`, wartość domyślna to `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="93eb1-136">Aby uzyskać `bool`, wartość domyślna to `false`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="93eb1-137">Aby uzyskać *enum_type* `E`, wartość domyślna to `0`, przekonwertowane na typ `E`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="93eb1-138">Aby uzyskać *struct_type*, wartością domyślną jest wartość produkowane przez ustawienie dla wszystkich pola typu wartości przywrócić wartości domyślne i wszystkie odwołania pola typu do `null`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="93eb1-139">Aby uzyskać *nullable_type* wartość domyślna to wystąpienie, dla którego `HasValue` właściwość ma wartość FAŁSZ i `Value` właściwość nie jest.</span><span class="sxs-lookup"><span data-stu-id="93eb1-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="93eb1-140">Wartością domyślną jest również nazywany ***wartość null*** typu dopuszczającego wartość null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="93eb1-141">Podobnie jak dowolnego innego konstruktora wystąpienia domyślnego konstruktora typu wartości jest wywoływana przy użyciu `new` operatora.</span><span class="sxs-lookup"><span data-stu-id="93eb1-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="93eb1-142">Ze względu na wydajność to wymaganie nie jest przeznaczona do faktycznie mieć implementacji generuje wywołanie konstruktora.</span><span class="sxs-lookup"><span data-stu-id="93eb1-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="93eb1-143">W przykładzie poniżej zmienne `i` i `j` są zarówno inicjowane od zera.</span><span class="sxs-lookup"><span data-stu-id="93eb1-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="93eb1-144">Każdy typ wartości jest niejawnie Konstruktor publiczny wystąpienia bez parametrów, dlatego nie jest możliwe dla typu struktury zawierają jawna deklaracja konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="93eb1-145">Typ struktury jest jednak dozwolony do deklarowania konstruktory sparametryzowane wystąpień ([konstruktory](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="93eb1-146">Typy — struktura</span><span class="sxs-lookup"><span data-stu-id="93eb1-146">Struct types</span></span>

<span data-ttu-id="93eb1-147">Typ struktury jest typem wartości, które można zadeklarować stałe, pola, metody, właściwości, indeksatory, operatory, konstruktory wystąpień, konstruktorów statycznych i zagnieżdżone typy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="93eb1-148">Deklaracja typu struktury jest opisana w [deklaracji struktury](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="93eb1-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="93eb1-149">Typy proste</span><span class="sxs-lookup"><span data-stu-id="93eb1-149">Simple types</span></span>

<span data-ttu-id="93eb1-150">C# zawiera zestaw wstępnie zdefiniowanych struktura typów o nazwie ***typów prostych***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="93eb1-151">Proste typy są identyfikowane za pomocą słów zastrzeżonych, ale te słowa zastrzeżone są po prostu aliasami dla struktury wstępnie zdefiniowanych typów w pakietach `System` przestrzeni nazw, zgodnie z opisem w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="93eb1-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="93eb1-152">__Słowo zastrzeżone__</span><span class="sxs-lookup"><span data-stu-id="93eb1-152">__Reserved word__</span></span> | <span data-ttu-id="93eb1-153">__Wpisz alias__</span><span class="sxs-lookup"><span data-stu-id="93eb1-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="93eb1-154">Ponieważ prostego typu aliasy struktury, co typ prosty ma członków.</span><span class="sxs-lookup"><span data-stu-id="93eb1-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="93eb1-155">Na przykład `int` ma elementów członkowskich zadeklarowanych w `System.Int32` i elementy członkowskie są dziedziczone z `System.Object`, oraz następujące instrukcje są dozwolone:</span><span class="sxs-lookup"><span data-stu-id="93eb1-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="93eb1-156">Proste typy różnią się od innych typów struktury w sposób, aby umożliwić pewne dodatkowe operacje:</span><span class="sxs-lookup"><span data-stu-id="93eb1-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="93eb1-157">Większość typów prostych zezwala na wartości, które mają być utworzone przez pisanie *literały* ([literały](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="93eb1-158">Na przykład `123` jest literału typu `int` i `'a'` jest literału typu `char`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="93eb1-159">C# nie przewiduje literałów typu struktury ogólnie rzecz biorąc, a wartości inne niż domyślne inne typy struktury ostatecznie są zawsze tworzone za pomocą konstruktorów wystąpienia z tych typów struktury.</span><span class="sxs-lookup"><span data-stu-id="93eb1-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="93eb1-160">Operandy wyrażenia w przypadku wszystkich stałych typu prostego, możliwe jest dla kompilatora można obliczyć wartości wyrażenia w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="93eb1-161">Takie wyrażenie jest znany jako *constant_expression* ([wyrażeń stałych](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="93eb1-162">Wyrażeń obejmujących operatory zdefiniowane przez inne typy struktury nie są uważane za wyrażeń stałych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="93eb1-163">Za pomocą `const` deklaracji jest możliwe do deklarowania stałych typów prostych ([stałe](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="93eb1-164">Nie jest możliwe stałe inne typy struktury, ale podobny efekt jest dostarczany przez `static readonly` pola.</span><span class="sxs-lookup"><span data-stu-id="93eb1-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="93eb1-165">Konwersje typów prostych obejmujące mogą uczestniczyć w wersji ewaluacyjnej usługi operatory konwersji zdefiniowane przez inne typy struktury, ale operator konwersji zdefiniowany przez użytkownika nigdy nie mogą brać udział w wersji ewaluacyjnej usługi innego operatora zdefiniowanego przez użytkownika ([oceny konwersje zdefiniowane przez użytkownika](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="93eb1-166">Typy całkowite</span><span class="sxs-lookup"><span data-stu-id="93eb1-166">Integral types</span></span>

<span data-ttu-id="93eb1-167">C# obsługuje dziewięć typów całkowitych: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, i `char`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="93eb1-168">Typy całkowite mają następujące rozmiarów i zakresy wartości:</span><span class="sxs-lookup"><span data-stu-id="93eb1-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="93eb1-169">`sbyte` Reprezentuje typ podpisany 8-bitowych liczb całkowitych przy użyciu wartości z zakresu od -128 i 127.</span><span class="sxs-lookup"><span data-stu-id="93eb1-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="93eb1-170">`byte` Typ reprezentuje liczb całkowitych bez znaku 8-bitową przy użyciu wartości z zakresu od 0 do 255.</span><span class="sxs-lookup"><span data-stu-id="93eb1-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="93eb1-171">`short` Reprezentuje typ podpisany 16-bitowych liczb całkowitych przy użyciu wartości z zakresu od -32768 do 32767.</span><span class="sxs-lookup"><span data-stu-id="93eb1-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="93eb1-172">`ushort` Typ reprezentuje liczb całkowitych bez znaku 16-bitowych przy użyciu wartości z zakresu od 0 do 65535.</span><span class="sxs-lookup"><span data-stu-id="93eb1-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="93eb1-173">`int` Reprezentuje typ podpisany 32-bitowych liczb całkowitych przy użyciu wartości z zakresu od -2147483648 do 2147483647.</span><span class="sxs-lookup"><span data-stu-id="93eb1-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="93eb1-174">`uint` Typ reprezentuje liczb całkowitych bez znaku 32-bitowych przy użyciu wartości z zakresu od 0 do 4294967295.</span><span class="sxs-lookup"><span data-stu-id="93eb1-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="93eb1-175">`long` Reprezentuje typ podpisany 64-bitowych liczb całkowitych przy użyciu wartości z zakresu od wartość -9223372036854775808 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="93eb1-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="93eb1-176">`ulong` Typ reprezentuje liczb całkowitych bez znaku 64-bitowych przy użyciu wartości z zakresu od 0 do 18446744073709551615 są.</span><span class="sxs-lookup"><span data-stu-id="93eb1-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="93eb1-177">`char` Typ reprezentuje liczb całkowitych bez znaku 16-bitowych przy użyciu wartości z zakresu od 0 do 65535.</span><span class="sxs-lookup"><span data-stu-id="93eb1-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="93eb1-178">Zestaw możliwych wartości dla `char` typu odnosi się do zestawu znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="93eb1-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="93eb1-179">Mimo że `char` ma taką samą reprezentację jako `ushort`, nie wszystkie operacje na jednym typie są dozwolone w drugiej.</span><span class="sxs-lookup"><span data-stu-id="93eb1-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="93eb1-180">Jednoargumentowy typu całkowitego i operatory dwuargumentowe są zawsze pracują z podpisem precyzji 32-bitowych, bez znaku 32-bitową precyzję, podpisem precyzji 64-bitowych lub bez znaku 64-bitowa precyzja:</span><span class="sxs-lookup"><span data-stu-id="93eb1-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="93eb1-181">Dla jednoargumentowego `+` i `~` operatorów, operand jest konwertowany na typ `T`, gdzie `T` jest to pierwszy `int`, `uint`, `long`, i `ulong` można w pełni reprezentujące wszystkie Możliwe wartości argumentu operacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="93eb1-182">Operacja jest wykonywana przy użyciu precyzji typu `T`, a typ wyniku jest `T`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="93eb1-183">Dla jednoargumentowego `-` operatora, operand jest konwertowany na typ `T`, gdzie `T` jest to pierwszy `int` i `long` który pełni może reprezentować wszystkie możliwe wartości argumentu operacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="93eb1-184">Operacja jest wykonywana przy użyciu precyzji typu `T`, a typ wyniku jest `T`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="93eb1-185">Jednoargumentowy `-` do argumentów operacji typu nie można zastosować operatora `ulong`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="93eb1-186">Aby uzyskać dane binarne `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, i `<=` operatorów, operandy są konwertowane na typ `T`, gdzie `T` jest to pierwszy `int`, `uint`, `long`, i `ulong` reprezentujące można w pełni wszystkich możliwych wartości oba operandy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="93eb1-187">Operacja jest wykonywana przy użyciu precyzji typu `T`, a typ wyniku jest `T` (lub `bool` dla operatorów relacyjnych).</span><span class="sxs-lookup"><span data-stu-id="93eb1-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="93eb1-188">Nie jest dozwolony dla jeden argument typu `long` i drugą typu `ulong` z operatorami dwuargumentowymi.</span><span class="sxs-lookup"><span data-stu-id="93eb1-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="93eb1-189">Dla pliku binarnego `<<` i `>>` operatorów, lewy operand jest konwertowany na typ `T`, gdzie `T` jest to pierwszy `int`, `uint`, `long`, i `ulong` można w pełni reprezentujące wszystkie Możliwe wartości argumentu operacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="93eb1-190">Operacja jest wykonywana przy użyciu precyzji typu `T`, a typ wyniku jest `T`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="93eb1-191">`char` Typu jest klasyfikowana jako integralny typ, ale różni się od innych typów całkowitych na dwa sposoby:</span><span class="sxs-lookup"><span data-stu-id="93eb1-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="93eb1-192">Istnieje nie niejawne konwersje z innych typów `char` typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="93eb1-193">W szczególności mimo że `sbyte`, `byte`, i `ushort` typy mają zakresy wartości, które są w pełni stałego za pośrednictwem `char` wpisz niejawne konwersje z elementu `sbyte`, `byte`, lub `ushort` do `char` nie istnieją.</span><span class="sxs-lookup"><span data-stu-id="93eb1-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="93eb1-194">Stałe `char` typu musi być napisana jako *character_literal*s lub jako *integer_literal*s w połączeniu z Rzutowanie na typ `char`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="93eb1-195">Na przykład `(char)10` jest taka sama jak `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="93eb1-196">`checked` i `unchecked` operatory i instrukcje, które są używane do kontrolowania przepełnienie sprawdzania pod kątem typu całkowitego operacje arytmetyczne i konwersje ([operatory checked i unchecked](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="93eb1-197">W `checked` kontekstu, przepełnienie powoduje błąd kompilacji lub powoduje, że `System.OverflowException` zostanie wygenerowany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="93eb1-198">W `unchecked` kontekście przepełnienia są ignorowane, a wszystkie bity wyższego rzędu, które nie mieszczą się w typie docelowym zostaną odrzucone.</span><span class="sxs-lookup"><span data-stu-id="93eb1-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="93eb1-199">Zmiennoprzecinkowe typy punktów</span><span class="sxs-lookup"><span data-stu-id="93eb1-199">Floating point types</span></span>

<span data-ttu-id="93eb1-200">C# obsługuje dwa punktu zmiennoprzecinkowego: `float` i `double`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="93eb1-201">`float` i `double` typy są reprezentowane przy użyciu 32-bitowe o pojedynczej dokładności i 64-bitowych podwójnej precyzji IEEE 754 formatów, które zapewniają następujące zestawy wartości:</span><span class="sxs-lookup"><span data-stu-id="93eb1-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="93eb1-202">Dodatnia zero i ujemna zero.</span><span class="sxs-lookup"><span data-stu-id="93eb1-202">Positive zero and negative zero.</span></span> <span data-ttu-id="93eb1-203">W większości sytuacji, zero dodatnie i ujemne zero zachowują się identycznie, prostą wartość zero, ale niektóre operacje rozróżnienie między dwoma ([operator dzielenia](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="93eb1-204">Nieskończoności dodatniej i ujemna nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="93eb1-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="93eb1-205">Nieskończoności są produkowane przez operacje, takie jak dzielenia liczby różna od zera przez zero.</span><span class="sxs-lookup"><span data-stu-id="93eb1-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="93eb1-206">Na przykład `1.0 / 0.0` daje nieskończoności dodatniej i `-1.0 / 0.0` plony minus nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="93eb1-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="93eb1-207">***Nie nieliczbowych*** wartości, często w postaci akronimu NaN.</span><span class="sxs-lookup"><span data-stu-id="93eb1-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="93eb1-208">NaNs są produkowane przez nieprawidłowy operacji zmiennoprzecinkowych, takich jak dzielenia 0 przez zero.</span><span class="sxs-lookup"><span data-stu-id="93eb1-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="93eb1-209">Ograniczone zbiór wartości niezerowe wiązania w postaci `s * m * 2^e`, gdzie `s` wynosi 1 lub -1, i `m` i `e` zależą od określonego typu zmiennoprzecinkowego: Aby uzyskać `float`, `0 < m < 2^24` i `-149 <= e <= 104`oraz `double`, `0 < m < 2^53` i `1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `1075 <= e <= 970`.</span></span> <span data-ttu-id="93eb1-210">Nieznormalizowany liczby zmiennoprzecinkowe są traktowane jako prawidłowe wartości różna od zera.</span><span class="sxs-lookup"><span data-stu-id="93eb1-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="93eb1-211">`float` Typ może reprezentować wartości z zakresu od około `1.5 * 10^-45` do `3.4 * 10^38` z dokładnością do 7 cyfr.</span><span class="sxs-lookup"><span data-stu-id="93eb1-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="93eb1-212">`double` Typ może reprezentować wartości z zakresu od około `5.0 * 10^-324` do `1.7 × 10^308` z dokładnością do 15-16 cyfr.</span><span class="sxs-lookup"><span data-stu-id="93eb1-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="93eb1-213">Jeśli jeden z operandów operatora binarnego jest typu zmiennoprzecinkowego, to drugi operand musi być typu całkowitego lub typu zmiennoprzecinkowego i operacji jest obliczane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="93eb1-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="93eb1-214">Jeśli jeden z operandów jest typu całkowitego, że operand jest konwertowany na typ zmiennoprzecinkowych to drugi operand.</span><span class="sxs-lookup"><span data-stu-id="93eb1-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="93eb1-215">Następnie, jeśli jeden z operandów jest typu `double`, to drugi operand jest konwertowany na `double`, operacja jest wykonywana przy użyciu co najmniej `double` zakres i dokładność i typ wyniku jest `double` (lub `bool` dla Operatory relacyjne).</span><span class="sxs-lookup"><span data-stu-id="93eb1-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="93eb1-216">W przeciwnym razie operacja odbywa się przy użyciu co najmniej `float` zakres i dokładność i typ wyniku jest `float` (lub `bool` dla operatorów relacyjnych).</span><span class="sxs-lookup"><span data-stu-id="93eb1-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="93eb1-217">Zmiennoprzecinkowe operatorów, łącznie z operatorów przypisania nigdy nie generuje wyjątków.</span><span class="sxs-lookup"><span data-stu-id="93eb1-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="93eb1-218">Zamiast tego w sytuacjach wyjątkowych operacji zmiennoprzecinkowych dawać zero, infinity lub NaN, zgodnie z poniższym opisem:</span><span class="sxs-lookup"><span data-stu-id="93eb1-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="93eb1-219">Jeśli wynik operacji zmiennoprzecinkowej jest zbyt mały dla formatu docelowego, wynik operacji staje się zerem dodatnia lub ujemna zero.</span><span class="sxs-lookup"><span data-stu-id="93eb1-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="93eb1-220">Jeśli wynik operacji zmiennoprzecinkowej jest zbyt duży dla formatu docelowego, wynik operacji staje się nieskończoność dodatnia lub ujemna nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="93eb1-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="93eb1-221">Jeśli operacji zmiennoprzecinkowej jest nieprawidłowa, wynik operacji staje się NaN.</span><span class="sxs-lookup"><span data-stu-id="93eb1-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="93eb1-222">Jeśli jeden lub obydwa operandy operacji zmiennoprzecinkowej jest NaN, wynik operacji staje się NaN.</span><span class="sxs-lookup"><span data-stu-id="93eb1-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="93eb1-223">Zmiennoprzecinkowe operacje mogą być wykonywane przy użyciu większą precyzję niż typ wyniku operacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="93eb1-224">Na przykład niektóre architektury sprzęt obsługuje "rozszerzony" lub "double" typ zmiennoprzecinkowy większy zakres i dokładność niż `double` wpisz i niejawnie wykonuje wszystkie operacje zmiennoprzecinkowe przy użyciu tego wyższe typu dokładności.</span><span class="sxs-lookup"><span data-stu-id="93eb1-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="93eb1-225">Tylko kosztów nadmierne wydajności architektur takich sprzętu nie jest możliwe do wykonania operacji zmiennoprzecinkowych z mniejszą dokładnością i, a nie wymagają wdrażania straci wydajności i dokładności, C# umożliwia wyższe typu dokładności jako używane dla wszystkich operacji zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="93eb1-226">Inne niż dostarczać dokładniejsze wyniki, rzadko ma wymierne efekty.</span><span class="sxs-lookup"><span data-stu-id="93eb1-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="93eb1-227">Jednak w wyrażeniach w postaci `x * y / z`, gdzie mnożenia daje wynik, który znajduje się poza `double` zakresu, ale kolejne dzielenie oferuje tymczasowy wynik do `double` zakresu fakt, że wyrażenie obliczone w zakresie wyższe format może spowodować skończoną wynik do wyprodukowania zamiast nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="93eb1-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="93eb1-228">Typu dziesiętnego</span><span class="sxs-lookup"><span data-stu-id="93eb1-228">The decimal type</span></span>

<span data-ttu-id="93eb1-229">`decimal` Typ to typ danych 128-bitowych, odpowiedni do obliczeń finansowych i walutowych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="93eb1-230">`decimal` Typ może reprezentować wartości z zakresu od `1.0 * 10^-28` do około `7.9 * 10^28` z cyframi znaczącymi 28-29.</span><span class="sxs-lookup"><span data-stu-id="93eb1-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="93eb1-231">Ograniczone zestaw wartości typu `decimal` mają postać `(-1)^s * c * 10^-e`, gdzie znak `s` jest równa 0 lub 1, współczynnik `c` jest nadawana przez `0 <= *c* < 2^96`i skalowania `e` jest tak, aby `0 <= e <= 28`. `decimal` Typ nie obsługuje podpisem zer, nieskończoności lub firmy NaN.</span><span class="sxs-lookup"><span data-stu-id="93eb1-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="93eb1-232">Element `decimal` jest reprezentowany jako 96-bitową liczbę całkowitą, skalowana przez potęgą liczby 10.</span><span class="sxs-lookup"><span data-stu-id="93eb1-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="93eb1-233">Dla `decimal`s przy użyciu wartości bezwzględnej mniej niż `1.0m`, wartość jest dokładnie do 28 po przecinku, lecz żadnych dalszych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="93eb1-234">Aby uzyskać `decimal`s przy użyciu wartości bezwzględnej większa lub równa `1.0m`, wartość jest dokładnie do 28-29 cyfr.</span><span class="sxs-lookup"><span data-stu-id="93eb1-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="93eb1-235">Sprzeczna `float` i `double` typy danych ułamkowych liczby dziesiętne, takich jak 0,1 może być reprezentowany dokładnie w `decimal` reprezentacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="93eb1-236">W `float` i `double` reprezentacje liczby takie są często nieskończonej ułamki co te oświadczenia, które są bardziej podatne na zaokrąglania błędy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="93eb1-237">Jeśli jeden z argumentów operatora binarnego jest typu `decimal`, to drugi operand musi być typu całkowitego lub typu `decimal`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="93eb1-238">Jeśli argument typu całkowitego jest obecny, jest konwertowany na `decimal` przed wykonaniem operacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="93eb1-239">Wynikiem operacji na wartościach typu `decimal` jest, który byłby wynikiem obliczania dokładny wynik (przy zachowaniu skalowania, zgodnie z definicją operatorów), a następnie Zaokrąglenie w celu dopasowania do przedstawienia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="93eb1-240">Wyniki są zaokrąglane do najbliższego wartość oraz, jeśli wynik jest jednakowo blisko dwóch reprezentowanych wartości do wartości, który ma parzystą liczbą w najmniej znaczący Pozycja cyfry (jest to określane jako "banker przez zaokrąglenie").</span><span class="sxs-lookup"><span data-stu-id="93eb1-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="93eb1-241">Zero wynik ma zawsze znak liczby 0 i o skali 0.</span><span class="sxs-lookup"><span data-stu-id="93eb1-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="93eb1-242">Jeśli dziesiętna Operacja arytmetyczna daje wartość mniejszą niż lub równa `5 * 10^-29` w wartościach bezwzględnych, wynik operacji staje się zerem.</span><span class="sxs-lookup"><span data-stu-id="93eb1-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="93eb1-243">Jeśli `decimal` Operacja arytmetyczna daje wynik, który jest zbyt duży dla `decimal` formacie `System.OverflowException` zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="93eb1-244">`decimal` Typ ma większą precyzję ale mniejszym zakresie niż typów zmiennoprzecinkowych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="93eb1-245">W związku z tym, konwersje z typów zmiennoprzecinkowych aby `decimal` może tworzyć wyjątki przepełnienia i konwersje z `decimal` z typami zmiennoprzecinkowymi może spowodować utratę dokładności.</span><span class="sxs-lookup"><span data-stu-id="93eb1-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="93eb1-246">Z tego względu nie niejawne występują konwersje między typami zmiennoprzecinkowymi a `decimal`, i bez jawnego rzutowania, nie można mieszać zmiennoprzecinkowe i `decimal` operandy w jednym wyrażeniu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="93eb1-247">Typu logicznego</span><span class="sxs-lookup"><span data-stu-id="93eb1-247">The bool type</span></span>

<span data-ttu-id="93eb1-248">`bool` Typ reprezentuje logiczną ilości logiczne.</span><span class="sxs-lookup"><span data-stu-id="93eb1-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="93eb1-249">Możliwe wartości typu `bool` są `true` i `false`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="93eb1-250">Nie standardowa występują konwersje między `bool` a innymi typami danych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="93eb1-251">W szczególności `bool` typ jest odrębna i oddzielona od typów całkowitych i `bool` wartości nie można użyć zamiast wartości całkowitej i na odwrót.</span><span class="sxs-lookup"><span data-stu-id="93eb1-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="93eb1-252">W językach C i C++ całkowitych lub zmiennoprzecinkowych wartość zero lub wskaźnikiem typu null można przekonwertować na wartość logiczną `false`, a wartość niezerową całkowitych lub zmiennoprzecinkowych lub wskaźnik zerowy można przekonwertować na wartość logiczną `true`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="93eb1-253">W języku C#, takie konwersje są wykonywane przez jawne porównanie wartości całkowitych lub zmiennoprzecinkowych do zera lub przez jawne porównanie odwołanie obiektu do `null`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="93eb1-254">Typów wyliczeniowych</span><span class="sxs-lookup"><span data-stu-id="93eb1-254">Enumeration types</span></span>

<span data-ttu-id="93eb1-255">Typ wyliczenia jest typem samodzielnym z nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="93eb1-256">Każdy typ wyliczenia ma podstawowy typ, który musi być `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` lub `ulong`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="93eb1-257">Zbiór wartości na typ wyliczenia jest taka sama jak zestaw wartości typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="93eb1-258">Wartości typu wyliczenia nie są ograniczone do wartości nazwanych stałych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="93eb1-259">Typy wyliczeniowe są definiowane za pomocą deklaracje modułów wyliczających ([deklaracje wyliczeń](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="93eb1-260">Typy dopuszczające wartości null</span><span class="sxs-lookup"><span data-stu-id="93eb1-260">Nullable types</span></span>

<span data-ttu-id="93eb1-261">Typ dopuszczający wartość null może reprezentować wszystkie wartości jego ***typ bazowy*** oraz dodatkową wartość null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="93eb1-262">Typ dopuszczający wartość null jest zapisywany `T?`, gdzie `T` jest typem podstawowym.</span><span class="sxs-lookup"><span data-stu-id="93eb1-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="93eb1-263">Ta składnia jest skrótem `System.Nullable<T>`, a dwa formularze, które mogą być używane zamiennie.</span><span class="sxs-lookup"><span data-stu-id="93eb1-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="93eb1-264">A ***typem wartościowym niebędącym*** i odwrotnie jest dowolny typ wartości inne niż `System.Nullable<T>` i jego skrót `T?` (dla każdego `T`), oraz parametr dowolnego typu, który jest ograniczony do być typem wartości niedopuszczającym wartości (czyli dowolny parametru typu z `struct` ograniczenia).</span><span class="sxs-lookup"><span data-stu-id="93eb1-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="93eb1-265">`System.Nullable<T>` Typ Określa wartość ograniczenia typu dla `T` ([ograniczenia parametru typu](classes.md#type-parameter-constraints)), co oznacza, że typ podstawowy elementu typu dopuszczającego wartość null, mogą być dowolnego typu wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="93eb1-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="93eb1-266">Typ dopuszczający wartość null lub typ referencyjny, nie może być typem podstawowym typu dopuszczającego wartość null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="93eb1-267">Na przykład `int??` i `string?` są nieprawidłowymi typami.</span><span class="sxs-lookup"><span data-stu-id="93eb1-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="93eb1-268">Wystąpienie typu dopuszczającego wartość null `T?` ma dwie właściwości publiczne tylko do odczytu:</span><span class="sxs-lookup"><span data-stu-id="93eb1-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="93eb1-269">A `HasValue` właściwości typu `bool`</span><span class="sxs-lookup"><span data-stu-id="93eb1-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="93eb1-270">A `Value` właściwości typu `T`</span><span class="sxs-lookup"><span data-stu-id="93eb1-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="93eb1-271">Wystąpienie, dla którego `HasValue` jest wartość PRAWDA jest określany jako inną niż null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="93eb1-272">Wystąpienia innych niż null zawiera znaną wartością i `Value` zwraca tę wartość.</span><span class="sxs-lookup"><span data-stu-id="93eb1-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="93eb1-273">Wystąpienie, dla którego `HasValue` jest FAŁSZ jest określany jako wartość null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="93eb1-274">Wystąpienie o wartości null ma wartość niezdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="93eb1-274">A null instance has an undefined value.</span></span> <span data-ttu-id="93eb1-275">Podjęto próbę odczytu `Value` wystąpienia o wartości null powoduje, że `System.InvalidOperationException` zostanie wygenerowany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="93eb1-276">Proces uzyskiwania `Value` właściwość nullable wystąpienia jest określany jako ***Odkodowywanie***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="93eb1-277">Oprócz domyślnego konstruktora, co typ dopuszczający wartość null `T?` publiczny konstruktor, który przyjmuje pojedynczy argument typu `T`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="93eb1-278">Wartość `x` typu `T`, wywołanie konstruktora formularza</span><span class="sxs-lookup"><span data-stu-id="93eb1-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="93eb1-279">tworzy wystąpienie innych niż null `T?` dla którego `Value` właściwość `x`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="93eb1-280">Proces tworzenia wystąpienia typu dopuszczającego wartość null inną niż null dla danej wartości nazywa się ***zawijania***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="93eb1-281">Niejawne konwersje są dostępne z `null` literału `T?` ([konwersje literału Null](conversions.md#null-literal-conversions)) i z `T` do `T?` ([niejawne konwersje nullable](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="93eb1-282">Typy odwołań</span><span class="sxs-lookup"><span data-stu-id="93eb1-282">Reference types</span></span>

<span data-ttu-id="93eb1-283">Typ odwołania jest typu klasy, typu interfejsu, typ tablicy lub typu delegata.</span><span class="sxs-lookup"><span data-stu-id="93eb1-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="93eb1-284">Wartość typu odwołania jest odwołaniem do ***wystąpienia*** typu ostatnie znane jako ***obiektu***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="93eb1-285">Specjalna wartość `null` jest zgodny ze wszystkimi typami odwołań i wskazuje brak wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="93eb1-286">Typy klas</span><span class="sxs-lookup"><span data-stu-id="93eb1-286">Class types</span></span>

<span data-ttu-id="93eb1-287">Typ klasy definiuje strukturę danych, który zawiera elementy członkowskie (stałe i pola), funkcji elementów członkowskich danych (metody, właściwości, zdarzenia, indeksatory, operatory, konstruktory wystąpień, destruktory i konstruktorów statycznych) i zagnieżdżone typy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="93eb1-288">Typy klas obsługuje dziedziczenie, mechanizm, według której rozszerzać i specialize klas bazowych klas pochodnych.</span><span class="sxs-lookup"><span data-stu-id="93eb1-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="93eb1-289">Wystąpienia typów klas są tworzone przy użyciu *object_creation_expression*s ([wyrażenia tworzenia obiektów](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="93eb1-290">Typy klas są opisane w [klasy](classes.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="93eb1-291">Niektóre typy wstępnie zdefiniowanych klas mają specjalne znaczenie w języku C#, zgodnie z opisem w poniższej tabeli.</span><span class="sxs-lookup"><span data-stu-id="93eb1-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="93eb1-292">__Typ klasy__</span><span class="sxs-lookup"><span data-stu-id="93eb1-292">__Class type__</span></span>     | <span data-ttu-id="93eb1-293">__Opis__</span><span class="sxs-lookup"><span data-stu-id="93eb1-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="93eb1-294">Ultimate klasa bazowa innych typów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="93eb1-295">Zobacz [typu obiektu](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="93eb1-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="93eb1-296">Typ ciągu języka C#.</span><span class="sxs-lookup"><span data-stu-id="93eb1-296">The string type of the C# language.</span></span> <span data-ttu-id="93eb1-297">Zobacz [typu string](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="93eb1-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="93eb1-298">Klasa bazowa wszystkich typów wartości.</span><span class="sxs-lookup"><span data-stu-id="93eb1-298">The base class of all value types.</span></span> <span data-ttu-id="93eb1-299">Zobacz [typu System.ValueType](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="93eb1-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="93eb1-300">Klasa bazowa wszystkich typów wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-300">The base class of all enum types.</span></span> <span data-ttu-id="93eb1-301">Zobacz [wyliczenia](enums.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="93eb1-302">Klasa bazowa wszystkie typy tablic.</span><span class="sxs-lookup"><span data-stu-id="93eb1-302">The base class of all array types.</span></span> <span data-ttu-id="93eb1-303">Zobacz [tablic](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="93eb1-304">Klasa bazowa wszystkimi typami delegatów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-304">The base class of all delegate types.</span></span> <span data-ttu-id="93eb1-305">Zobacz [delegatów](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="93eb1-306">Klasa bazowa wszystkich typów wyjątków.</span><span class="sxs-lookup"><span data-stu-id="93eb1-306">The base class of all exception types.</span></span> <span data-ttu-id="93eb1-307">Zobacz [wyjątki](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="93eb1-308">Typ obiektu</span><span class="sxs-lookup"><span data-stu-id="93eb1-308">The object type</span></span>

<span data-ttu-id="93eb1-309">`object` Typu klasy jest ultimate klasą bazową wszystkich innych typów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="93eb1-310">Każdy typ w języku C#, bezpośrednio lub pośrednio pochodzi z `object` typ klasy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="93eb1-311">Słowo kluczowe `object` jest po prostu aliasem dla wstępnie zdefiniowanego klasy `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="93eb1-312">Typ dynamiczny</span><span class="sxs-lookup"><span data-stu-id="93eb1-312">The dynamic type</span></span>

<span data-ttu-id="93eb1-313">`dynamic` Typ, takie jak `object`, można odwoływać się do dowolnych obiektów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="93eb1-314">Gdy operatory są stosowane do wyrażenia typu `dynamic`, ich rozwiązania jest odroczone do czasu program jest uruchamiany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="93eb1-315">W związku z tym jeśli operator prawnie nie można zastosować do przywoływanego obiektu, błąd nie jest zwracany podczas kompilacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="93eb1-316">Zamiast tego zostanie zgłoszony wyjątek podczas rozpoznawania operatora zakończy się niepowodzeniem w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="93eb1-317">Jej celem jest umożliwienie dynamiczne powiązanie, które opisano szczegółowo w temacie [wiązanie dynamiczne](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="93eb1-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="93eb1-318">`dynamic` uznaje się taka sama jak `object` z wyjątkiem pod następującymi względami:</span><span class="sxs-lookup"><span data-stu-id="93eb1-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="93eb1-319">Operacje dotyczące wyrażeń typu `dynamic` mogą być dynamicznie powiązane ([wiązanie dynamiczne](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="93eb1-320">Wnioskowanie o typie ([wnioskowanie o typie](expressions.md#type-inference)) zostanie Preferuj `dynamic` za pośrednictwem `object` , gdy oba są kandydatami.</span><span class="sxs-lookup"><span data-stu-id="93eb1-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="93eb1-321">Ze względu na to równoważności poniżej zawiera:</span><span class="sxs-lookup"><span data-stu-id="93eb1-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="93eb1-322">Brak konwersji niejawnych tożsamości między `object` i `dynamic`oraz między typami skonstruowany, które są takie same w przypadku zastępowania `dynamic` z `object`</span><span class="sxs-lookup"><span data-stu-id="93eb1-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="93eb1-323">Jawne i niejawne konwersje do i z `object` mają zastosowanie również do i z `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="93eb1-324">Podpisy metod, które są takie same w przypadku zastępowania `dynamic` z `object` są traktowane jako ten sam podpis</span><span class="sxs-lookup"><span data-stu-id="93eb1-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="93eb1-325">Typ `dynamic` nie można odróżnić od `object` w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="93eb1-326">Wyrażenie typu `dynamic` nazywa się ***wyrażenia dynamicznego***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="93eb1-327">Typ ciągu</span><span class="sxs-lookup"><span data-stu-id="93eb1-327">The string type</span></span>

<span data-ttu-id="93eb1-328">`string` Typ jest typem klasy zapieczętowanej, który dziedziczy bezpośrednio z `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="93eb1-329">Wystąpienia elementu `string` klasa reprezentuje ciągami znaków Unicode.</span><span class="sxs-lookup"><span data-stu-id="93eb1-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="93eb1-330">Wartości typu `string` typ może być zapisana jako literały ciągów ([Literały ciągu](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="93eb1-331">Słowo kluczowe `string` jest po prostu aliasem dla wstępnie zdefiniowanego klasy `System.String`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="93eb1-332">Typy interfejsów</span><span class="sxs-lookup"><span data-stu-id="93eb1-332">Interface types</span></span>

<span data-ttu-id="93eb1-333">Interfejs definiuje kontrakt.</span><span class="sxs-lookup"><span data-stu-id="93eb1-333">An interface defines a contract.</span></span> <span data-ttu-id="93eb1-334">Klasa lub struktura, która implementuje interfejs musi być zgodne z jego umową.</span><span class="sxs-lookup"><span data-stu-id="93eb1-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="93eb1-335">Interfejs może dziedziczyć z wielu interfejsach podstawowych, a klasa lub struktura może zaimplementować wiele interfejsów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="93eb1-336">Typy interfejsów są opisane w [interfejsów](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="93eb1-337">Typy tablic</span><span class="sxs-lookup"><span data-stu-id="93eb1-337">Array types</span></span>

<span data-ttu-id="93eb1-338">Tablica jest strukturą danych, która zawiera zero lub więcej zmiennych, które są dostępne za pośrednictwem obliczanej indeksów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="93eb1-339">Zmienne zawartych w tablicy jest określana skrótem elementy tablicy są wszystkie tego samego typu i tego typu jest nazywana typ elementu tablicy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="93eb1-340">Typy tablicowe są opisane w [tablic](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="93eb1-341">Typy delegatów</span><span class="sxs-lookup"><span data-stu-id="93eb1-341">Delegate types</span></span>

<span data-ttu-id="93eb1-342">Delegat jest strukturą danych, która odwołuje się do co najmniej jednej metody.</span><span class="sxs-lookup"><span data-stu-id="93eb1-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="93eb1-343">Na przykład metody, również odwołuje się on do ich odpowiednich wystąpień obiektu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="93eb1-344">Najbliższy wielokrotność delegata w C lub C++ jest wskaźnik funkcji, ale wskaźnika funkcji może odwoływać się tylko funkcje statyczne, obiekt delegowany może odwoływać się do statycznych i wystąpienia metody.</span><span class="sxs-lookup"><span data-stu-id="93eb1-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="93eb1-345">W tym ostatnim przypadku delegata przechowuje nie tylko odwołanie do metody punktu wejścia, ale również odwołanie do wystąpienia obiektu do wywołania metody.</span><span class="sxs-lookup"><span data-stu-id="93eb1-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="93eb1-346">Typy delegatów są opisane w [delegatów](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="93eb1-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="93eb1-347">Konwersja boxing i konwersja unboxing</span><span class="sxs-lookup"><span data-stu-id="93eb1-347">Boxing and unboxing</span></span>

<span data-ttu-id="93eb1-348">Pojęcie pakowania i rozpakowywania stanowi podstawę do w systemie typu C#.</span><span class="sxs-lookup"><span data-stu-id="93eb1-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="93eb1-349">Stanowi Most między *value_type*s i *reference_type*s, umożliwiając dowolnej wartości *value_type* do konwersji do i z typu `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="93eb1-350">Pakowanie i rozpakowywanie pozwala ujednoliconego widoku system typów, w którym wartość dowolnego typu ostatecznie mogą być traktowane jako obiekt.</span><span class="sxs-lookup"><span data-stu-id="93eb1-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="93eb1-351">Konwersje boxing</span><span class="sxs-lookup"><span data-stu-id="93eb1-351">Boxing conversions</span></span>

<span data-ttu-id="93eb1-352">Konwersja boxing pozwala *value_type* są niejawnie konwertowane na *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="93eb1-353">Istnieją następujące konwersje boxing:</span><span class="sxs-lookup"><span data-stu-id="93eb1-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="93eb1-354">Za pomocą dowolnego *value_type* typowi `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="93eb1-355">Za pomocą dowolnego *value_type* typowi `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="93eb1-356">Za pomocą dowolnego *non_nullable_value_type* do dowolnego *interface_type* implementowany przez *value_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="93eb1-357">Za pomocą dowolnego *nullable_type* do dowolnego *interface_type* implementowana przez typ podstawowy elementu *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="93eb1-358">Za pomocą dowolnego *enum_type* typowi `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="93eb1-359">Za pomocą dowolnego *nullable_type* z odpowiednią *enum_type* typowi `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="93eb1-360">Należy pamiętać, że niejawna konwersja z parametrem typu zostaną wykonane jako konwersja boxing Jeśli w czasie wykonywania kończy się konwersji z typu wartości typu odwołania ([niejawne konwersje dotyczące parametrów typu](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="93eb1-361">Konwersja boxing wartość *non_nullable_value_type* składa się z przydzielanie wystąpienia obiektu i kopiowanie *non_nullable_value_type* wartość do tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="93eb1-362">Konwersja boxing wartość *nullable_type* tworzy odwołanie o wartości null, jeśli jest `null` wartość (`HasValue` jest `false`), lub wynik rozpakowanie, a w przeciwnym razie konwersja boxing podstawową wartość.</span><span class="sxs-lookup"><span data-stu-id="93eb1-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="93eb1-363">Rzeczywisty proces konwersja boxing wartość *non_nullable_value_type* najlepiej tłumaczy opracowująca w wyobraźni istnienie ogólnego ***opakowywanie klasy***, który zachowuje się tak, jakby były zadeklarowane w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="93eb1-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="93eb1-364">OPAKOWYWANIE wartość `v` typu `T` teraz składa się z wykonującego wyrażenie `new Box<T>(v)`i zwraca wynikowy wystąpienia jako wartość typu `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="93eb1-365">W związku z tym instrukcje</span><span class="sxs-lookup"><span data-stu-id="93eb1-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="93eb1-366">koncepcyjnie odpowiadają</span><span class="sxs-lookup"><span data-stu-id="93eb1-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="93eb1-367">Klasa pakowania, takich jak `Box<T>` powyżej faktycznie nie istnieje i dynamiczny typ spakowany wartości nie jest faktycznie typu klasy.</span><span class="sxs-lookup"><span data-stu-id="93eb1-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="93eb1-368">Zamiast tego typu wartości spakowanej `T` ma typu dynamicznego `T`i wyboru typu dynamicznego przy użyciu `is` operator może po prostu odwoływać się do typu `T`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="93eb1-369">Na przykład</span><span class="sxs-lookup"><span data-stu-id="93eb1-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="93eb1-370">generuje ciąg "`Box contains an int`" na konsoli.</span><span class="sxs-lookup"><span data-stu-id="93eb1-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="93eb1-371">Konwersja boxing oznacza skopiowanie wartości jest ramce.</span><span class="sxs-lookup"><span data-stu-id="93eb1-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="93eb1-372">To różni się od wymiany *reference_type* na typ `object`, w których wartość odwoływać się do tego samego wystąpienia w dalszym ciągu i po prostu jest traktowany jako mniej pochodnego typu `object`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="93eb1-373">Na przykład biorąc pod uwagę deklaracji</span><span class="sxs-lookup"><span data-stu-id="93eb1-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="93eb1-374">Poniższe instrukcje</span><span class="sxs-lookup"><span data-stu-id="93eb1-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="93eb1-375">zwróci wartość 10 w konsoli, ponieważ operacji niejawnej konwersji boxing, która występuje w przypisanie `p` do `box` powoduje, że wartość `p` do skopiowania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="93eb1-376">Gdyby `Point` została zadeklarowana `class` zamiast tego wartość 20 będzie wynosić danych wyjściowych, ponieważ `p` i `box` będzie odwoływać się do tego samego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="93eb1-377">Konwersji rozpakowującej</span><span class="sxs-lookup"><span data-stu-id="93eb1-377">Unboxing conversions</span></span>

<span data-ttu-id="93eb1-378">Zezwala na konwersji rozpakowującej *reference_type* być jawnie konwertowane na *value_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="93eb1-379">Istnieją następujące konwersji rozpakowującej:</span><span class="sxs-lookup"><span data-stu-id="93eb1-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="93eb1-380">Z typu `object` do dowolnego *value_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="93eb1-381">Z typu `System.ValueType` do dowolnego *value_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="93eb1-382">Za pomocą dowolnego *interface_type* do dowolnego *non_nullable_value_type* implementującej *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="93eb1-383">Za pomocą dowolnego *interface_type* do dowolnego *nullable_type* implementuje o typie podstawowym *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="93eb1-384">Z typu `System.Enum` do dowolnego *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="93eb1-385">Z typu `System.Enum` do dowolnego *nullable_type* z odpowiednią *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="93eb1-386">Należy pamiętać, że konwersja jawna z parametrem typu zostanie wykonany jako konwersji rozpakowującej, jeśli w czasie wykonywania kończy się konwersja z typu odwołania do typu wartości ([jawne konwersje dynamiczne](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="93eb1-387">Operacja rozpakowania do *non_nullable_value_type* składa się z wcześniejszego sprawdzenia, że wystąpienie obiektu jest zapakowaną wartością danego *non_nullable_value_type*, a następnie skopiować wartość z wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="93eb1-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="93eb1-388">Rozpakowywanie do *nullable_type* generuje wartość null *nullable_type* operandów źródła jest `null`, lub opakowana wynik rozpakowywania wystąpienie obiektu, aby typ podstawowy elementu *nullable_type* inaczej.</span><span class="sxs-lookup"><span data-stu-id="93eb1-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="93eb1-389">Odwołujące się do klasy urojone pakowania, opisanego w poprzedniej sekcji, konwersji rozpakowującej obiektu `box` do *value_type* `T` składa się z wykonującego wyrażenie `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="93eb1-390">W związku z tym instrukcje</span><span class="sxs-lookup"><span data-stu-id="93eb1-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="93eb1-391">koncepcyjnie odpowiadają</span><span class="sxs-lookup"><span data-stu-id="93eb1-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="93eb1-392">Dla konwersji rozpakowującej do danego *non_nullable_value_type* zakończyło się sukcesem w czasie wykonywania, wartość operandu źródła musi być odwołaniem do wartości spakowanej tego *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="93eb1-393">Jeśli źródłowy argument operacji jest `null`, `System.NullReferenceException` zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="93eb1-394">Jeśli źródłowy argument operacji jest odwołaniem do obiektu niezgodne `System.InvalidCastException` zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="93eb1-395">Dla konwersji rozpakowującej do danego *nullable_type* zakończyło się sukcesem w czasie wykonywania, wartość operandu źródła musi być albo `null` lub odwołanie do wartości spakowanej podstawowych *non_nullable_value_type* z *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="93eb1-396">Jeśli źródłowy argument operacji jest odwołaniem do obiektu niezgodne `System.InvalidCastException` zgłaszany.</span><span class="sxs-lookup"><span data-stu-id="93eb1-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="93eb1-397">Typy utworzone</span><span class="sxs-lookup"><span data-stu-id="93eb1-397">Constructed types</span></span>

<span data-ttu-id="93eb1-398">Deklarację typu ogólnego, oznacza ***niepowiązany typ ogólny*** używany jako "planu" w celu utworzenia wielu różnych typów, za pomocą zastosowania ***argumentów typu***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="93eb1-399">Argumenty typu są zapisywane w nawiasach kątowych (`<` i `>`) bezpośrednio po nazwie typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="93eb1-400">Typ, który zawiera co najmniej jeden typ argumentu jest wywoływana ***skonstruowany typ***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="93eb1-401">Skonstruowany typ może służyć w większości miejsc w języku, w którym nazwa typu, który może występować.</span><span class="sxs-lookup"><span data-stu-id="93eb1-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="93eb1-402">Typu rodzajowego niezwiązanego można używać tylko wewnątrz *typeof_expression* ([typeof operator](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="93eb1-403">Typy utworzone można również w wyrażeniach jako nazwy proste ([proste nazwy](expressions.md#simple-names)) lub podczas uzyskiwania dostępu do członka ([dostęp do elementu członkowskiego](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="93eb1-404">Gdy *namespace_or_type_name* jest oceniana, tylko wewnętrzne typów przy użyciu poprawnej liczby parametrów są traktowane jako typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="93eb1-405">Dlatego jest możliwe użycie tego samego identyfikatora do identyfikacji różnych typów, tak długo, jak typy mają różną liczbę parametrów typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="93eb1-406">Jest to przydatne, gdy mieszanie ogólnych i nieogólnych klasach, w tym samym programie:</span><span class="sxs-lookup"><span data-stu-id="93eb1-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="93eb1-407">A *type_name* może identyfikować skonstruowanego typu, nawet jeśli go nie określono parametrów typu bezpośrednio.</span><span class="sxs-lookup"><span data-stu-id="93eb1-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="93eb1-408">Taka sytuacja może wystąpić, gdy typem jest zagnieżdżony w obrębie deklaracji klasy ogólnej i typu wystąpienia zawierający deklaracji niejawnie używane podczas wyszukiwania nazwy ([zagnieżdżone typy klas ogólnych](classes.md#nested-types-in-generic-classes)):</span><span class="sxs-lookup"><span data-stu-id="93eb1-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="93eb1-409">W niebezpieczny kod nie może pełnić skonstruowanego typu *unmanaged_type* ([typy wskaźników](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="93eb1-410">Argumenty typu</span><span class="sxs-lookup"><span data-stu-id="93eb1-410">Type arguments</span></span>

<span data-ttu-id="93eb1-411">Każdy argument na liście argumentów typu jest po prostu *typu*.</span><span class="sxs-lookup"><span data-stu-id="93eb1-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="93eb1-412">W niebezpieczny kod ([niebezpieczny kod](unsafe-code.md)), *type_argument* nie może być typem wskaźnika.</span><span class="sxs-lookup"><span data-stu-id="93eb1-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="93eb1-413">Każdy argument typu musi spełniać żadnych ograniczeń na odpowiedni parametr typu ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="93eb1-414">Typy otwarte i zamknięte</span><span class="sxs-lookup"><span data-stu-id="93eb1-414">Open and closed types</span></span>

<span data-ttu-id="93eb1-415">Wszystkie typy mogą być klasyfikowane jako ***Otwórz typy*** lub ***zamknięte typy***.</span><span class="sxs-lookup"><span data-stu-id="93eb1-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="93eb1-416">Otwarty typ to typ, który obejmuje parametry typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="93eb1-417">Więcej szczegółów:</span><span class="sxs-lookup"><span data-stu-id="93eb1-417">More specifically:</span></span>

*  <span data-ttu-id="93eb1-418">Parametr typu definiuje typu otwartego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="93eb1-419">Typ tablicy jest typem otwartym, tylko wtedy, gdy jego typ elementu jest typem otwartym.</span><span class="sxs-lookup"><span data-stu-id="93eb1-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="93eb1-420">Skonstruowany typ jest typem otwartym, tylko wtedy, gdy co najmniej jeden z argumentów typu jest typem otwartym.</span><span class="sxs-lookup"><span data-stu-id="93eb1-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="93eb1-421">Skonstruowany typ zagnieżdżony jest typem otwartym, tylko wtedy, gdy jeden lub więcej argumentów typu lub argumentów typu z jej typów zawierających jest typem otwartym.</span><span class="sxs-lookup"><span data-stu-id="93eb1-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="93eb1-422">Zamknięty typ jest typem, który nie jest typem otwartym.</span><span class="sxs-lookup"><span data-stu-id="93eb1-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="93eb1-423">W czasie wykonywania cały kod w obrębie deklaracji typu ogólnego jest wykonywany w kontekście zamknięte skonstruowanego typu, który został utworzony przez stosowanie argumentów typu do deklaracji ogólnej.</span><span class="sxs-lookup"><span data-stu-id="93eb1-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="93eb1-424">Każdy parametr typu w ramach typu ogólnego jest powiązany z określonego typu run-time.</span><span class="sxs-lookup"><span data-stu-id="93eb1-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="93eb1-425">Przetwarzanie czasu wykonywania wszystkich instrukcji i wyrażeń zawsze odbywa się z typami zamknięte i otwarte typy występuje tylko podczas kompilacji przetwarzania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="93eb1-426">Każdy zamknięte skonstruowanego typu ma swój własny zestaw zmiennych statycznych, które nie są współużytkowane z innymi zamknięte typy utworzone.</span><span class="sxs-lookup"><span data-stu-id="93eb1-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="93eb1-427">Od typu otwartego nie istnieje w czasie wykonywania, nie istnieją żadne statyczne zmienne skojarzone z typem otwartym.</span><span class="sxs-lookup"><span data-stu-id="93eb1-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="93eb1-428">Dwa typy utworzone zamknięte są tego samego typu, jeśli one są konstruowane na podstawie tego samego typu niepowiązanego ogólny i ich odpowiednie argumenty typu tego samego typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="93eb1-429">Powiązane i niepowiązanych typów</span><span class="sxs-lookup"><span data-stu-id="93eb1-429">Bound and unbound types</span></span>

<span data-ttu-id="93eb1-430">Termin ***niepowiązany typ*** odwołuje się do typu nieogólnego lub niepowiązanych typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="93eb1-431">Termin ***powiązany typ*** odwołuje się do typu nieogólnego lub skonstruowanego typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="93eb1-432">Typu niepowiązanego odnosi się do jednostki zadeklarowanej przez deklarację typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="93eb1-433">Typu rodzajowego niezwiązanego sam nie jest typem i nie można używać jako typ zmiennej, argumentu lub wartości zwracanej lub jako typu podstawowego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="93eb1-434">Tylko konstrukcja, w którym można się odwoływać niepowiązanych typu ogólnego jest `typeof` wyrażenia ([typeof operator](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="93eb1-435">Spełniających ograniczenia</span><span class="sxs-lookup"><span data-stu-id="93eb1-435">Satisfying constraints</span></span>

<span data-ttu-id="93eb1-436">Zawsze, gdy odwołanie do skonstruowanego typu lub metody rodzajowej, argumenty podanego typu są porównywane z ograniczeniami parametrów typu zadeklarowanych w ogólnym typie lub metodzie ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="93eb1-437">Dla każdego `where` klauzuli, argument typu `A` , który odpowiada nazwany parametr typu jest sprawdzana względem każde ograniczenie w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="93eb1-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="93eb1-438">W przypadku ograniczenia typu klasy, typ interfejsu lub parametrem typu, należy umożliwić `C` reprezentuje ograniczenie z argumentami typu podane zastępują wszystkie parametry typu, które są wyświetlane w ograniczeniu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="93eb1-439">Aby spełniać ograniczenie, musi być tak, że tekst `A` jest konwertowany na typ `C` za pomocą jednej z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="93eb1-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="93eb1-440">Konwersja tożsamości ([konwersji tożsamości](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="93eb1-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="93eb1-441">Niejawna konwersja odwołania ([konwersje niejawne odwołanie](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="93eb1-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="93eb1-442">Konwersja boxing ([konwersje Boxing](conversions.md#boxing-conversions)) pod warunkiem, że typ A jest typem wartości niedopuszczającym wartości.</span><span class="sxs-lookup"><span data-stu-id="93eb1-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="93eb1-443">Niejawna konwersja parametru odwołania, konwersji boxing lub typu z parametrem typu `A` do `C`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="93eb1-444">Jeśli ograniczenie jest ograniczenie typu odwołania (`class`), typ `A` muszą spełniać jeden z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="93eb1-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="93eb1-445">`A` jest typu interfejsu, typu klasy, typu delegata lub typu tablicowego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="93eb1-446">Należy pamiętać, że `System.ValueType` i `System.Enum` są typami odwołań, które spełniają kryteria tego ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="93eb1-447">`A` jest parametrem typu, który jest znany jako typu odwołania ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="93eb1-448">Jeśli ograniczenie jest ograniczenie typów wartości (`struct`), typ `A` muszą spełniać jeden z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="93eb1-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="93eb1-449">`A` jest typ struktury lub typu wyliczeniowego, ale nie typu dopuszczającego wartość null.</span><span class="sxs-lookup"><span data-stu-id="93eb1-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="93eb1-450">Należy pamiętać, że `System.ValueType` i `System.Enum` są typami odwołań, które nie spełniają tego ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="93eb1-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="93eb1-451">`A` jest to parametr typu o wartości ograniczenia typu ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="93eb1-452">Jeśli to ograniczenie jest ograniczenie konstruktora `new()`, typ `A` nie może być `abstract` i musi mieć publicznego konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="93eb1-453">To jest spełniony, gdy jest spełniony jeden z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="93eb1-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="93eb1-454">`A` jest typem wartości, ponieważ wszystkie typy wartości mają publicznego konstruktora domyślnego ([domyślne konstruktory](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="93eb1-455">`A` jest to parametr typu o ograniczenie konstruktora ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="93eb1-456">`A` jest to parametr typu o wartości ograniczenia typu ([ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="93eb1-457">`A` to klasa, która nie jest `abstract` i zawiera zadeklarowany w sposób jawny `public` konstruktora bez parametrów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="93eb1-458">`A` nie jest `abstract` i ma domyślnego konstruktora ([domyślne konstruktory](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="93eb1-459">Błąd kompilacji występuje, jeśli co najmniej jeden z ograniczenia parametru typu nie są spełnione przez argumenty danego typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="93eb1-460">Ponieważ parametry typu nie są dziedziczone, ograniczenia nigdy nie są dziedziczone albo.</span><span class="sxs-lookup"><span data-stu-id="93eb1-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="93eb1-461">W poniższym przykładzie `D` należy określić ograniczenie jego parametr typu `T` tak, aby `T` spełnia ograniczenia nałożone przez klasę bazową `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="93eb1-462">Z kolei klasa `E` nie trzeba określać ograniczenie, `List<T>` implementuje `IEnumerable` dla każdego `T`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="93eb1-463">Parametry typu</span><span class="sxs-lookup"><span data-stu-id="93eb1-463">Type parameters</span></span>

<span data-ttu-id="93eb1-464">Parametr typu jest identyfikatorem wyznaczania typu wartości lub typ referencyjny, powiązany z parametru w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="93eb1-465">Ponieważ parametr typu mogą być utworzone przy użyciu wielu różnych rzeczywisty typ argumentów, parametry typu mają nieco inne operacje i ograniczenia od innych typów.</span><span class="sxs-lookup"><span data-stu-id="93eb1-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="93eb1-466">Należą do nich następujące elementy:</span><span class="sxs-lookup"><span data-stu-id="93eb1-466">These include:</span></span>

*  <span data-ttu-id="93eb1-467">Parametr typu nie można bezpośrednio, aby zadeklarować klasę bazową ([klasy bazowej](classes.md#base-class)) lub interfejsu ([list parametrów typu Variant](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="93eb1-468">Reguły dotyczące wyszukać składowej w typie, czy parametry są zależne od ograniczeń, jeśli istnieje, jest stosowane do parametru typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="93eb1-469">Szczegółowo w [wyszukanie członka](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="93eb1-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="93eb1-470">Dostępne konwersje dla parametru typu są zależne od ograniczeń, ewentualnej zastosowany do parametru typu.</span><span class="sxs-lookup"><span data-stu-id="93eb1-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="93eb1-471">Szczegółowo w [niejawne konwersje dotyczące parametrów typu](conversions.md#implicit-conversions-involving-type-parameters) i [jawne konwersje dynamiczne](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="93eb1-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="93eb1-472">Literał `null` nie można przekonwertować na typ, określone przez parametr typu, z wyjątkiem, jeśli wiadomo, że parametr typu jako typów referencyjnych ([niejawne konwersje dotyczące parametrów typu](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="93eb1-473">Jednak `default` wyrażenia ([domyślna wartość wyrażenia](expressions.md#default-value-expressions)) mogą być używane zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="93eb1-474">Ponadto wartości o typie podanym przez parametru typu można porównać z `null` przy użyciu `==` i `!=` ([Operatory równości typu odwołania](expressions.md#reference-type-equality-operators)), chyba że parametr typu ma ograniczenia typu wartości.</span><span class="sxs-lookup"><span data-stu-id="93eb1-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="93eb1-475">A `new` wyrażenia ([wyrażenia tworzenia obiektów](expressions.md#object-creation-expressions)) należy używać tylko z parametrem typu Jeśli parametr typu jest ograniczony przez *constructor_constraint* lub typ ograniczenia (wartości[ Ograniczenia parametru typu](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="93eb1-476">Parametr typu nie można używać w dowolnym miejscu w atrybucie.</span><span class="sxs-lookup"><span data-stu-id="93eb1-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="93eb1-477">Parametr typu nie można używać w dostęp do elementu członkowskiego ([dostęp do elementu członkowskiego](expressions.md#member-access)) lub wpisz nazwę ([nazw Namespace i typ](basic-concepts.md#namespace-and-type-names)) do identyfikowania statycznej składowej lub typu zagnieżdżonego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="93eb1-478">W niebezpieczny kod parametr typu nie może zostać użyty jako *unmanaged_type* ([typy wskaźników](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="93eb1-479">Jako typ parametry typu są wyłącznie konstrukcję kompilacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="93eb1-480">W czasie wykonywania każdego parametru typu jest powiązany z typu run-time, który został określony poprzez dostarczenie argument typu w deklaracji typu ogólnego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="93eb1-481">Zatem typ zmiennej jest zadeklarowana z będzie parametr typu, w czasie wykonywania, będą zamknięte skonstruowanego typu ([otwarte i zamknięte typy](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="93eb1-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="93eb1-482">Wykonanie czasu wykonywania wszystkich instrukcji i wyrażeń zawierających parametry typu używa rzeczywisty typ, który został dostarczony jako argument typu dla tego parametru.</span><span class="sxs-lookup"><span data-stu-id="93eb1-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="93eb1-483">Typy drzewa wyrażeń</span><span class="sxs-lookup"><span data-stu-id="93eb1-483">Expression tree types</span></span>

<span data-ttu-id="93eb1-484">***Drzewa wyrażeń*** zezwolić wyrażenia lambda może być reprezentowana jako struktur danych, zamiast kodu wykonywalnego.</span><span class="sxs-lookup"><span data-stu-id="93eb1-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="93eb1-485">Drzewa wyrażeń są wartościami ***typy drzewa wyrażenie*** formularza `System.Linq.Expressions.Expression<D>`, gdzie `D` jest dowolny typ delegata.</span><span class="sxs-lookup"><span data-stu-id="93eb1-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="93eb1-486">W pozostałej części tej specyfikacji odnoszą się do tych typów, przy użyciu skrótu `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="93eb1-487">Jeśli istnieje konwersja z wyrażenia lambda do typu delegata `D`, istnieje również konwersji na typ drzewa wyrażenia `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="93eb1-488">Natomiast konwersji wyrażenia lambda do typu delegata generuje obiekt delegowany, który odwołuje się kod wykonywalny dla wyrażenia lambda, konwersja na typ drzewa wyrażeń tworzy reprezentację w postaci drzewa wyrażeń, wyrażenia lambda.</span><span class="sxs-lookup"><span data-stu-id="93eb1-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="93eb1-489">Drzewa wyrażeń są wydajne danych w pamięci reprezentacje wyrażeń lambda i upewnij struktury wyrażenia lambda, przejrzyste i jawne.</span><span class="sxs-lookup"><span data-stu-id="93eb1-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="93eb1-490">Podobnie jak typ delegata `D`, `Expression<D>` ma parametr i zwracane typy, które są takie same, jak z `D`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="93eb1-491">Poniższy przykład przedstawia wyrażenie lambda, zarówno kodu wykonywalnego, jak i w postaci drzewa wyrażenie.</span><span class="sxs-lookup"><span data-stu-id="93eb1-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="93eb1-492">Ponieważ istnieje konwersja `Func<int,int>`, również istnieje konwersja `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="93eb1-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="93eb1-493">Po tych przypisań delegata `del` odwołuje się do metody, która zwraca `x + 1`i drzewa wyrażeń `exp` odwołuje się do struktury danych, który opisuje wyrażenie `x => x + 1`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="93eb1-494">Dokładne definicji typu ogólnego `Expression<D>` oraz dokładne zasady Konstruowanie drzewa wyrażeń, gdy wyrażenie lambda jest konwertowany na typ drzewa wyrażenia są poza zakresem tej specyfikacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="93eb1-495">Ważne dla zapewnienia jawnego są dwie rzeczy:</span><span class="sxs-lookup"><span data-stu-id="93eb1-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="93eb1-496">Nie wszystkie wyrażenia lambda można konwertować na drzewa wyrażeń.</span><span class="sxs-lookup"><span data-stu-id="93eb1-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="93eb1-497">Na przykład nie można przedstawić wyrażeń lambda z treści instrukcji i wyrażeń lambda, zawierające wyrażenia przypisania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="93eb1-498">W takich przypadkach konwersji jest nadal istnieje, ale zakończy się niepowodzeniem w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="93eb1-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="93eb1-499">Wyjątki te są szczegółowo opisane w [konwersje funkcja anonimowa](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="93eb1-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="93eb1-500">`Expression<D>` udostępnia metodę wystąpienia `Compile` wytwarzająca delegat typu `D`:</span><span class="sxs-lookup"><span data-stu-id="93eb1-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="93eb1-501">Ten delegat wywołania powoduje, że kod reprezentowany przez drzewo wyrażenia do wykonania.</span><span class="sxs-lookup"><span data-stu-id="93eb1-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="93eb1-502">W związku z tym biorąc pod uwagę powyższe definicje, del i del2 są równoważne i dwie poniższe instrukcje mają ten sam efekt:</span><span class="sxs-lookup"><span data-stu-id="93eb1-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="93eb1-503">Po wykonaniu tego kodu `i1` i `i2` będziecie mieli wartość `2`.</span><span class="sxs-lookup"><span data-stu-id="93eb1-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

